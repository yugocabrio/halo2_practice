{"message":"method `zero` is not a member of trait `ff::Field`","code":{"code":"E0407","explanation":"A definition of a method not in the implemented trait was given in a trait\nimplementation.\n\nErroneous code example:\n\n```compile_fail,E0407\ntrait Foo {\n    fn a();\n}\n\nstruct Bar;\n\nimpl Foo for Bar {\n    fn a() {}\n    fn b() {} // error: method `b` is not a member of trait `Foo`\n}\n```\n\nPlease verify you didn't misspell the method name and you used the correct\ntrait. First example:\n\n```\ntrait Foo {\n    fn a();\n    fn b();\n}\n\nstruct Bar;\n\nimpl Foo for Bar {\n    fn a() {}\n    fn b() {} // ok!\n}\n```\n\nSecond example:\n\n```\ntrait Foo {\n    fn a();\n}\n\nstruct Bar;\n\nimpl Foo for Bar {\n    fn a() {}\n}\n\nimpl Bar {\n    fn b() {}\n}\n```\n"},"level":"error","spans":[{"file_name":"/Users/yugo/.cargo/git/checkouts/pairing-e1005e25456a4f82/868f527/src/bn256/fq.rs","byte_start":4896,"byte_end":4942,"line_start":164,"line_end":166,"column_start":5,"column_end":6,"is_primary":true,"text":[{"text":"    fn zero() -> Self {","highlight_start":5,"highlight_end":24},{"text":"        Self::zero()","highlight_start":1,"highlight_end":21},{"text":"    }","highlight_start":1,"highlight_end":6}],"label":"not a member of trait `ff::Field`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0407]\u001b[0m\u001b[0m\u001b[1m: method `zero` is not a member of trait `ff::Field`\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0m/Users/yugo/.cargo/git/checkouts/pairing-e1005e25456a4f82/868f527/src/bn256/fq.rs:164:5\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m164\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m/\u001b[0m\u001b[0m \u001b[0m\u001b[0m    fn zero() -> Self {\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m165\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m        Self::zero()\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m166\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m    }\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m|_____^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9mnot a member of trait `ff::Field`\u001b[0m\n\n"}
{"message":"method `one` is not a member of trait `ff::Field`","code":{"code":"E0407","explanation":"A definition of a method not in the implemented trait was given in a trait\nimplementation.\n\nErroneous code example:\n\n```compile_fail,E0407\ntrait Foo {\n    fn a();\n}\n\nstruct Bar;\n\nimpl Foo for Bar {\n    fn a() {}\n    fn b() {} // error: method `b` is not a member of trait `Foo`\n}\n```\n\nPlease verify you didn't misspell the method name and you used the correct\ntrait. First example:\n\n```\ntrait Foo {\n    fn a();\n    fn b();\n}\n\nstruct Bar;\n\nimpl Foo for Bar {\n    fn a() {}\n    fn b() {} // ok!\n}\n```\n\nSecond example:\n\n```\ntrait Foo {\n    fn a();\n}\n\nstruct Bar;\n\nimpl Foo for Bar {\n    fn a() {}\n}\n\nimpl Bar {\n    fn b() {}\n}\n```\n"},"level":"error","spans":[{"file_name":"/Users/yugo/.cargo/git/checkouts/pairing-e1005e25456a4f82/868f527/src/bn256/fq.rs","byte_start":4948,"byte_end":4992,"line_start":168,"line_end":170,"column_start":5,"column_end":6,"is_primary":true,"text":[{"text":"    fn one() -> Self {","highlight_start":5,"highlight_end":23},{"text":"        Self::one()","highlight_start":1,"highlight_end":20},{"text":"    }","highlight_start":1,"highlight_end":6}],"label":"not a member of trait `ff::Field`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0407]\u001b[0m\u001b[0m\u001b[1m: method `one` is not a member of trait `ff::Field`\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0m/Users/yugo/.cargo/git/checkouts/pairing-e1005e25456a4f82/868f527/src/bn256/fq.rs:168:5\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m168\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m/\u001b[0m\u001b[0m \u001b[0m\u001b[0m    fn one() -> Self {\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m169\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m        Self::one()\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m170\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m    }\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m|_____^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9mnot a member of trait `ff::Field`\u001b[0m\n\n"}
{"message":"method `multiplicative_generator` is not a member of trait `ff::PrimeField`","code":{"code":"E0407","explanation":"A definition of a method not in the implemented trait was given in a trait\nimplementation.\n\nErroneous code example:\n\n```compile_fail,E0407\ntrait Foo {\n    fn a();\n}\n\nstruct Bar;\n\nimpl Foo for Bar {\n    fn a() {}\n    fn b() {} // error: method `b` is not a member of trait `Foo`\n}\n```\n\nPlease verify you didn't misspell the method name and you used the correct\ntrait. First example:\n\n```\ntrait Foo {\n    fn a();\n    fn b();\n}\n\nstruct Bar;\n\nimpl Foo for Bar {\n    fn a() {}\n    fn b() {} // ok!\n}\n```\n\nSecond example:\n\n```\ntrait Foo {\n    fn a();\n}\n\nstruct Bar;\n\nimpl Foo for Bar {\n    fn a() {}\n}\n\nimpl Bar {\n    fn b() {}\n}\n```\n"},"level":"error","spans":[{"file_name":"/Users/yugo/.cargo/git/checkouts/pairing-e1005e25456a4f82/868f527/src/bn256/fq.rs","byte_start":7957,"byte_end":8027,"line_start":268,"line_end":270,"column_start":5,"column_end":6,"is_primary":true,"text":[{"text":"    fn multiplicative_generator() -> Self {","highlight_start":5,"highlight_end":44},{"text":"        unimplemented!()","highlight_start":1,"highlight_end":25},{"text":"    }","highlight_start":1,"highlight_end":6}],"label":"not a member of trait `ff::PrimeField`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0407]\u001b[0m\u001b[0m\u001b[1m: method `multiplicative_generator` is not a member of trait `ff::PrimeField`\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0m/Users/yugo/.cargo/git/checkouts/pairing-e1005e25456a4f82/868f527/src/bn256/fq.rs:268:5\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m268\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m/\u001b[0m\u001b[0m \u001b[0m\u001b[0m    fn multiplicative_generator() -> Self {\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m269\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m        unimplemented!()\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m270\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m    }\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m|_____^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9mnot a member of trait `ff::PrimeField`\u001b[0m\n\n"}
{"message":"method `root_of_unity` is not a member of trait `ff::PrimeField`","code":{"code":"E0407","explanation":"A definition of a method not in the implemented trait was given in a trait\nimplementation.\n\nErroneous code example:\n\n```compile_fail,E0407\ntrait Foo {\n    fn a();\n}\n\nstruct Bar;\n\nimpl Foo for Bar {\n    fn a() {}\n    fn b() {} // error: method `b` is not a member of trait `Foo`\n}\n```\n\nPlease verify you didn't misspell the method name and you used the correct\ntrait. First example:\n\n```\ntrait Foo {\n    fn a();\n    fn b();\n}\n\nstruct Bar;\n\nimpl Foo for Bar {\n    fn a() {}\n    fn b() {} // ok!\n}\n```\n\nSecond example:\n\n```\ntrait Foo {\n    fn a();\n}\n\nstruct Bar;\n\nimpl Foo for Bar {\n    fn a() {}\n}\n\nimpl Bar {\n    fn b() {}\n}\n```\n"},"level":"error","spans":[{"file_name":"/Users/yugo/.cargo/git/checkouts/pairing-e1005e25456a4f82/868f527/src/bn256/fq.rs","byte_start":8033,"byte_end":8092,"line_start":272,"line_end":274,"column_start":5,"column_end":6,"is_primary":true,"text":[{"text":"    fn root_of_unity() -> Self {","highlight_start":5,"highlight_end":33},{"text":"        unimplemented!()","highlight_start":1,"highlight_end":25},{"text":"    }","highlight_start":1,"highlight_end":6}],"label":"not a member of trait `ff::PrimeField`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0407]\u001b[0m\u001b[0m\u001b[1m: method `root_of_unity` is not a member of trait `ff::PrimeField`\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0m/Users/yugo/.cargo/git/checkouts/pairing-e1005e25456a4f82/868f527/src/bn256/fq.rs:272:5\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m272\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m/\u001b[0m\u001b[0m \u001b[0m\u001b[0m    fn root_of_unity() -> Self {\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m273\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m        unimplemented!()\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m274\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m    }\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m|_____^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9mnot a member of trait `ff::PrimeField`\u001b[0m\n\n"}
{"message":"method `zero` is not a member of trait `Field`","code":{"code":"E0407","explanation":"A definition of a method not in the implemented trait was given in a trait\nimplementation.\n\nErroneous code example:\n\n```compile_fail,E0407\ntrait Foo {\n    fn a();\n}\n\nstruct Bar;\n\nimpl Foo for Bar {\n    fn a() {}\n    fn b() {} // error: method `b` is not a member of trait `Foo`\n}\n```\n\nPlease verify you didn't misspell the method name and you used the correct\ntrait. First example:\n\n```\ntrait Foo {\n    fn a();\n    fn b();\n}\n\nstruct Bar;\n\nimpl Foo for Bar {\n    fn a() {}\n    fn b() {} // ok!\n}\n```\n\nSecond example:\n\n```\ntrait Foo {\n    fn a();\n}\n\nstruct Bar;\n\nimpl Foo for Bar {\n    fn a() {}\n}\n\nimpl Bar {\n    fn b() {}\n}\n```\n"},"level":"error","spans":[{"file_name":"/Users/yugo/.cargo/git/checkouts/pairing-e1005e25456a4f82/868f527/src/bn256/fq12.rs","byte_start":6546,"byte_end":6654,"line_start":282,"line_end":287,"column_start":5,"column_end":6,"is_primary":true,"text":[{"text":"    fn zero() -> Self {","highlight_start":5,"highlight_end":24},{"text":"        Fq12 {","highlight_start":1,"highlight_end":15},{"text":"            c0: Fq6::zero(),","highlight_start":1,"highlight_end":29},{"text":"            c1: Fq6::zero(),","highlight_start":1,"highlight_end":29},{"text":"        }","highlight_start":1,"highlight_end":10},{"text":"    }","highlight_start":1,"highlight_end":6}],"label":"not a member of trait `Field`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0407]\u001b[0m\u001b[0m\u001b[1m: method `zero` is not a member of trait `Field`\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0m/Users/yugo/.cargo/git/checkouts/pairing-e1005e25456a4f82/868f527/src/bn256/fq12.rs:282:5\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m282\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m/\u001b[0m\u001b[0m \u001b[0m\u001b[0m    fn zero() -> Self {\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m283\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m        Fq12 {\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m284\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m            c0: Fq6::zero(),\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m285\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m            c1: Fq6::zero(),\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m286\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m        }\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m287\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m    }\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m|_____^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9mnot a member of trait `Field`\u001b[0m\n\n"}
{"message":"method `one` is not a member of trait `Field`","code":{"code":"E0407","explanation":"A definition of a method not in the implemented trait was given in a trait\nimplementation.\n\nErroneous code example:\n\n```compile_fail,E0407\ntrait Foo {\n    fn a();\n}\n\nstruct Bar;\n\nimpl Foo for Bar {\n    fn a() {}\n    fn b() {} // error: method `b` is not a member of trait `Foo`\n}\n```\n\nPlease verify you didn't misspell the method name and you used the correct\ntrait. First example:\n\n```\ntrait Foo {\n    fn a();\n    fn b();\n}\n\nstruct Bar;\n\nimpl Foo for Bar {\n    fn a() {}\n    fn b() {} // ok!\n}\n```\n\nSecond example:\n\n```\ntrait Foo {\n    fn a();\n}\n\nstruct Bar;\n\nimpl Foo for Bar {\n    fn a() {}\n}\n\nimpl Bar {\n    fn b() {}\n}\n```\n"},"level":"error","spans":[{"file_name":"/Users/yugo/.cargo/git/checkouts/pairing-e1005e25456a4f82/868f527/src/bn256/fq12.rs","byte_start":6660,"byte_end":6766,"line_start":289,"line_end":294,"column_start":5,"column_end":6,"is_primary":true,"text":[{"text":"    fn one() -> Self {","highlight_start":5,"highlight_end":23},{"text":"        Fq12 {","highlight_start":1,"highlight_end":15},{"text":"            c0: Fq6::one(),","highlight_start":1,"highlight_end":28},{"text":"            c1: Fq6::zero(),","highlight_start":1,"highlight_end":29},{"text":"        }","highlight_start":1,"highlight_end":10},{"text":"    }","highlight_start":1,"highlight_end":6}],"label":"not a member of trait `Field`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0407]\u001b[0m\u001b[0m\u001b[1m: method `one` is not a member of trait `Field`\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0m/Users/yugo/.cargo/git/checkouts/pairing-e1005e25456a4f82/868f527/src/bn256/fq12.rs:289:5\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m289\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m/\u001b[0m\u001b[0m \u001b[0m\u001b[0m    fn one() -> Self {\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m290\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m        Fq12 {\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m291\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m            c0: Fq6::one(),\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m292\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m            c1: Fq6::zero(),\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m293\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m        }\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m294\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m    }\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m|_____^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9mnot a member of trait `Field`\u001b[0m\n\n"}
{"message":"method `zero` is not a member of trait `Field`","code":{"code":"E0407","explanation":"A definition of a method not in the implemented trait was given in a trait\nimplementation.\n\nErroneous code example:\n\n```compile_fail,E0407\ntrait Foo {\n    fn a();\n}\n\nstruct Bar;\n\nimpl Foo for Bar {\n    fn a() {}\n    fn b() {} // error: method `b` is not a member of trait `Foo`\n}\n```\n\nPlease verify you didn't misspell the method name and you used the correct\ntrait. First example:\n\n```\ntrait Foo {\n    fn a();\n    fn b();\n}\n\nstruct Bar;\n\nimpl Foo for Bar {\n    fn a() {}\n    fn b() {} // ok!\n}\n```\n\nSecond example:\n\n```\ntrait Foo {\n    fn a();\n}\n\nstruct Bar;\n\nimpl Foo for Bar {\n    fn a() {}\n}\n\nimpl Bar {\n    fn b() {}\n}\n```\n"},"level":"error","spans":[{"file_name":"/Users/yugo/.cargo/git/checkouts/pairing-e1005e25456a4f82/868f527/src/bn256/fq2.rs","byte_start":6986,"byte_end":7091,"line_start":310,"line_end":315,"column_start":5,"column_end":6,"is_primary":true,"text":[{"text":"    fn zero() -> Self {","highlight_start":5,"highlight_end":24},{"text":"        Fq2 {","highlight_start":1,"highlight_end":14},{"text":"            c0: Fq::zero(),","highlight_start":1,"highlight_end":28},{"text":"            c1: Fq::zero(),","highlight_start":1,"highlight_end":28},{"text":"        }","highlight_start":1,"highlight_end":10},{"text":"    }","highlight_start":1,"highlight_end":6}],"label":"not a member of trait `Field`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0407]\u001b[0m\u001b[0m\u001b[1m: method `zero` is not a member of trait `Field`\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0m/Users/yugo/.cargo/git/checkouts/pairing-e1005e25456a4f82/868f527/src/bn256/fq2.rs:310:5\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m310\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m/\u001b[0m\u001b[0m \u001b[0m\u001b[0m    fn zero() -> Self {\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m311\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m        Fq2 {\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m312\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m            c0: Fq::zero(),\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m313\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m            c1: Fq::zero(),\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m314\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m        }\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m315\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m    }\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m|_____^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9mnot a member of trait `Field`\u001b[0m\n\n"}
{"message":"method `one` is not a member of trait `Field`","code":{"code":"E0407","explanation":"A definition of a method not in the implemented trait was given in a trait\nimplementation.\n\nErroneous code example:\n\n```compile_fail,E0407\ntrait Foo {\n    fn a();\n}\n\nstruct Bar;\n\nimpl Foo for Bar {\n    fn a() {}\n    fn b() {} // error: method `b` is not a member of trait `Foo`\n}\n```\n\nPlease verify you didn't misspell the method name and you used the correct\ntrait. First example:\n\n```\ntrait Foo {\n    fn a();\n    fn b();\n}\n\nstruct Bar;\n\nimpl Foo for Bar {\n    fn a() {}\n    fn b() {} // ok!\n}\n```\n\nSecond example:\n\n```\ntrait Foo {\n    fn a();\n}\n\nstruct Bar;\n\nimpl Foo for Bar {\n    fn a() {}\n}\n\nimpl Bar {\n    fn b() {}\n}\n```\n"},"level":"error","spans":[{"file_name":"/Users/yugo/.cargo/git/checkouts/pairing-e1005e25456a4f82/868f527/src/bn256/fq2.rs","byte_start":7097,"byte_end":7200,"line_start":317,"line_end":322,"column_start":5,"column_end":6,"is_primary":true,"text":[{"text":"    fn one() -> Self {","highlight_start":5,"highlight_end":23},{"text":"        Fq2 {","highlight_start":1,"highlight_end":14},{"text":"            c0: Fq::one(),","highlight_start":1,"highlight_end":27},{"text":"            c1: Fq::zero(),","highlight_start":1,"highlight_end":28},{"text":"        }","highlight_start":1,"highlight_end":10},{"text":"    }","highlight_start":1,"highlight_end":6}],"label":"not a member of trait `Field`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0407]\u001b[0m\u001b[0m\u001b[1m: method `one` is not a member of trait `Field`\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0m/Users/yugo/.cargo/git/checkouts/pairing-e1005e25456a4f82/868f527/src/bn256/fq2.rs:317:5\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m317\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m/\u001b[0m\u001b[0m \u001b[0m\u001b[0m    fn one() -> Self {\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m318\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m        Fq2 {\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m319\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m            c0: Fq::one(),\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m320\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m            c1: Fq::zero(),\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m321\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m        }\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m322\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m    }\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m|_____^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9mnot a member of trait `Field`\u001b[0m\n\n"}
{"message":"method `zero` is not a member of trait `Field`","code":{"code":"E0407","explanation":"A definition of a method not in the implemented trait was given in a trait\nimplementation.\n\nErroneous code example:\n\n```compile_fail,E0407\ntrait Foo {\n    fn a();\n}\n\nstruct Bar;\n\nimpl Foo for Bar {\n    fn a() {}\n    fn b() {} // error: method `b` is not a member of trait `Foo`\n}\n```\n\nPlease verify you didn't misspell the method name and you used the correct\ntrait. First example:\n\n```\ntrait Foo {\n    fn a();\n    fn b();\n}\n\nstruct Bar;\n\nimpl Foo for Bar {\n    fn a() {}\n    fn b() {} // ok!\n}\n```\n\nSecond example:\n\n```\ntrait Foo {\n    fn a();\n}\n\nstruct Bar;\n\nimpl Foo for Bar {\n    fn a() {}\n}\n\nimpl Bar {\n    fn b() {}\n}\n```\n"},"level":"error","spans":[{"file_name":"/Users/yugo/.cargo/git/checkouts/pairing-e1005e25456a4f82/868f527/src/bn256/fq6.rs","byte_start":8332,"byte_end":8468,"line_start":383,"line_end":389,"column_start":5,"column_end":6,"is_primary":true,"text":[{"text":"    fn zero() -> Self {","highlight_start":5,"highlight_end":24},{"text":"        Fq6 {","highlight_start":1,"highlight_end":14},{"text":"            c0: Fq2::zero(),","highlight_start":1,"highlight_end":29},{"text":"            c1: Fq2::zero(),","highlight_start":1,"highlight_end":29},{"text":"            c2: Fq2::zero(),","highlight_start":1,"highlight_end":29},{"text":"        }","highlight_start":1,"highlight_end":10},{"text":"    }","highlight_start":1,"highlight_end":6}],"label":"not a member of trait `Field`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0407]\u001b[0m\u001b[0m\u001b[1m: method `zero` is not a member of trait `Field`\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0m/Users/yugo/.cargo/git/checkouts/pairing-e1005e25456a4f82/868f527/src/bn256/fq6.rs:383:5\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m383\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m/\u001b[0m\u001b[0m \u001b[0m\u001b[0m    fn zero() -> Self {\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m384\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m        Fq6 {\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m385\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m            c0: Fq2::zero(),\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m386\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m            c1: Fq2::zero(),\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m387\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m            c2: Fq2::zero(),\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m388\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m        }\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m389\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m    }\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m|_____^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9mnot a member of trait `Field`\u001b[0m\n\n"}
{"message":"method `one` is not a member of trait `Field`","code":{"code":"E0407","explanation":"A definition of a method not in the implemented trait was given in a trait\nimplementation.\n\nErroneous code example:\n\n```compile_fail,E0407\ntrait Foo {\n    fn a();\n}\n\nstruct Bar;\n\nimpl Foo for Bar {\n    fn a() {}\n    fn b() {} // error: method `b` is not a member of trait `Foo`\n}\n```\n\nPlease verify you didn't misspell the method name and you used the correct\ntrait. First example:\n\n```\ntrait Foo {\n    fn a();\n    fn b();\n}\n\nstruct Bar;\n\nimpl Foo for Bar {\n    fn a() {}\n    fn b() {} // ok!\n}\n```\n\nSecond example:\n\n```\ntrait Foo {\n    fn a();\n}\n\nstruct Bar;\n\nimpl Foo for Bar {\n    fn a() {}\n}\n\nimpl Bar {\n    fn b() {}\n}\n```\n"},"level":"error","spans":[{"file_name":"/Users/yugo/.cargo/git/checkouts/pairing-e1005e25456a4f82/868f527/src/bn256/fq6.rs","byte_start":8474,"byte_end":8608,"line_start":391,"line_end":397,"column_start":5,"column_end":6,"is_primary":true,"text":[{"text":"    fn one() -> Self {","highlight_start":5,"highlight_end":23},{"text":"        Fq6 {","highlight_start":1,"highlight_end":14},{"text":"            c0: Fq2::one(),","highlight_start":1,"highlight_end":28},{"text":"            c1: Fq2::zero(),","highlight_start":1,"highlight_end":29},{"text":"            c2: Fq2::zero(),","highlight_start":1,"highlight_end":29},{"text":"        }","highlight_start":1,"highlight_end":10},{"text":"    }","highlight_start":1,"highlight_end":6}],"label":"not a member of trait `Field`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0407]\u001b[0m\u001b[0m\u001b[1m: method `one` is not a member of trait `Field`\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0m/Users/yugo/.cargo/git/checkouts/pairing-e1005e25456a4f82/868f527/src/bn256/fq6.rs:391:5\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m391\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m/\u001b[0m\u001b[0m \u001b[0m\u001b[0m    fn one() -> Self {\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m392\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m        Fq6 {\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m393\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m            c0: Fq2::one(),\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m394\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m            c1: Fq2::zero(),\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m395\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m            c2: Fq2::zero(),\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m396\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m        }\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m397\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m    }\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m|_____^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9mnot a member of trait `Field`\u001b[0m\n\n"}
{"message":"method `zero` is not a member of trait `ff::Field`","code":{"code":"E0407","explanation":"A definition of a method not in the implemented trait was given in a trait\nimplementation.\n\nErroneous code example:\n\n```compile_fail,E0407\ntrait Foo {\n    fn a();\n}\n\nstruct Bar;\n\nimpl Foo for Bar {\n    fn a() {}\n    fn b() {} // error: method `b` is not a member of trait `Foo`\n}\n```\n\nPlease verify you didn't misspell the method name and you used the correct\ntrait. First example:\n\n```\ntrait Foo {\n    fn a();\n    fn b();\n}\n\nstruct Bar;\n\nimpl Foo for Bar {\n    fn a() {}\n    fn b() {} // ok!\n}\n```\n\nSecond example:\n\n```\ntrait Foo {\n    fn a();\n}\n\nstruct Bar;\n\nimpl Foo for Bar {\n    fn a() {}\n}\n\nimpl Bar {\n    fn b() {}\n}\n```\n"},"level":"error","spans":[{"file_name":"/Users/yugo/.cargo/git/checkouts/pairing-e1005e25456a4f82/868f527/src/bn256/fr.rs","byte_start":3142,"byte_end":3188,"line_start":135,"line_end":137,"column_start":5,"column_end":6,"is_primary":true,"text":[{"text":"    fn zero() -> Self {","highlight_start":5,"highlight_end":24},{"text":"        Self::zero()","highlight_start":1,"highlight_end":21},{"text":"    }","highlight_start":1,"highlight_end":6}],"label":"not a member of trait `ff::Field`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0407]\u001b[0m\u001b[0m\u001b[1m: method `zero` is not a member of trait `ff::Field`\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0m/Users/yugo/.cargo/git/checkouts/pairing-e1005e25456a4f82/868f527/src/bn256/fr.rs:135:5\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m135\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m/\u001b[0m\u001b[0m \u001b[0m\u001b[0m    fn zero() -> Self {\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m136\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m        Self::zero()\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m137\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m    }\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m|_____^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9mnot a member of trait `ff::Field`\u001b[0m\n\n"}
{"message":"method `one` is not a member of trait `ff::Field`","code":{"code":"E0407","explanation":"A definition of a method not in the implemented trait was given in a trait\nimplementation.\n\nErroneous code example:\n\n```compile_fail,E0407\ntrait Foo {\n    fn a();\n}\n\nstruct Bar;\n\nimpl Foo for Bar {\n    fn a() {}\n    fn b() {} // error: method `b` is not a member of trait `Foo`\n}\n```\n\nPlease verify you didn't misspell the method name and you used the correct\ntrait. First example:\n\n```\ntrait Foo {\n    fn a();\n    fn b();\n}\n\nstruct Bar;\n\nimpl Foo for Bar {\n    fn a() {}\n    fn b() {} // ok!\n}\n```\n\nSecond example:\n\n```\ntrait Foo {\n    fn a();\n}\n\nstruct Bar;\n\nimpl Foo for Bar {\n    fn a() {}\n}\n\nimpl Bar {\n    fn b() {}\n}\n```\n"},"level":"error","spans":[{"file_name":"/Users/yugo/.cargo/git/checkouts/pairing-e1005e25456a4f82/868f527/src/bn256/fr.rs","byte_start":3194,"byte_end":3238,"line_start":139,"line_end":141,"column_start":5,"column_end":6,"is_primary":true,"text":[{"text":"    fn one() -> Self {","highlight_start":5,"highlight_end":23},{"text":"        Self::one()","highlight_start":1,"highlight_end":20},{"text":"    }","highlight_start":1,"highlight_end":6}],"label":"not a member of trait `ff::Field`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0407]\u001b[0m\u001b[0m\u001b[1m: method `one` is not a member of trait `ff::Field`\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0m/Users/yugo/.cargo/git/checkouts/pairing-e1005e25456a4f82/868f527/src/bn256/fr.rs:139:5\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m139\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m/\u001b[0m\u001b[0m \u001b[0m\u001b[0m    fn one() -> Self {\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m140\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m        Self::one()\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m141\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m    }\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m|_____^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9mnot a member of trait `ff::Field`\u001b[0m\n\n"}
{"message":"method `multiplicative_generator` is not a member of trait `ff::PrimeField`","code":{"code":"E0407","explanation":"A definition of a method not in the implemented trait was given in a trait\nimplementation.\n\nErroneous code example:\n\n```compile_fail,E0407\ntrait Foo {\n    fn a();\n}\n\nstruct Bar;\n\nimpl Foo for Bar {\n    fn a() {}\n    fn b() {} // error: method `b` is not a member of trait `Foo`\n}\n```\n\nPlease verify you didn't misspell the method name and you used the correct\ntrait. First example:\n\n```\ntrait Foo {\n    fn a();\n    fn b();\n}\n\nstruct Bar;\n\nimpl Foo for Bar {\n    fn a() {}\n    fn b() {} // ok!\n}\n```\n\nSecond example:\n\n```\ntrait Foo {\n    fn a();\n}\n\nstruct Bar;\n\nimpl Foo for Bar {\n    fn a() {}\n}\n\nimpl Bar {\n    fn b() {}\n}\n```\n"},"level":"error","spans":[{"file_name":"/Users/yugo/.cargo/git/checkouts/pairing-e1005e25456a4f82/868f527/src/bn256/fr.rs","byte_start":5987,"byte_end":6050,"line_start":230,"line_end":232,"column_start":5,"column_end":6,"is_primary":true,"text":[{"text":"    fn multiplicative_generator() -> Self {","highlight_start":5,"highlight_end":44},{"text":"        GENERATOR","highlight_start":1,"highlight_end":18},{"text":"    }","highlight_start":1,"highlight_end":6}],"label":"not a member of trait `ff::PrimeField`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0407]\u001b[0m\u001b[0m\u001b[1m: method `multiplicative_generator` is not a member of trait `ff::PrimeField`\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0m/Users/yugo/.cargo/git/checkouts/pairing-e1005e25456a4f82/868f527/src/bn256/fr.rs:230:5\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m230\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m/\u001b[0m\u001b[0m \u001b[0m\u001b[0m    fn multiplicative_generator() -> Self {\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m231\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m        GENERATOR\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m232\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m    }\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m|_____^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9mnot a member of trait `ff::PrimeField`\u001b[0m\n\n"}
{"message":"method `root_of_unity` is not a member of trait `ff::PrimeField`","code":{"code":"E0407","explanation":"A definition of a method not in the implemented trait was given in a trait\nimplementation.\n\nErroneous code example:\n\n```compile_fail,E0407\ntrait Foo {\n    fn a();\n}\n\nstruct Bar;\n\nimpl Foo for Bar {\n    fn a() {}\n    fn b() {} // error: method `b` is not a member of trait `Foo`\n}\n```\n\nPlease verify you didn't misspell the method name and you used the correct\ntrait. First example:\n\n```\ntrait Foo {\n    fn a();\n    fn b();\n}\n\nstruct Bar;\n\nimpl Foo for Bar {\n    fn a() {}\n    fn b() {} // ok!\n}\n```\n\nSecond example:\n\n```\ntrait Foo {\n    fn a();\n}\n\nstruct Bar;\n\nimpl Foo for Bar {\n    fn a() {}\n}\n\nimpl Bar {\n    fn b() {}\n}\n```\n"},"level":"error","spans":[{"file_name":"/Users/yugo/.cargo/git/checkouts/pairing-e1005e25456a4f82/868f527/src/bn256/fr.rs","byte_start":6056,"byte_end":6112,"line_start":234,"line_end":236,"column_start":5,"column_end":6,"is_primary":true,"text":[{"text":"    fn root_of_unity() -> Self {","highlight_start":5,"highlight_end":33},{"text":"        ROOT_OF_UNITY","highlight_start":1,"highlight_end":22},{"text":"    }","highlight_start":1,"highlight_end":6}],"label":"not a member of trait `ff::PrimeField`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0407]\u001b[0m\u001b[0m\u001b[1m: method `root_of_unity` is not a member of trait `ff::PrimeField`\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0m/Users/yugo/.cargo/git/checkouts/pairing-e1005e25456a4f82/868f527/src/bn256/fr.rs:234:5\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m234\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m/\u001b[0m\u001b[0m \u001b[0m\u001b[0m    fn root_of_unity() -> Self {\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m235\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m        ROOT_OF_UNITY\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m236\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m    }\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m|_____^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9mnot a member of trait `ff::PrimeField`\u001b[0m\n\n"}
{"message":"a value of type `fq::Fq` cannot be made by multiplying all elements of type `&'a fq::Fq` from an iterator","code":{"code":"E0277","explanation":"You tried to use a type which doesn't implement some trait in a place which\nexpected that trait.\n\nErroneous code example:\n\n```compile_fail,E0277\n// here we declare the Foo trait with a bar method\ntrait Foo {\n    fn bar(&self);\n}\n\n// we now declare a function which takes an object implementing the Foo trait\nfn some_func<T: Foo>(foo: T) {\n    foo.bar();\n}\n\nfn main() {\n    // we now call the method with the i32 type, which doesn't implement\n    // the Foo trait\n    some_func(5i32); // error: the trait bound `i32 : Foo` is not satisfied\n}\n```\n\nIn order to fix this error, verify that the type you're using does implement\nthe trait. Example:\n\n```\ntrait Foo {\n    fn bar(&self);\n}\n\n// we implement the trait on the i32 type\nimpl Foo for i32 {\n    fn bar(&self) {}\n}\n\nfn some_func<T: Foo>(foo: T) {\n    foo.bar(); // we can now use this method since i32 implements the\n               // Foo trait\n}\n\nfn main() {\n    some_func(5i32); // ok!\n}\n```\n\nOr in a generic context, an erroneous code example would look like:\n\n```compile_fail,E0277\nfn some_func<T>(foo: T) {\n    println!(\"{:?}\", foo); // error: the trait `core::fmt::Debug` is not\n                           //        implemented for the type `T`\n}\n\nfn main() {\n    // We now call the method with the i32 type,\n    // which *does* implement the Debug trait.\n    some_func(5i32);\n}\n```\n\nNote that the error here is in the definition of the generic function. Although\nwe only call it with a parameter that does implement `Debug`, the compiler\nstill rejects the function. It must work with all possible input types. In\norder to make this example compile, we need to restrict the generic type we're\naccepting:\n\n```\nuse std::fmt;\n\n// Restrict the input type to types that implement Debug.\nfn some_func<T: fmt::Debug>(foo: T) {\n    println!(\"{:?}\", foo);\n}\n\nfn main() {\n    // Calling the method is still fine, as i32 implements Debug.\n    some_func(5i32);\n\n    // This would fail to compile now:\n    // struct WithoutDebug;\n    // some_func(WithoutDebug);\n}\n```\n\nRust only looks at the signature of the called function, as such it must\nalready specify all requirements that will be used for every type parameter.\n"},"level":"error","spans":[{"file_name":"/Users/yugo/.cargo/git/checkouts/pairing-e1005e25456a4f82/868f527/src/bn256/common.rs","byte_start":17937,"byte_end":17943,"line_start":439,"line_end":439,"column_start":26,"column_end":32,"is_primary":true,"text":[{"text":"        impl BaseExt for $field {","highlight_start":26,"highlight_end":32}],"label":"value of type `fq::Fq` cannot be made by multiplying all elements from a `std::iter::Iterator<Item=&'a fq::Fq>`","suggested_replacement":null,"suggestion_applicability":null,"expansion":{"span":{"file_name":"/Users/yugo/.cargo/git/checkouts/pairing-e1005e25456a4f82/868f527/src/bn256/fq.rs","byte_start":1766,"byte_end":1889,"line_start":70,"line_end":79,"column_start":1,"column_end":2,"is_primary":false,"text":[{"text":"common_field!(","highlight_start":1,"highlight_end":15},{"text":"    Fq,","highlight_start":1,"highlight_end":8},{"text":"    MODULUS,","highlight_start":1,"highlight_end":13},{"text":"    INV,","highlight_start":1,"highlight_end":9},{"text":"    BASEEXT_MODULUS,","highlight_start":1,"highlight_end":21},{"text":"    TWO_INV,","highlight_start":1,"highlight_end":13},{"text":"    ROOT_OF_UNITY_INV,","highlight_start":1,"highlight_end":23},{"text":"    DELTA,","highlight_start":1,"highlight_end":11},{"text":"    ZETA","highlight_start":1,"highlight_end":9},{"text":");","highlight_start":1,"highlight_end":2}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null},"macro_decl_name":"common_field!","def_site_span":{"file_name":"/Users/yugo/.cargo/git/checkouts/pairing-e1005e25456a4f82/868f527/src/bn256/common.rs","byte_start":0,"byte_end":25,"line_start":1,"line_end":1,"column_start":1,"column_end":26,"is_primary":false,"text":[{"text":"macro_rules! common_field {","highlight_start":1,"highlight_end":26}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}}}],"children":[{"message":"the trait `for<'a> Product<&'a fq::Fq>` is not implemented for `fq::Fq`","code":null,"level":"help","spans":[],"children":[],"rendered":null},{"message":"the following other types implement trait `Product<A>`:\n  <Option<T> as Product<Option<U>>>\n  <Result<T, E> as Product<Result<U, E>>>\n  <Simd<f32, LANES> as Product<&'a Simd<f32, LANES>>>\n  <Simd<f32, LANES> as Product>\n  <Simd<f64, LANES> as Product<&'a Simd<f64, LANES>>>\n  <Simd<f64, LANES> as Product>\n  <Simd<i16, LANES> as Product<&'a Simd<i16, LANES>>>\n  <Simd<i16, LANES> as Product>\nand 70 others","code":null,"level":"help","spans":[],"children":[],"rendered":null},{"message":"required for `fq::Fq` to implement `ff::Field`","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"required by a bound in `fields::BaseExt`","code":null,"level":"note","spans":[{"file_name":"/Users/yugo/.cargo/git/checkouts/pairing-e1005e25456a4f82/868f527/src/arithmetic/fields.rs","byte_start":422,"byte_end":431,"line_start":15,"line_end":15,"column_start":20,"column_end":29,"is_primary":true,"text":[{"text":"pub trait BaseExt: ff::Field + Ord + ConstantTimeEq {","highlight_start":20,"highlight_end":29}],"label":"required by this bound in `BaseExt`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0277]\u001b[0m\u001b[0m\u001b[1m: a value of type `fq::Fq` cannot be made by multiplying all elements of type `&'a fq::Fq` from an iterator\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0m/Users/yugo/.cargo/git/checkouts/pairing-e1005e25456a4f82/868f527/src/bn256/common.rs:439:26\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m439\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m   \u001b[0m\u001b[0m        impl BaseExt for $field {\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m                           \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^^^^^^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9mvalue of type `fq::Fq` cannot be made by multiplying all elements from a `std::iter::Iterator<Item=&'a fq::Fq>`\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m::: \u001b[0m\u001b[0m/Users/yugo/.cargo/git/checkouts/pairing-e1005e25456a4f82/868f527/src/bn256/fq.rs:70:1\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m70\u001b[0m\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m/\u001b[0m\u001b[0m \u001b[0m\u001b[0mcommon_field!(\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m71\u001b[0m\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m    Fq,\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m72\u001b[0m\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m    MODULUS,\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m73\u001b[0m\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m    INV,\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m...\u001b[0m\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m78\u001b[0m\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m    ZETA\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m79\u001b[0m\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m);\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|_-\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12min this macro invocation\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mhelp\u001b[0m\u001b[0m: the trait `for<'a> Product<&'a fq::Fq>` is not implemented for `fq::Fq`\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mhelp\u001b[0m\u001b[0m: the following other types implement trait `Product<A>`:\u001b[0m\n\u001b[0m              <Option<T> as Product<Option<U>>>\u001b[0m\n\u001b[0m              <Result<T, E> as Product<Result<U, E>>>\u001b[0m\n\u001b[0m              <Simd<f32, LANES> as Product<&'a Simd<f32, LANES>>>\u001b[0m\n\u001b[0m              <Simd<f32, LANES> as Product>\u001b[0m\n\u001b[0m              <Simd<f64, LANES> as Product<&'a Simd<f64, LANES>>>\u001b[0m\n\u001b[0m              <Simd<f64, LANES> as Product>\u001b[0m\n\u001b[0m              <Simd<i16, LANES> as Product<&'a Simd<i16, LANES>>>\u001b[0m\n\u001b[0m              <Simd<i16, LANES> as Product>\u001b[0m\n\u001b[0m            and 70 others\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mnote\u001b[0m\u001b[0m: required for `fq::Fq` to implement `ff::Field`\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;10mnote\u001b[0m\u001b[0m: required by a bound in `fields::BaseExt`\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0m/Users/yugo/.cargo/git/checkouts/pairing-e1005e25456a4f82/868f527/src/arithmetic/fields.rs:15:20\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m15\u001b[0m\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0mpub trait BaseExt: ff::Field + Ord + ConstantTimeEq {\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m                   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;10m^^^^^^^^^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;10mrequired by this bound in `BaseExt`\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mnote\u001b[0m\u001b[0m: this error originates in the macro `common_field` (in Nightly builds, run with -Z macro-backtrace for more info)\u001b[0m\n\n"}
{"message":"a value of type `fq::Fq` cannot be made by summing an iterator over elements of type `&'a fq::Fq`","code":{"code":"E0277","explanation":"You tried to use a type which doesn't implement some trait in a place which\nexpected that trait.\n\nErroneous code example:\n\n```compile_fail,E0277\n// here we declare the Foo trait with a bar method\ntrait Foo {\n    fn bar(&self);\n}\n\n// we now declare a function which takes an object implementing the Foo trait\nfn some_func<T: Foo>(foo: T) {\n    foo.bar();\n}\n\nfn main() {\n    // we now call the method with the i32 type, which doesn't implement\n    // the Foo trait\n    some_func(5i32); // error: the trait bound `i32 : Foo` is not satisfied\n}\n```\n\nIn order to fix this error, verify that the type you're using does implement\nthe trait. Example:\n\n```\ntrait Foo {\n    fn bar(&self);\n}\n\n// we implement the trait on the i32 type\nimpl Foo for i32 {\n    fn bar(&self) {}\n}\n\nfn some_func<T: Foo>(foo: T) {\n    foo.bar(); // we can now use this method since i32 implements the\n               // Foo trait\n}\n\nfn main() {\n    some_func(5i32); // ok!\n}\n```\n\nOr in a generic context, an erroneous code example would look like:\n\n```compile_fail,E0277\nfn some_func<T>(foo: T) {\n    println!(\"{:?}\", foo); // error: the trait `core::fmt::Debug` is not\n                           //        implemented for the type `T`\n}\n\nfn main() {\n    // We now call the method with the i32 type,\n    // which *does* implement the Debug trait.\n    some_func(5i32);\n}\n```\n\nNote that the error here is in the definition of the generic function. Although\nwe only call it with a parameter that does implement `Debug`, the compiler\nstill rejects the function. It must work with all possible input types. In\norder to make this example compile, we need to restrict the generic type we're\naccepting:\n\n```\nuse std::fmt;\n\n// Restrict the input type to types that implement Debug.\nfn some_func<T: fmt::Debug>(foo: T) {\n    println!(\"{:?}\", foo);\n}\n\nfn main() {\n    // Calling the method is still fine, as i32 implements Debug.\n    some_func(5i32);\n\n    // This would fail to compile now:\n    // struct WithoutDebug;\n    // some_func(WithoutDebug);\n}\n```\n\nRust only looks at the signature of the called function, as such it must\nalready specify all requirements that will be used for every type parameter.\n"},"level":"error","spans":[{"file_name":"/Users/yugo/.cargo/git/checkouts/pairing-e1005e25456a4f82/868f527/src/bn256/common.rs","byte_start":17937,"byte_end":17943,"line_start":439,"line_end":439,"column_start":26,"column_end":32,"is_primary":true,"text":[{"text":"        impl BaseExt for $field {","highlight_start":26,"highlight_end":32}],"label":"value of type `fq::Fq` cannot be made by summing a `std::iter::Iterator<Item=&'a fq::Fq>`","suggested_replacement":null,"suggestion_applicability":null,"expansion":{"span":{"file_name":"/Users/yugo/.cargo/git/checkouts/pairing-e1005e25456a4f82/868f527/src/bn256/fq.rs","byte_start":1766,"byte_end":1889,"line_start":70,"line_end":79,"column_start":1,"column_end":2,"is_primary":false,"text":[{"text":"common_field!(","highlight_start":1,"highlight_end":15},{"text":"    Fq,","highlight_start":1,"highlight_end":8},{"text":"    MODULUS,","highlight_start":1,"highlight_end":13},{"text":"    INV,","highlight_start":1,"highlight_end":9},{"text":"    BASEEXT_MODULUS,","highlight_start":1,"highlight_end":21},{"text":"    TWO_INV,","highlight_start":1,"highlight_end":13},{"text":"    ROOT_OF_UNITY_INV,","highlight_start":1,"highlight_end":23},{"text":"    DELTA,","highlight_start":1,"highlight_end":11},{"text":"    ZETA","highlight_start":1,"highlight_end":9},{"text":");","highlight_start":1,"highlight_end":2}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null},"macro_decl_name":"common_field!","def_site_span":{"file_name":"/Users/yugo/.cargo/git/checkouts/pairing-e1005e25456a4f82/868f527/src/bn256/common.rs","byte_start":0,"byte_end":25,"line_start":1,"line_end":1,"column_start":1,"column_end":26,"is_primary":false,"text":[{"text":"macro_rules! common_field {","highlight_start":1,"highlight_end":26}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}}}],"children":[{"message":"the trait `for<'a> Sum<&'a fq::Fq>` is not implemented for `fq::Fq`","code":null,"level":"help","spans":[],"children":[],"rendered":null},{"message":"the following other types implement trait `Sum<A>`:\n  <Duration as Sum<&'a Duration>>\n  <Duration as Sum>\n  <Gt as Sum<T>>\n  <Option<T> as Sum<Option<U>>>\n  <Result<T, E> as Sum<Result<U, E>>>\n  <Simd<f32, LANES> as Sum<&'a Simd<f32, LANES>>>\n  <Simd<f32, LANES> as Sum>\n  <Simd<f64, LANES> as Sum<&'a Simd<f64, LANES>>>\nand 76 others","code":null,"level":"help","spans":[],"children":[],"rendered":null},{"message":"required for `fq::Fq` to implement `ff::Field`","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"required by a bound in `fields::BaseExt`","code":null,"level":"note","spans":[{"file_name":"/Users/yugo/.cargo/git/checkouts/pairing-e1005e25456a4f82/868f527/src/arithmetic/fields.rs","byte_start":422,"byte_end":431,"line_start":15,"line_end":15,"column_start":20,"column_end":29,"is_primary":true,"text":[{"text":"pub trait BaseExt: ff::Field + Ord + ConstantTimeEq {","highlight_start":20,"highlight_end":29}],"label":"required by this bound in `BaseExt`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0277]\u001b[0m\u001b[0m\u001b[1m: a value of type `fq::Fq` cannot be made by summing an iterator over elements of type `&'a fq::Fq`\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0m/Users/yugo/.cargo/git/checkouts/pairing-e1005e25456a4f82/868f527/src/bn256/common.rs:439:26\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m439\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m   \u001b[0m\u001b[0m        impl BaseExt for $field {\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m                           \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^^^^^^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9mvalue of type `fq::Fq` cannot be made by summing a `std::iter::Iterator<Item=&'a fq::Fq>`\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m::: \u001b[0m\u001b[0m/Users/yugo/.cargo/git/checkouts/pairing-e1005e25456a4f82/868f527/src/bn256/fq.rs:70:1\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m70\u001b[0m\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m/\u001b[0m\u001b[0m \u001b[0m\u001b[0mcommon_field!(\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m71\u001b[0m\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m    Fq,\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m72\u001b[0m\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m    MODULUS,\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m73\u001b[0m\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m    INV,\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m...\u001b[0m\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m78\u001b[0m\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m    ZETA\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m79\u001b[0m\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m);\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|_-\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12min this macro invocation\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mhelp\u001b[0m\u001b[0m: the trait `for<'a> Sum<&'a fq::Fq>` is not implemented for `fq::Fq`\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mhelp\u001b[0m\u001b[0m: the following other types implement trait `Sum<A>`:\u001b[0m\n\u001b[0m              <Duration as Sum<&'a Duration>>\u001b[0m\n\u001b[0m              <Duration as Sum>\u001b[0m\n\u001b[0m              <Gt as Sum<T>>\u001b[0m\n\u001b[0m              <Option<T> as Sum<Option<U>>>\u001b[0m\n\u001b[0m              <Result<T, E> as Sum<Result<U, E>>>\u001b[0m\n\u001b[0m              <Simd<f32, LANES> as Sum<&'a Simd<f32, LANES>>>\u001b[0m\n\u001b[0m              <Simd<f32, LANES> as Sum>\u001b[0m\n\u001b[0m              <Simd<f64, LANES> as Sum<&'a Simd<f64, LANES>>>\u001b[0m\n\u001b[0m            and 76 others\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mnote\u001b[0m\u001b[0m: required for `fq::Fq` to implement `ff::Field`\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;10mnote\u001b[0m\u001b[0m: required by a bound in `fields::BaseExt`\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0m/Users/yugo/.cargo/git/checkouts/pairing-e1005e25456a4f82/868f527/src/arithmetic/fields.rs:15:20\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m15\u001b[0m\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0mpub trait BaseExt: ff::Field + Ord + ConstantTimeEq {\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m                   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;10m^^^^^^^^^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;10mrequired by this bound in `BaseExt`\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mnote\u001b[0m\u001b[0m: this error originates in the macro `common_field` (in Nightly builds, run with -Z macro-backtrace for more info)\u001b[0m\n\n"}
{"message":"a value of type `fq::Fq` cannot be made by multiplying all elements of type `fq::Fq` from an iterator","code":{"code":"E0277","explanation":"You tried to use a type which doesn't implement some trait in a place which\nexpected that trait.\n\nErroneous code example:\n\n```compile_fail,E0277\n// here we declare the Foo trait with a bar method\ntrait Foo {\n    fn bar(&self);\n}\n\n// we now declare a function which takes an object implementing the Foo trait\nfn some_func<T: Foo>(foo: T) {\n    foo.bar();\n}\n\nfn main() {\n    // we now call the method with the i32 type, which doesn't implement\n    // the Foo trait\n    some_func(5i32); // error: the trait bound `i32 : Foo` is not satisfied\n}\n```\n\nIn order to fix this error, verify that the type you're using does implement\nthe trait. Example:\n\n```\ntrait Foo {\n    fn bar(&self);\n}\n\n// we implement the trait on the i32 type\nimpl Foo for i32 {\n    fn bar(&self) {}\n}\n\nfn some_func<T: Foo>(foo: T) {\n    foo.bar(); // we can now use this method since i32 implements the\n               // Foo trait\n}\n\nfn main() {\n    some_func(5i32); // ok!\n}\n```\n\nOr in a generic context, an erroneous code example would look like:\n\n```compile_fail,E0277\nfn some_func<T>(foo: T) {\n    println!(\"{:?}\", foo); // error: the trait `core::fmt::Debug` is not\n                           //        implemented for the type `T`\n}\n\nfn main() {\n    // We now call the method with the i32 type,\n    // which *does* implement the Debug trait.\n    some_func(5i32);\n}\n```\n\nNote that the error here is in the definition of the generic function. Although\nwe only call it with a parameter that does implement `Debug`, the compiler\nstill rejects the function. It must work with all possible input types. In\norder to make this example compile, we need to restrict the generic type we're\naccepting:\n\n```\nuse std::fmt;\n\n// Restrict the input type to types that implement Debug.\nfn some_func<T: fmt::Debug>(foo: T) {\n    println!(\"{:?}\", foo);\n}\n\nfn main() {\n    // Calling the method is still fine, as i32 implements Debug.\n    some_func(5i32);\n\n    // This would fail to compile now:\n    // struct WithoutDebug;\n    // some_func(WithoutDebug);\n}\n```\n\nRust only looks at the signature of the called function, as such it must\nalready specify all requirements that will be used for every type parameter.\n"},"level":"error","spans":[{"file_name":"/Users/yugo/.cargo/git/checkouts/pairing-e1005e25456a4f82/868f527/src/bn256/common.rs","byte_start":17937,"byte_end":17943,"line_start":439,"line_end":439,"column_start":26,"column_end":32,"is_primary":true,"text":[{"text":"        impl BaseExt for $field {","highlight_start":26,"highlight_end":32}],"label":"value of type `fq::Fq` cannot be made by multiplying all elements from a `std::iter::Iterator<Item=fq::Fq>`","suggested_replacement":null,"suggestion_applicability":null,"expansion":{"span":{"file_name":"/Users/yugo/.cargo/git/checkouts/pairing-e1005e25456a4f82/868f527/src/bn256/fq.rs","byte_start":1766,"byte_end":1889,"line_start":70,"line_end":79,"column_start":1,"column_end":2,"is_primary":false,"text":[{"text":"common_field!(","highlight_start":1,"highlight_end":15},{"text":"    Fq,","highlight_start":1,"highlight_end":8},{"text":"    MODULUS,","highlight_start":1,"highlight_end":13},{"text":"    INV,","highlight_start":1,"highlight_end":9},{"text":"    BASEEXT_MODULUS,","highlight_start":1,"highlight_end":21},{"text":"    TWO_INV,","highlight_start":1,"highlight_end":13},{"text":"    ROOT_OF_UNITY_INV,","highlight_start":1,"highlight_end":23},{"text":"    DELTA,","highlight_start":1,"highlight_end":11},{"text":"    ZETA","highlight_start":1,"highlight_end":9},{"text":");","highlight_start":1,"highlight_end":2}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null},"macro_decl_name":"common_field!","def_site_span":{"file_name":"/Users/yugo/.cargo/git/checkouts/pairing-e1005e25456a4f82/868f527/src/bn256/common.rs","byte_start":0,"byte_end":25,"line_start":1,"line_end":1,"column_start":1,"column_end":26,"is_primary":false,"text":[{"text":"macro_rules! common_field {","highlight_start":1,"highlight_end":26}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}}}],"children":[{"message":"the trait `Product` is not implemented for `fq::Fq`","code":null,"level":"help","spans":[],"children":[],"rendered":null},{"message":"the following other types implement trait `Product<A>`:\n  <Option<T> as Product<Option<U>>>\n  <Result<T, E> as Product<Result<U, E>>>\n  <Simd<f32, LANES> as Product<&'a Simd<f32, LANES>>>\n  <Simd<f32, LANES> as Product>\n  <Simd<f64, LANES> as Product<&'a Simd<f64, LANES>>>\n  <Simd<f64, LANES> as Product>\n  <Simd<i16, LANES> as Product<&'a Simd<i16, LANES>>>\n  <Simd<i16, LANES> as Product>\nand 70 others","code":null,"level":"help","spans":[],"children":[],"rendered":null},{"message":"required for `fq::Fq` to implement `ff::Field`","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"required by a bound in `fields::BaseExt`","code":null,"level":"note","spans":[{"file_name":"/Users/yugo/.cargo/git/checkouts/pairing-e1005e25456a4f82/868f527/src/arithmetic/fields.rs","byte_start":422,"byte_end":431,"line_start":15,"line_end":15,"column_start":20,"column_end":29,"is_primary":true,"text":[{"text":"pub trait BaseExt: ff::Field + Ord + ConstantTimeEq {","highlight_start":20,"highlight_end":29}],"label":"required by this bound in `BaseExt`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0277]\u001b[0m\u001b[0m\u001b[1m: a value of type `fq::Fq` cannot be made by multiplying all elements of type `fq::Fq` from an iterator\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0m/Users/yugo/.cargo/git/checkouts/pairing-e1005e25456a4f82/868f527/src/bn256/common.rs:439:26\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m439\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m   \u001b[0m\u001b[0m        impl BaseExt for $field {\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m                           \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^^^^^^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9mvalue of type `fq::Fq` cannot be made by multiplying all elements from a `std::iter::Iterator<Item=fq::Fq>`\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m::: \u001b[0m\u001b[0m/Users/yugo/.cargo/git/checkouts/pairing-e1005e25456a4f82/868f527/src/bn256/fq.rs:70:1\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m70\u001b[0m\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m/\u001b[0m\u001b[0m \u001b[0m\u001b[0mcommon_field!(\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m71\u001b[0m\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m    Fq,\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m72\u001b[0m\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m    MODULUS,\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m73\u001b[0m\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m    INV,\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m...\u001b[0m\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m78\u001b[0m\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m    ZETA\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m79\u001b[0m\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m);\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|_-\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12min this macro invocation\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mhelp\u001b[0m\u001b[0m: the trait `Product` is not implemented for `fq::Fq`\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mhelp\u001b[0m\u001b[0m: the following other types implement trait `Product<A>`:\u001b[0m\n\u001b[0m              <Option<T> as Product<Option<U>>>\u001b[0m\n\u001b[0m              <Result<T, E> as Product<Result<U, E>>>\u001b[0m\n\u001b[0m              <Simd<f32, LANES> as Product<&'a Simd<f32, LANES>>>\u001b[0m\n\u001b[0m              <Simd<f32, LANES> as Product>\u001b[0m\n\u001b[0m              <Simd<f64, LANES> as Product<&'a Simd<f64, LANES>>>\u001b[0m\n\u001b[0m              <Simd<f64, LANES> as Product>\u001b[0m\n\u001b[0m              <Simd<i16, LANES> as Product<&'a Simd<i16, LANES>>>\u001b[0m\n\u001b[0m              <Simd<i16, LANES> as Product>\u001b[0m\n\u001b[0m            and 70 others\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mnote\u001b[0m\u001b[0m: required for `fq::Fq` to implement `ff::Field`\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;10mnote\u001b[0m\u001b[0m: required by a bound in `fields::BaseExt`\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0m/Users/yugo/.cargo/git/checkouts/pairing-e1005e25456a4f82/868f527/src/arithmetic/fields.rs:15:20\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m15\u001b[0m\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0mpub trait BaseExt: ff::Field + Ord + ConstantTimeEq {\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m                   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;10m^^^^^^^^^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;10mrequired by this bound in `BaseExt`\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mnote\u001b[0m\u001b[0m: this error originates in the macro `common_field` (in Nightly builds, run with -Z macro-backtrace for more info)\u001b[0m\n\n"}
{"message":"a value of type `fq::Fq` cannot be made by summing an iterator over elements of type `fq::Fq`","code":{"code":"E0277","explanation":"You tried to use a type which doesn't implement some trait in a place which\nexpected that trait.\n\nErroneous code example:\n\n```compile_fail,E0277\n// here we declare the Foo trait with a bar method\ntrait Foo {\n    fn bar(&self);\n}\n\n// we now declare a function which takes an object implementing the Foo trait\nfn some_func<T: Foo>(foo: T) {\n    foo.bar();\n}\n\nfn main() {\n    // we now call the method with the i32 type, which doesn't implement\n    // the Foo trait\n    some_func(5i32); // error: the trait bound `i32 : Foo` is not satisfied\n}\n```\n\nIn order to fix this error, verify that the type you're using does implement\nthe trait. Example:\n\n```\ntrait Foo {\n    fn bar(&self);\n}\n\n// we implement the trait on the i32 type\nimpl Foo for i32 {\n    fn bar(&self) {}\n}\n\nfn some_func<T: Foo>(foo: T) {\n    foo.bar(); // we can now use this method since i32 implements the\n               // Foo trait\n}\n\nfn main() {\n    some_func(5i32); // ok!\n}\n```\n\nOr in a generic context, an erroneous code example would look like:\n\n```compile_fail,E0277\nfn some_func<T>(foo: T) {\n    println!(\"{:?}\", foo); // error: the trait `core::fmt::Debug` is not\n                           //        implemented for the type `T`\n}\n\nfn main() {\n    // We now call the method with the i32 type,\n    // which *does* implement the Debug trait.\n    some_func(5i32);\n}\n```\n\nNote that the error here is in the definition of the generic function. Although\nwe only call it with a parameter that does implement `Debug`, the compiler\nstill rejects the function. It must work with all possible input types. In\norder to make this example compile, we need to restrict the generic type we're\naccepting:\n\n```\nuse std::fmt;\n\n// Restrict the input type to types that implement Debug.\nfn some_func<T: fmt::Debug>(foo: T) {\n    println!(\"{:?}\", foo);\n}\n\nfn main() {\n    // Calling the method is still fine, as i32 implements Debug.\n    some_func(5i32);\n\n    // This would fail to compile now:\n    // struct WithoutDebug;\n    // some_func(WithoutDebug);\n}\n```\n\nRust only looks at the signature of the called function, as such it must\nalready specify all requirements that will be used for every type parameter.\n"},"level":"error","spans":[{"file_name":"/Users/yugo/.cargo/git/checkouts/pairing-e1005e25456a4f82/868f527/src/bn256/common.rs","byte_start":17937,"byte_end":17943,"line_start":439,"line_end":439,"column_start":26,"column_end":32,"is_primary":true,"text":[{"text":"        impl BaseExt for $field {","highlight_start":26,"highlight_end":32}],"label":"value of type `fq::Fq` cannot be made by summing a `std::iter::Iterator<Item=fq::Fq>`","suggested_replacement":null,"suggestion_applicability":null,"expansion":{"span":{"file_name":"/Users/yugo/.cargo/git/checkouts/pairing-e1005e25456a4f82/868f527/src/bn256/fq.rs","byte_start":1766,"byte_end":1889,"line_start":70,"line_end":79,"column_start":1,"column_end":2,"is_primary":false,"text":[{"text":"common_field!(","highlight_start":1,"highlight_end":15},{"text":"    Fq,","highlight_start":1,"highlight_end":8},{"text":"    MODULUS,","highlight_start":1,"highlight_end":13},{"text":"    INV,","highlight_start":1,"highlight_end":9},{"text":"    BASEEXT_MODULUS,","highlight_start":1,"highlight_end":21},{"text":"    TWO_INV,","highlight_start":1,"highlight_end":13},{"text":"    ROOT_OF_UNITY_INV,","highlight_start":1,"highlight_end":23},{"text":"    DELTA,","highlight_start":1,"highlight_end":11},{"text":"    ZETA","highlight_start":1,"highlight_end":9},{"text":");","highlight_start":1,"highlight_end":2}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null},"macro_decl_name":"common_field!","def_site_span":{"file_name":"/Users/yugo/.cargo/git/checkouts/pairing-e1005e25456a4f82/868f527/src/bn256/common.rs","byte_start":0,"byte_end":25,"line_start":1,"line_end":1,"column_start":1,"column_end":26,"is_primary":false,"text":[{"text":"macro_rules! common_field {","highlight_start":1,"highlight_end":26}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}}}],"children":[{"message":"the trait `Sum` is not implemented for `fq::Fq`","code":null,"level":"help","spans":[],"children":[],"rendered":null},{"message":"the following other types implement trait `Sum<A>`:\n  <Duration as Sum<&'a Duration>>\n  <Duration as Sum>\n  <Gt as Sum<T>>\n  <Option<T> as Sum<Option<U>>>\n  <Result<T, E> as Sum<Result<U, E>>>\n  <Simd<f32, LANES> as Sum<&'a Simd<f32, LANES>>>\n  <Simd<f32, LANES> as Sum>\n  <Simd<f64, LANES> as Sum<&'a Simd<f64, LANES>>>\nand 76 others","code":null,"level":"help","spans":[],"children":[],"rendered":null},{"message":"required for `fq::Fq` to implement `ff::Field`","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"required by a bound in `fields::BaseExt`","code":null,"level":"note","spans":[{"file_name":"/Users/yugo/.cargo/git/checkouts/pairing-e1005e25456a4f82/868f527/src/arithmetic/fields.rs","byte_start":422,"byte_end":431,"line_start":15,"line_end":15,"column_start":20,"column_end":29,"is_primary":true,"text":[{"text":"pub trait BaseExt: ff::Field + Ord + ConstantTimeEq {","highlight_start":20,"highlight_end":29}],"label":"required by this bound in `BaseExt`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0277]\u001b[0m\u001b[0m\u001b[1m: a value of type `fq::Fq` cannot be made by summing an iterator over elements of type `fq::Fq`\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0m/Users/yugo/.cargo/git/checkouts/pairing-e1005e25456a4f82/868f527/src/bn256/common.rs:439:26\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m439\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m   \u001b[0m\u001b[0m        impl BaseExt for $field {\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m                           \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^^^^^^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9mvalue of type `fq::Fq` cannot be made by summing a `std::iter::Iterator<Item=fq::Fq>`\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m::: \u001b[0m\u001b[0m/Users/yugo/.cargo/git/checkouts/pairing-e1005e25456a4f82/868f527/src/bn256/fq.rs:70:1\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m70\u001b[0m\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m/\u001b[0m\u001b[0m \u001b[0m\u001b[0mcommon_field!(\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m71\u001b[0m\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m    Fq,\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m72\u001b[0m\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m    MODULUS,\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m73\u001b[0m\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m    INV,\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m...\u001b[0m\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m78\u001b[0m\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m    ZETA\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m79\u001b[0m\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m);\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|_-\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12min this macro invocation\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mhelp\u001b[0m\u001b[0m: the trait `Sum` is not implemented for `fq::Fq`\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mhelp\u001b[0m\u001b[0m: the following other types implement trait `Sum<A>`:\u001b[0m\n\u001b[0m              <Duration as Sum<&'a Duration>>\u001b[0m\n\u001b[0m              <Duration as Sum>\u001b[0m\n\u001b[0m              <Gt as Sum<T>>\u001b[0m\n\u001b[0m              <Option<T> as Sum<Option<U>>>\u001b[0m\n\u001b[0m              <Result<T, E> as Sum<Result<U, E>>>\u001b[0m\n\u001b[0m              <Simd<f32, LANES> as Sum<&'a Simd<f32, LANES>>>\u001b[0m\n\u001b[0m              <Simd<f32, LANES> as Sum>\u001b[0m\n\u001b[0m              <Simd<f64, LANES> as Sum<&'a Simd<f64, LANES>>>\u001b[0m\n\u001b[0m            and 76 others\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mnote\u001b[0m\u001b[0m: required for `fq::Fq` to implement `ff::Field`\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;10mnote\u001b[0m\u001b[0m: required by a bound in `fields::BaseExt`\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0m/Users/yugo/.cargo/git/checkouts/pairing-e1005e25456a4f82/868f527/src/arithmetic/fields.rs:15:20\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m15\u001b[0m\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0mpub trait BaseExt: ff::Field + Ord + ConstantTimeEq {\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m                   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;10m^^^^^^^^^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;10mrequired by this bound in `BaseExt`\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mnote\u001b[0m\u001b[0m: this error originates in the macro `common_field` (in Nightly builds, run with -Z macro-backtrace for more info)\u001b[0m\n\n"}
{"message":"a value of type `fq::Fq` cannot be made by multiplying all elements of type `&'a fq::Fq` from an iterator","code":{"code":"E0277","explanation":"You tried to use a type which doesn't implement some trait in a place which\nexpected that trait.\n\nErroneous code example:\n\n```compile_fail,E0277\n// here we declare the Foo trait with a bar method\ntrait Foo {\n    fn bar(&self);\n}\n\n// we now declare a function which takes an object implementing the Foo trait\nfn some_func<T: Foo>(foo: T) {\n    foo.bar();\n}\n\nfn main() {\n    // we now call the method with the i32 type, which doesn't implement\n    // the Foo trait\n    some_func(5i32); // error: the trait bound `i32 : Foo` is not satisfied\n}\n```\n\nIn order to fix this error, verify that the type you're using does implement\nthe trait. Example:\n\n```\ntrait Foo {\n    fn bar(&self);\n}\n\n// we implement the trait on the i32 type\nimpl Foo for i32 {\n    fn bar(&self) {}\n}\n\nfn some_func<T: Foo>(foo: T) {\n    foo.bar(); // we can now use this method since i32 implements the\n               // Foo trait\n}\n\nfn main() {\n    some_func(5i32); // ok!\n}\n```\n\nOr in a generic context, an erroneous code example would look like:\n\n```compile_fail,E0277\nfn some_func<T>(foo: T) {\n    println!(\"{:?}\", foo); // error: the trait `core::fmt::Debug` is not\n                           //        implemented for the type `T`\n}\n\nfn main() {\n    // We now call the method with the i32 type,\n    // which *does* implement the Debug trait.\n    some_func(5i32);\n}\n```\n\nNote that the error here is in the definition of the generic function. Although\nwe only call it with a parameter that does implement `Debug`, the compiler\nstill rejects the function. It must work with all possible input types. In\norder to make this example compile, we need to restrict the generic type we're\naccepting:\n\n```\nuse std::fmt;\n\n// Restrict the input type to types that implement Debug.\nfn some_func<T: fmt::Debug>(foo: T) {\n    println!(\"{:?}\", foo);\n}\n\nfn main() {\n    // Calling the method is still fine, as i32 implements Debug.\n    some_func(5i32);\n\n    // This would fail to compile now:\n    // struct WithoutDebug;\n    // some_func(WithoutDebug);\n}\n```\n\nRust only looks at the signature of the called function, as such it must\nalready specify all requirements that will be used for every type parameter.\n"},"level":"error","spans":[{"file_name":"/Users/yugo/.cargo/git/checkouts/pairing-e1005e25456a4f82/868f527/src/bn256/common.rs","byte_start":19738,"byte_end":19744,"line_start":478,"line_end":478,"column_start":27,"column_end":33,"is_primary":true,"text":[{"text":"        impl FieldExt for $field {","highlight_start":27,"highlight_end":33}],"label":"value of type `fq::Fq` cannot be made by multiplying all elements from a `std::iter::Iterator<Item=&'a fq::Fq>`","suggested_replacement":null,"suggestion_applicability":null,"expansion":{"span":{"file_name":"/Users/yugo/.cargo/git/checkouts/pairing-e1005e25456a4f82/868f527/src/bn256/fq.rs","byte_start":1766,"byte_end":1889,"line_start":70,"line_end":79,"column_start":1,"column_end":2,"is_primary":false,"text":[{"text":"common_field!(","highlight_start":1,"highlight_end":15},{"text":"    Fq,","highlight_start":1,"highlight_end":8},{"text":"    MODULUS,","highlight_start":1,"highlight_end":13},{"text":"    INV,","highlight_start":1,"highlight_end":9},{"text":"    BASEEXT_MODULUS,","highlight_start":1,"highlight_end":21},{"text":"    TWO_INV,","highlight_start":1,"highlight_end":13},{"text":"    ROOT_OF_UNITY_INV,","highlight_start":1,"highlight_end":23},{"text":"    DELTA,","highlight_start":1,"highlight_end":11},{"text":"    ZETA","highlight_start":1,"highlight_end":9},{"text":");","highlight_start":1,"highlight_end":2}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null},"macro_decl_name":"common_field!","def_site_span":{"file_name":"/Users/yugo/.cargo/git/checkouts/pairing-e1005e25456a4f82/868f527/src/bn256/common.rs","byte_start":0,"byte_end":25,"line_start":1,"line_end":1,"column_start":1,"column_end":26,"is_primary":false,"text":[{"text":"macro_rules! common_field {","highlight_start":1,"highlight_end":26}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}}}],"children":[{"message":"the trait `for<'a> Product<&'a fq::Fq>` is not implemented for `fq::Fq`","code":null,"level":"help","spans":[],"children":[],"rendered":null},{"message":"the following other types implement trait `Product<A>`:\n  <Option<T> as Product<Option<U>>>\n  <Result<T, E> as Product<Result<U, E>>>\n  <Simd<f32, LANES> as Product<&'a Simd<f32, LANES>>>\n  <Simd<f32, LANES> as Product>\n  <Simd<f64, LANES> as Product<&'a Simd<f64, LANES>>>\n  <Simd<f64, LANES> as Product>\n  <Simd<i16, LANES> as Product<&'a Simd<i16, LANES>>>\n  <Simd<i16, LANES> as Product>\nand 70 others","code":null,"level":"help","spans":[],"children":[],"rendered":null},{"message":"required for `fq::Fq` to implement `ff::Field`","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"required for `fq::Fq` to implement `fields::BaseExt`","code":null,"level":"note","spans":[{"file_name":"/Users/yugo/.cargo/git/checkouts/pairing-e1005e25456a4f82/868f527/src/arithmetic/fields.rs","byte_start":413,"byte_end":420,"line_start":15,"line_end":15,"column_start":11,"column_end":18,"is_primary":true,"text":[{"text":"pub trait BaseExt: ff::Field + Ord + ConstantTimeEq {","highlight_start":11,"highlight_end":18}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null},{"message":"required by a bound in `fields::FieldExt`","code":null,"level":"note","spans":[{"file_name":"/Users/yugo/.cargo/git/checkouts/pairing-e1005e25456a4f82/868f527/src/arithmetic/fields.rs","byte_start":1823,"byte_end":1830,"line_start":56,"line_end":56,"column_start":38,"column_end":45,"is_primary":true,"text":[{"text":"pub trait FieldExt: ff::PrimeField + BaseExt + Group<Scalar = Self> + From<bool> {","highlight_start":38,"highlight_end":45}],"label":"required by this bound in `FieldExt`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0277]\u001b[0m\u001b[0m\u001b[1m: a value of type `fq::Fq` cannot be made by multiplying all elements of type `&'a fq::Fq` from an iterator\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0m/Users/yugo/.cargo/git/checkouts/pairing-e1005e25456a4f82/868f527/src/bn256/common.rs:478:27\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m478\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m   \u001b[0m\u001b[0m        impl FieldExt for $field {\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m                            \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^^^^^^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9mvalue of type `fq::Fq` cannot be made by multiplying all elements from a `std::iter::Iterator<Item=&'a fq::Fq>`\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m::: \u001b[0m\u001b[0m/Users/yugo/.cargo/git/checkouts/pairing-e1005e25456a4f82/868f527/src/bn256/fq.rs:70:1\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m70\u001b[0m\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m/\u001b[0m\u001b[0m \u001b[0m\u001b[0mcommon_field!(\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m71\u001b[0m\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m    Fq,\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m72\u001b[0m\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m    MODULUS,\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m73\u001b[0m\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m    INV,\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m...\u001b[0m\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m78\u001b[0m\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m    ZETA\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m79\u001b[0m\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m);\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|_-\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12min this macro invocation\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mhelp\u001b[0m\u001b[0m: the trait `for<'a> Product<&'a fq::Fq>` is not implemented for `fq::Fq`\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mhelp\u001b[0m\u001b[0m: the following other types implement trait `Product<A>`:\u001b[0m\n\u001b[0m              <Option<T> as Product<Option<U>>>\u001b[0m\n\u001b[0m              <Result<T, E> as Product<Result<U, E>>>\u001b[0m\n\u001b[0m              <Simd<f32, LANES> as Product<&'a Simd<f32, LANES>>>\u001b[0m\n\u001b[0m              <Simd<f32, LANES> as Product>\u001b[0m\n\u001b[0m              <Simd<f64, LANES> as Product<&'a Simd<f64, LANES>>>\u001b[0m\n\u001b[0m              <Simd<f64, LANES> as Product>\u001b[0m\n\u001b[0m              <Simd<i16, LANES> as Product<&'a Simd<i16, LANES>>>\u001b[0m\n\u001b[0m              <Simd<i16, LANES> as Product>\u001b[0m\n\u001b[0m            and 70 others\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mnote\u001b[0m\u001b[0m: required for `fq::Fq` to implement `ff::Field`\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;10mnote\u001b[0m\u001b[0m: required for `fq::Fq` to implement `fields::BaseExt`\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0m/Users/yugo/.cargo/git/checkouts/pairing-e1005e25456a4f82/868f527/src/arithmetic/fields.rs:15:11\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m15\u001b[0m\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0mpub trait BaseExt: ff::Field + Ord + ConstantTimeEq {\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m          \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;10m^^^^^^^\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;10mnote\u001b[0m\u001b[0m: required by a bound in `fields::FieldExt`\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0m/Users/yugo/.cargo/git/checkouts/pairing-e1005e25456a4f82/868f527/src/arithmetic/fields.rs:56:38\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m56\u001b[0m\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0mpub trait FieldExt: ff::PrimeField + BaseExt + Group<Scalar = Self> + From<bool> {\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m                                     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;10m^^^^^^^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;10mrequired by this bound in `FieldExt`\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mnote\u001b[0m\u001b[0m: this error originates in the macro `common_field` (in Nightly builds, run with -Z macro-backtrace for more info)\u001b[0m\n\n"}
{"message":"a value of type `fq::Fq` cannot be made by summing an iterator over elements of type `&'a fq::Fq`","code":{"code":"E0277","explanation":"You tried to use a type which doesn't implement some trait in a place which\nexpected that trait.\n\nErroneous code example:\n\n```compile_fail,E0277\n// here we declare the Foo trait with a bar method\ntrait Foo {\n    fn bar(&self);\n}\n\n// we now declare a function which takes an object implementing the Foo trait\nfn some_func<T: Foo>(foo: T) {\n    foo.bar();\n}\n\nfn main() {\n    // we now call the method with the i32 type, which doesn't implement\n    // the Foo trait\n    some_func(5i32); // error: the trait bound `i32 : Foo` is not satisfied\n}\n```\n\nIn order to fix this error, verify that the type you're using does implement\nthe trait. Example:\n\n```\ntrait Foo {\n    fn bar(&self);\n}\n\n// we implement the trait on the i32 type\nimpl Foo for i32 {\n    fn bar(&self) {}\n}\n\nfn some_func<T: Foo>(foo: T) {\n    foo.bar(); // we can now use this method since i32 implements the\n               // Foo trait\n}\n\nfn main() {\n    some_func(5i32); // ok!\n}\n```\n\nOr in a generic context, an erroneous code example would look like:\n\n```compile_fail,E0277\nfn some_func<T>(foo: T) {\n    println!(\"{:?}\", foo); // error: the trait `core::fmt::Debug` is not\n                           //        implemented for the type `T`\n}\n\nfn main() {\n    // We now call the method with the i32 type,\n    // which *does* implement the Debug trait.\n    some_func(5i32);\n}\n```\n\nNote that the error here is in the definition of the generic function. Although\nwe only call it with a parameter that does implement `Debug`, the compiler\nstill rejects the function. It must work with all possible input types. In\norder to make this example compile, we need to restrict the generic type we're\naccepting:\n\n```\nuse std::fmt;\n\n// Restrict the input type to types that implement Debug.\nfn some_func<T: fmt::Debug>(foo: T) {\n    println!(\"{:?}\", foo);\n}\n\nfn main() {\n    // Calling the method is still fine, as i32 implements Debug.\n    some_func(5i32);\n\n    // This would fail to compile now:\n    // struct WithoutDebug;\n    // some_func(WithoutDebug);\n}\n```\n\nRust only looks at the signature of the called function, as such it must\nalready specify all requirements that will be used for every type parameter.\n"},"level":"error","spans":[{"file_name":"/Users/yugo/.cargo/git/checkouts/pairing-e1005e25456a4f82/868f527/src/bn256/common.rs","byte_start":19738,"byte_end":19744,"line_start":478,"line_end":478,"column_start":27,"column_end":33,"is_primary":true,"text":[{"text":"        impl FieldExt for $field {","highlight_start":27,"highlight_end":33}],"label":"value of type `fq::Fq` cannot be made by summing a `std::iter::Iterator<Item=&'a fq::Fq>`","suggested_replacement":null,"suggestion_applicability":null,"expansion":{"span":{"file_name":"/Users/yugo/.cargo/git/checkouts/pairing-e1005e25456a4f82/868f527/src/bn256/fq.rs","byte_start":1766,"byte_end":1889,"line_start":70,"line_end":79,"column_start":1,"column_end":2,"is_primary":false,"text":[{"text":"common_field!(","highlight_start":1,"highlight_end":15},{"text":"    Fq,","highlight_start":1,"highlight_end":8},{"text":"    MODULUS,","highlight_start":1,"highlight_end":13},{"text":"    INV,","highlight_start":1,"highlight_end":9},{"text":"    BASEEXT_MODULUS,","highlight_start":1,"highlight_end":21},{"text":"    TWO_INV,","highlight_start":1,"highlight_end":13},{"text":"    ROOT_OF_UNITY_INV,","highlight_start":1,"highlight_end":23},{"text":"    DELTA,","highlight_start":1,"highlight_end":11},{"text":"    ZETA","highlight_start":1,"highlight_end":9},{"text":");","highlight_start":1,"highlight_end":2}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null},"macro_decl_name":"common_field!","def_site_span":{"file_name":"/Users/yugo/.cargo/git/checkouts/pairing-e1005e25456a4f82/868f527/src/bn256/common.rs","byte_start":0,"byte_end":25,"line_start":1,"line_end":1,"column_start":1,"column_end":26,"is_primary":false,"text":[{"text":"macro_rules! common_field {","highlight_start":1,"highlight_end":26}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}}}],"children":[{"message":"the trait `for<'a> Sum<&'a fq::Fq>` is not implemented for `fq::Fq`","code":null,"level":"help","spans":[],"children":[],"rendered":null},{"message":"the following other types implement trait `Sum<A>`:\n  <Duration as Sum<&'a Duration>>\n  <Duration as Sum>\n  <Gt as Sum<T>>\n  <Option<T> as Sum<Option<U>>>\n  <Result<T, E> as Sum<Result<U, E>>>\n  <Simd<f32, LANES> as Sum<&'a Simd<f32, LANES>>>\n  <Simd<f32, LANES> as Sum>\n  <Simd<f64, LANES> as Sum<&'a Simd<f64, LANES>>>\nand 76 others","code":null,"level":"help","spans":[],"children":[],"rendered":null},{"message":"required for `fq::Fq` to implement `ff::Field`","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"required for `fq::Fq` to implement `fields::BaseExt`","code":null,"level":"note","spans":[{"file_name":"/Users/yugo/.cargo/git/checkouts/pairing-e1005e25456a4f82/868f527/src/arithmetic/fields.rs","byte_start":413,"byte_end":420,"line_start":15,"line_end":15,"column_start":11,"column_end":18,"is_primary":true,"text":[{"text":"pub trait BaseExt: ff::Field + Ord + ConstantTimeEq {","highlight_start":11,"highlight_end":18}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null},{"message":"required by a bound in `fields::FieldExt`","code":null,"level":"note","spans":[{"file_name":"/Users/yugo/.cargo/git/checkouts/pairing-e1005e25456a4f82/868f527/src/arithmetic/fields.rs","byte_start":1823,"byte_end":1830,"line_start":56,"line_end":56,"column_start":38,"column_end":45,"is_primary":true,"text":[{"text":"pub trait FieldExt: ff::PrimeField + BaseExt + Group<Scalar = Self> + From<bool> {","highlight_start":38,"highlight_end":45}],"label":"required by this bound in `FieldExt`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0277]\u001b[0m\u001b[0m\u001b[1m: a value of type `fq::Fq` cannot be made by summing an iterator over elements of type `&'a fq::Fq`\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0m/Users/yugo/.cargo/git/checkouts/pairing-e1005e25456a4f82/868f527/src/bn256/common.rs:478:27\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m478\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m   \u001b[0m\u001b[0m        impl FieldExt for $field {\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m                            \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^^^^^^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9mvalue of type `fq::Fq` cannot be made by summing a `std::iter::Iterator<Item=&'a fq::Fq>`\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m::: \u001b[0m\u001b[0m/Users/yugo/.cargo/git/checkouts/pairing-e1005e25456a4f82/868f527/src/bn256/fq.rs:70:1\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m70\u001b[0m\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m/\u001b[0m\u001b[0m \u001b[0m\u001b[0mcommon_field!(\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m71\u001b[0m\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m    Fq,\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m72\u001b[0m\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m    MODULUS,\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m73\u001b[0m\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m    INV,\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m...\u001b[0m\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m78\u001b[0m\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m    ZETA\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m79\u001b[0m\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m);\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|_-\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12min this macro invocation\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mhelp\u001b[0m\u001b[0m: the trait `for<'a> Sum<&'a fq::Fq>` is not implemented for `fq::Fq`\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mhelp\u001b[0m\u001b[0m: the following other types implement trait `Sum<A>`:\u001b[0m\n\u001b[0m              <Duration as Sum<&'a Duration>>\u001b[0m\n\u001b[0m              <Duration as Sum>\u001b[0m\n\u001b[0m              <Gt as Sum<T>>\u001b[0m\n\u001b[0m              <Option<T> as Sum<Option<U>>>\u001b[0m\n\u001b[0m              <Result<T, E> as Sum<Result<U, E>>>\u001b[0m\n\u001b[0m              <Simd<f32, LANES> as Sum<&'a Simd<f32, LANES>>>\u001b[0m\n\u001b[0m              <Simd<f32, LANES> as Sum>\u001b[0m\n\u001b[0m              <Simd<f64, LANES> as Sum<&'a Simd<f64, LANES>>>\u001b[0m\n\u001b[0m            and 76 others\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mnote\u001b[0m\u001b[0m: required for `fq::Fq` to implement `ff::Field`\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;10mnote\u001b[0m\u001b[0m: required for `fq::Fq` to implement `fields::BaseExt`\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0m/Users/yugo/.cargo/git/checkouts/pairing-e1005e25456a4f82/868f527/src/arithmetic/fields.rs:15:11\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m15\u001b[0m\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0mpub trait BaseExt: ff::Field + Ord + ConstantTimeEq {\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m          \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;10m^^^^^^^\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;10mnote\u001b[0m\u001b[0m: required by a bound in `fields::FieldExt`\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0m/Users/yugo/.cargo/git/checkouts/pairing-e1005e25456a4f82/868f527/src/arithmetic/fields.rs:56:38\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m56\u001b[0m\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0mpub trait FieldExt: ff::PrimeField + BaseExt + Group<Scalar = Self> + From<bool> {\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m                                     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;10m^^^^^^^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;10mrequired by this bound in `FieldExt`\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mnote\u001b[0m\u001b[0m: this error originates in the macro `common_field` (in Nightly builds, run with -Z macro-backtrace for more info)\u001b[0m\n\n"}
{"message":"a value of type `fq::Fq` cannot be made by multiplying all elements of type `fq::Fq` from an iterator","code":{"code":"E0277","explanation":"You tried to use a type which doesn't implement some trait in a place which\nexpected that trait.\n\nErroneous code example:\n\n```compile_fail,E0277\n// here we declare the Foo trait with a bar method\ntrait Foo {\n    fn bar(&self);\n}\n\n// we now declare a function which takes an object implementing the Foo trait\nfn some_func<T: Foo>(foo: T) {\n    foo.bar();\n}\n\nfn main() {\n    // we now call the method with the i32 type, which doesn't implement\n    // the Foo trait\n    some_func(5i32); // error: the trait bound `i32 : Foo` is not satisfied\n}\n```\n\nIn order to fix this error, verify that the type you're using does implement\nthe trait. Example:\n\n```\ntrait Foo {\n    fn bar(&self);\n}\n\n// we implement the trait on the i32 type\nimpl Foo for i32 {\n    fn bar(&self) {}\n}\n\nfn some_func<T: Foo>(foo: T) {\n    foo.bar(); // we can now use this method since i32 implements the\n               // Foo trait\n}\n\nfn main() {\n    some_func(5i32); // ok!\n}\n```\n\nOr in a generic context, an erroneous code example would look like:\n\n```compile_fail,E0277\nfn some_func<T>(foo: T) {\n    println!(\"{:?}\", foo); // error: the trait `core::fmt::Debug` is not\n                           //        implemented for the type `T`\n}\n\nfn main() {\n    // We now call the method with the i32 type,\n    // which *does* implement the Debug trait.\n    some_func(5i32);\n}\n```\n\nNote that the error here is in the definition of the generic function. Although\nwe only call it with a parameter that does implement `Debug`, the compiler\nstill rejects the function. It must work with all possible input types. In\norder to make this example compile, we need to restrict the generic type we're\naccepting:\n\n```\nuse std::fmt;\n\n// Restrict the input type to types that implement Debug.\nfn some_func<T: fmt::Debug>(foo: T) {\n    println!(\"{:?}\", foo);\n}\n\nfn main() {\n    // Calling the method is still fine, as i32 implements Debug.\n    some_func(5i32);\n\n    // This would fail to compile now:\n    // struct WithoutDebug;\n    // some_func(WithoutDebug);\n}\n```\n\nRust only looks at the signature of the called function, as such it must\nalready specify all requirements that will be used for every type parameter.\n"},"level":"error","spans":[{"file_name":"/Users/yugo/.cargo/git/checkouts/pairing-e1005e25456a4f82/868f527/src/bn256/common.rs","byte_start":19738,"byte_end":19744,"line_start":478,"line_end":478,"column_start":27,"column_end":33,"is_primary":true,"text":[{"text":"        impl FieldExt for $field {","highlight_start":27,"highlight_end":33}],"label":"value of type `fq::Fq` cannot be made by multiplying all elements from a `std::iter::Iterator<Item=fq::Fq>`","suggested_replacement":null,"suggestion_applicability":null,"expansion":{"span":{"file_name":"/Users/yugo/.cargo/git/checkouts/pairing-e1005e25456a4f82/868f527/src/bn256/fq.rs","byte_start":1766,"byte_end":1889,"line_start":70,"line_end":79,"column_start":1,"column_end":2,"is_primary":false,"text":[{"text":"common_field!(","highlight_start":1,"highlight_end":15},{"text":"    Fq,","highlight_start":1,"highlight_end":8},{"text":"    MODULUS,","highlight_start":1,"highlight_end":13},{"text":"    INV,","highlight_start":1,"highlight_end":9},{"text":"    BASEEXT_MODULUS,","highlight_start":1,"highlight_end":21},{"text":"    TWO_INV,","highlight_start":1,"highlight_end":13},{"text":"    ROOT_OF_UNITY_INV,","highlight_start":1,"highlight_end":23},{"text":"    DELTA,","highlight_start":1,"highlight_end":11},{"text":"    ZETA","highlight_start":1,"highlight_end":9},{"text":");","highlight_start":1,"highlight_end":2}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null},"macro_decl_name":"common_field!","def_site_span":{"file_name":"/Users/yugo/.cargo/git/checkouts/pairing-e1005e25456a4f82/868f527/src/bn256/common.rs","byte_start":0,"byte_end":25,"line_start":1,"line_end":1,"column_start":1,"column_end":26,"is_primary":false,"text":[{"text":"macro_rules! common_field {","highlight_start":1,"highlight_end":26}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}}}],"children":[{"message":"the trait `Product` is not implemented for `fq::Fq`","code":null,"level":"help","spans":[],"children":[],"rendered":null},{"message":"the following other types implement trait `Product<A>`:\n  <Option<T> as Product<Option<U>>>\n  <Result<T, E> as Product<Result<U, E>>>\n  <Simd<f32, LANES> as Product<&'a Simd<f32, LANES>>>\n  <Simd<f32, LANES> as Product>\n  <Simd<f64, LANES> as Product<&'a Simd<f64, LANES>>>\n  <Simd<f64, LANES> as Product>\n  <Simd<i16, LANES> as Product<&'a Simd<i16, LANES>>>\n  <Simd<i16, LANES> as Product>\nand 70 others","code":null,"level":"help","spans":[],"children":[],"rendered":null},{"message":"required for `fq::Fq` to implement `ff::Field`","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"required for `fq::Fq` to implement `fields::BaseExt`","code":null,"level":"note","spans":[{"file_name":"/Users/yugo/.cargo/git/checkouts/pairing-e1005e25456a4f82/868f527/src/arithmetic/fields.rs","byte_start":413,"byte_end":420,"line_start":15,"line_end":15,"column_start":11,"column_end":18,"is_primary":true,"text":[{"text":"pub trait BaseExt: ff::Field + Ord + ConstantTimeEq {","highlight_start":11,"highlight_end":18}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null},{"message":"required by a bound in `fields::FieldExt`","code":null,"level":"note","spans":[{"file_name":"/Users/yugo/.cargo/git/checkouts/pairing-e1005e25456a4f82/868f527/src/arithmetic/fields.rs","byte_start":1823,"byte_end":1830,"line_start":56,"line_end":56,"column_start":38,"column_end":45,"is_primary":true,"text":[{"text":"pub trait FieldExt: ff::PrimeField + BaseExt + Group<Scalar = Self> + From<bool> {","highlight_start":38,"highlight_end":45}],"label":"required by this bound in `FieldExt`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0277]\u001b[0m\u001b[0m\u001b[1m: a value of type `fq::Fq` cannot be made by multiplying all elements of type `fq::Fq` from an iterator\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0m/Users/yugo/.cargo/git/checkouts/pairing-e1005e25456a4f82/868f527/src/bn256/common.rs:478:27\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m478\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m   \u001b[0m\u001b[0m        impl FieldExt for $field {\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m                            \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^^^^^^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9mvalue of type `fq::Fq` cannot be made by multiplying all elements from a `std::iter::Iterator<Item=fq::Fq>`\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m::: \u001b[0m\u001b[0m/Users/yugo/.cargo/git/checkouts/pairing-e1005e25456a4f82/868f527/src/bn256/fq.rs:70:1\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m70\u001b[0m\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m/\u001b[0m\u001b[0m \u001b[0m\u001b[0mcommon_field!(\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m71\u001b[0m\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m    Fq,\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m72\u001b[0m\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m    MODULUS,\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m73\u001b[0m\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m    INV,\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m...\u001b[0m\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m78\u001b[0m\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m    ZETA\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m79\u001b[0m\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m);\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|_-\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12min this macro invocation\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mhelp\u001b[0m\u001b[0m: the trait `Product` is not implemented for `fq::Fq`\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mhelp\u001b[0m\u001b[0m: the following other types implement trait `Product<A>`:\u001b[0m\n\u001b[0m              <Option<T> as Product<Option<U>>>\u001b[0m\n\u001b[0m              <Result<T, E> as Product<Result<U, E>>>\u001b[0m\n\u001b[0m              <Simd<f32, LANES> as Product<&'a Simd<f32, LANES>>>\u001b[0m\n\u001b[0m              <Simd<f32, LANES> as Product>\u001b[0m\n\u001b[0m              <Simd<f64, LANES> as Product<&'a Simd<f64, LANES>>>\u001b[0m\n\u001b[0m              <Simd<f64, LANES> as Product>\u001b[0m\n\u001b[0m              <Simd<i16, LANES> as Product<&'a Simd<i16, LANES>>>\u001b[0m\n\u001b[0m              <Simd<i16, LANES> as Product>\u001b[0m\n\u001b[0m            and 70 others\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mnote\u001b[0m\u001b[0m: required for `fq::Fq` to implement `ff::Field`\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;10mnote\u001b[0m\u001b[0m: required for `fq::Fq` to implement `fields::BaseExt`\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0m/Users/yugo/.cargo/git/checkouts/pairing-e1005e25456a4f82/868f527/src/arithmetic/fields.rs:15:11\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m15\u001b[0m\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0mpub trait BaseExt: ff::Field + Ord + ConstantTimeEq {\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m          \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;10m^^^^^^^\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;10mnote\u001b[0m\u001b[0m: required by a bound in `fields::FieldExt`\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0m/Users/yugo/.cargo/git/checkouts/pairing-e1005e25456a4f82/868f527/src/arithmetic/fields.rs:56:38\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m56\u001b[0m\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0mpub trait FieldExt: ff::PrimeField + BaseExt + Group<Scalar = Self> + From<bool> {\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m                                     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;10m^^^^^^^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;10mrequired by this bound in `FieldExt`\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mnote\u001b[0m\u001b[0m: this error originates in the macro `common_field` (in Nightly builds, run with -Z macro-backtrace for more info)\u001b[0m\n\n"}
{"message":"a value of type `fq::Fq` cannot be made by summing an iterator over elements of type `fq::Fq`","code":{"code":"E0277","explanation":"You tried to use a type which doesn't implement some trait in a place which\nexpected that trait.\n\nErroneous code example:\n\n```compile_fail,E0277\n// here we declare the Foo trait with a bar method\ntrait Foo {\n    fn bar(&self);\n}\n\n// we now declare a function which takes an object implementing the Foo trait\nfn some_func<T: Foo>(foo: T) {\n    foo.bar();\n}\n\nfn main() {\n    // we now call the method with the i32 type, which doesn't implement\n    // the Foo trait\n    some_func(5i32); // error: the trait bound `i32 : Foo` is not satisfied\n}\n```\n\nIn order to fix this error, verify that the type you're using does implement\nthe trait. Example:\n\n```\ntrait Foo {\n    fn bar(&self);\n}\n\n// we implement the trait on the i32 type\nimpl Foo for i32 {\n    fn bar(&self) {}\n}\n\nfn some_func<T: Foo>(foo: T) {\n    foo.bar(); // we can now use this method since i32 implements the\n               // Foo trait\n}\n\nfn main() {\n    some_func(5i32); // ok!\n}\n```\n\nOr in a generic context, an erroneous code example would look like:\n\n```compile_fail,E0277\nfn some_func<T>(foo: T) {\n    println!(\"{:?}\", foo); // error: the trait `core::fmt::Debug` is not\n                           //        implemented for the type `T`\n}\n\nfn main() {\n    // We now call the method with the i32 type,\n    // which *does* implement the Debug trait.\n    some_func(5i32);\n}\n```\n\nNote that the error here is in the definition of the generic function. Although\nwe only call it with a parameter that does implement `Debug`, the compiler\nstill rejects the function. It must work with all possible input types. In\norder to make this example compile, we need to restrict the generic type we're\naccepting:\n\n```\nuse std::fmt;\n\n// Restrict the input type to types that implement Debug.\nfn some_func<T: fmt::Debug>(foo: T) {\n    println!(\"{:?}\", foo);\n}\n\nfn main() {\n    // Calling the method is still fine, as i32 implements Debug.\n    some_func(5i32);\n\n    // This would fail to compile now:\n    // struct WithoutDebug;\n    // some_func(WithoutDebug);\n}\n```\n\nRust only looks at the signature of the called function, as such it must\nalready specify all requirements that will be used for every type parameter.\n"},"level":"error","spans":[{"file_name":"/Users/yugo/.cargo/git/checkouts/pairing-e1005e25456a4f82/868f527/src/bn256/common.rs","byte_start":19738,"byte_end":19744,"line_start":478,"line_end":478,"column_start":27,"column_end":33,"is_primary":true,"text":[{"text":"        impl FieldExt for $field {","highlight_start":27,"highlight_end":33}],"label":"value of type `fq::Fq` cannot be made by summing a `std::iter::Iterator<Item=fq::Fq>`","suggested_replacement":null,"suggestion_applicability":null,"expansion":{"span":{"file_name":"/Users/yugo/.cargo/git/checkouts/pairing-e1005e25456a4f82/868f527/src/bn256/fq.rs","byte_start":1766,"byte_end":1889,"line_start":70,"line_end":79,"column_start":1,"column_end":2,"is_primary":false,"text":[{"text":"common_field!(","highlight_start":1,"highlight_end":15},{"text":"    Fq,","highlight_start":1,"highlight_end":8},{"text":"    MODULUS,","highlight_start":1,"highlight_end":13},{"text":"    INV,","highlight_start":1,"highlight_end":9},{"text":"    BASEEXT_MODULUS,","highlight_start":1,"highlight_end":21},{"text":"    TWO_INV,","highlight_start":1,"highlight_end":13},{"text":"    ROOT_OF_UNITY_INV,","highlight_start":1,"highlight_end":23},{"text":"    DELTA,","highlight_start":1,"highlight_end":11},{"text":"    ZETA","highlight_start":1,"highlight_end":9},{"text":");","highlight_start":1,"highlight_end":2}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null},"macro_decl_name":"common_field!","def_site_span":{"file_name":"/Users/yugo/.cargo/git/checkouts/pairing-e1005e25456a4f82/868f527/src/bn256/common.rs","byte_start":0,"byte_end":25,"line_start":1,"line_end":1,"column_start":1,"column_end":26,"is_primary":false,"text":[{"text":"macro_rules! common_field {","highlight_start":1,"highlight_end":26}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}}}],"children":[{"message":"the trait `Sum` is not implemented for `fq::Fq`","code":null,"level":"help","spans":[],"children":[],"rendered":null},{"message":"the following other types implement trait `Sum<A>`:\n  <Duration as Sum<&'a Duration>>\n  <Duration as Sum>\n  <Gt as Sum<T>>\n  <Option<T> as Sum<Option<U>>>\n  <Result<T, E> as Sum<Result<U, E>>>\n  <Simd<f32, LANES> as Sum<&'a Simd<f32, LANES>>>\n  <Simd<f32, LANES> as Sum>\n  <Simd<f64, LANES> as Sum<&'a Simd<f64, LANES>>>\nand 76 others","code":null,"level":"help","spans":[],"children":[],"rendered":null},{"message":"required for `fq::Fq` to implement `ff::Field`","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"required for `fq::Fq` to implement `fields::BaseExt`","code":null,"level":"note","spans":[{"file_name":"/Users/yugo/.cargo/git/checkouts/pairing-e1005e25456a4f82/868f527/src/arithmetic/fields.rs","byte_start":413,"byte_end":420,"line_start":15,"line_end":15,"column_start":11,"column_end":18,"is_primary":true,"text":[{"text":"pub trait BaseExt: ff::Field + Ord + ConstantTimeEq {","highlight_start":11,"highlight_end":18}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null},{"message":"required by a bound in `fields::FieldExt`","code":null,"level":"note","spans":[{"file_name":"/Users/yugo/.cargo/git/checkouts/pairing-e1005e25456a4f82/868f527/src/arithmetic/fields.rs","byte_start":1823,"byte_end":1830,"line_start":56,"line_end":56,"column_start":38,"column_end":45,"is_primary":true,"text":[{"text":"pub trait FieldExt: ff::PrimeField + BaseExt + Group<Scalar = Self> + From<bool> {","highlight_start":38,"highlight_end":45}],"label":"required by this bound in `FieldExt`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0277]\u001b[0m\u001b[0m\u001b[1m: a value of type `fq::Fq` cannot be made by summing an iterator over elements of type `fq::Fq`\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0m/Users/yugo/.cargo/git/checkouts/pairing-e1005e25456a4f82/868f527/src/bn256/common.rs:478:27\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m478\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m   \u001b[0m\u001b[0m        impl FieldExt for $field {\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m                            \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^^^^^^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9mvalue of type `fq::Fq` cannot be made by summing a `std::iter::Iterator<Item=fq::Fq>`\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m::: \u001b[0m\u001b[0m/Users/yugo/.cargo/git/checkouts/pairing-e1005e25456a4f82/868f527/src/bn256/fq.rs:70:1\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m70\u001b[0m\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m/\u001b[0m\u001b[0m \u001b[0m\u001b[0mcommon_field!(\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m71\u001b[0m\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m    Fq,\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m72\u001b[0m\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m    MODULUS,\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m73\u001b[0m\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m    INV,\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m...\u001b[0m\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m78\u001b[0m\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m    ZETA\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m79\u001b[0m\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m);\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|_-\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12min this macro invocation\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mhelp\u001b[0m\u001b[0m: the trait `Sum` is not implemented for `fq::Fq`\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mhelp\u001b[0m\u001b[0m: the following other types implement trait `Sum<A>`:\u001b[0m\n\u001b[0m              <Duration as Sum<&'a Duration>>\u001b[0m\n\u001b[0m              <Duration as Sum>\u001b[0m\n\u001b[0m              <Gt as Sum<T>>\u001b[0m\n\u001b[0m              <Option<T> as Sum<Option<U>>>\u001b[0m\n\u001b[0m              <Result<T, E> as Sum<Result<U, E>>>\u001b[0m\n\u001b[0m              <Simd<f32, LANES> as Sum<&'a Simd<f32, LANES>>>\u001b[0m\n\u001b[0m              <Simd<f32, LANES> as Sum>\u001b[0m\n\u001b[0m              <Simd<f64, LANES> as Sum<&'a Simd<f64, LANES>>>\u001b[0m\n\u001b[0m            and 76 others\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mnote\u001b[0m\u001b[0m: required for `fq::Fq` to implement `ff::Field`\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;10mnote\u001b[0m\u001b[0m: required for `fq::Fq` to implement `fields::BaseExt`\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0m/Users/yugo/.cargo/git/checkouts/pairing-e1005e25456a4f82/868f527/src/arithmetic/fields.rs:15:11\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m15\u001b[0m\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0mpub trait BaseExt: ff::Field + Ord + ConstantTimeEq {\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m          \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;10m^^^^^^^\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;10mnote\u001b[0m\u001b[0m: required by a bound in `fields::FieldExt`\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0m/Users/yugo/.cargo/git/checkouts/pairing-e1005e25456a4f82/868f527/src/arithmetic/fields.rs:56:38\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m56\u001b[0m\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0mpub trait FieldExt: ff::PrimeField + BaseExt + Group<Scalar = Self> + From<bool> {\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m                                     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;10m^^^^^^^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;10mrequired by this bound in `FieldExt`\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mnote\u001b[0m\u001b[0m: this error originates in the macro `common_field` (in Nightly builds, run with -Z macro-backtrace for more info)\u001b[0m\n\n"}
{"message":"a value of type `fq::Fq` cannot be made by multiplying all elements of type `&'a fq::Fq` from an iterator","code":{"code":"E0277","explanation":"You tried to use a type which doesn't implement some trait in a place which\nexpected that trait.\n\nErroneous code example:\n\n```compile_fail,E0277\n// here we declare the Foo trait with a bar method\ntrait Foo {\n    fn bar(&self);\n}\n\n// we now declare a function which takes an object implementing the Foo trait\nfn some_func<T: Foo>(foo: T) {\n    foo.bar();\n}\n\nfn main() {\n    // we now call the method with the i32 type, which doesn't implement\n    // the Foo trait\n    some_func(5i32); // error: the trait bound `i32 : Foo` is not satisfied\n}\n```\n\nIn order to fix this error, verify that the type you're using does implement\nthe trait. Example:\n\n```\ntrait Foo {\n    fn bar(&self);\n}\n\n// we implement the trait on the i32 type\nimpl Foo for i32 {\n    fn bar(&self) {}\n}\n\nfn some_func<T: Foo>(foo: T) {\n    foo.bar(); // we can now use this method since i32 implements the\n               // Foo trait\n}\n\nfn main() {\n    some_func(5i32); // ok!\n}\n```\n\nOr in a generic context, an erroneous code example would look like:\n\n```compile_fail,E0277\nfn some_func<T>(foo: T) {\n    println!(\"{:?}\", foo); // error: the trait `core::fmt::Debug` is not\n                           //        implemented for the type `T`\n}\n\nfn main() {\n    // We now call the method with the i32 type,\n    // which *does* implement the Debug trait.\n    some_func(5i32);\n}\n```\n\nNote that the error here is in the definition of the generic function. Although\nwe only call it with a parameter that does implement `Debug`, the compiler\nstill rejects the function. It must work with all possible input types. In\norder to make this example compile, we need to restrict the generic type we're\naccepting:\n\n```\nuse std::fmt;\n\n// Restrict the input type to types that implement Debug.\nfn some_func<T: fmt::Debug>(foo: T) {\n    println!(\"{:?}\", foo);\n}\n\nfn main() {\n    // Calling the method is still fine, as i32 implements Debug.\n    some_func(5i32);\n\n    // This would fail to compile now:\n    // struct WithoutDebug;\n    // some_func(WithoutDebug);\n}\n```\n\nRust only looks at the signature of the called function, as such it must\nalready specify all requirements that will be used for every type parameter.\n"},"level":"error","spans":[{"file_name":"/Users/yugo/.cargo/git/checkouts/pairing-e1005e25456a4f82/868f527/src/bn256/fq.rs","byte_start":4700,"byte_end":4702,"line_start":156,"line_end":156,"column_start":20,"column_end":22,"is_primary":true,"text":[{"text":"impl ff::Field for Fq {","highlight_start":20,"highlight_end":22}],"label":"value of type `fq::Fq` cannot be made by multiplying all elements from a `std::iter::Iterator<Item=&'a fq::Fq>`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"the trait `for<'a> Product<&'a fq::Fq>` is not implemented for `fq::Fq`","code":null,"level":"help","spans":[],"children":[],"rendered":null},{"message":"the following other types implement trait `Product<A>`:\n  <Option<T> as Product<Option<U>>>\n  <Result<T, E> as Product<Result<U, E>>>\n  <Simd<f32, LANES> as Product<&'a Simd<f32, LANES>>>\n  <Simd<f32, LANES> as Product>\n  <Simd<f64, LANES> as Product<&'a Simd<f64, LANES>>>\n  <Simd<f64, LANES> as Product>\n  <Simd<i16, LANES> as Product<&'a Simd<i16, LANES>>>\n  <Simd<i16, LANES> as Product>\nand 70 others","code":null,"level":"help","spans":[],"children":[],"rendered":null},{"message":"required by a bound in `ff::Field`","code":null,"level":"note","spans":[{"file_name":"/Users/yugo/.cargo/registry/src/index.crates.io-6f17d22bba15001f/ff-0.13.0/src/lib.rs","byte_start":1508,"byte_end":1533,"line_start":63,"line_end":63,"column_start":7,"column_end":32,"is_primary":true,"text":[{"text":"    + for<'a> Product<&'a Self>","highlight_start":7,"highlight_end":32}],"label":"required by this bound in `Field`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0277]\u001b[0m\u001b[0m\u001b[1m: a value of type `fq::Fq` cannot be made by multiplying all elements of type `&'a fq::Fq` from an iterator\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0m/Users/yugo/.cargo/git/checkouts/pairing-e1005e25456a4f82/868f527/src/bn256/fq.rs:156:20\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m156\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0mimpl ff::Field for Fq {\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m                   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9mvalue of type `fq::Fq` cannot be made by multiplying all elements from a `std::iter::Iterator<Item=&'a fq::Fq>`\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mhelp\u001b[0m\u001b[0m: the trait `for<'a> Product<&'a fq::Fq>` is not implemented for `fq::Fq`\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mhelp\u001b[0m\u001b[0m: the following other types implement trait `Product<A>`:\u001b[0m\n\u001b[0m              <Option<T> as Product<Option<U>>>\u001b[0m\n\u001b[0m              <Result<T, E> as Product<Result<U, E>>>\u001b[0m\n\u001b[0m              <Simd<f32, LANES> as Product<&'a Simd<f32, LANES>>>\u001b[0m\n\u001b[0m              <Simd<f32, LANES> as Product>\u001b[0m\n\u001b[0m              <Simd<f64, LANES> as Product<&'a Simd<f64, LANES>>>\u001b[0m\n\u001b[0m              <Simd<f64, LANES> as Product>\u001b[0m\n\u001b[0m              <Simd<i16, LANES> as Product<&'a Simd<i16, LANES>>>\u001b[0m\n\u001b[0m              <Simd<i16, LANES> as Product>\u001b[0m\n\u001b[0m            and 70 others\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;10mnote\u001b[0m\u001b[0m: required by a bound in `ff::Field`\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0m/Users/yugo/.cargo/registry/src/index.crates.io-6f17d22bba15001f/ff-0.13.0/src/lib.rs:63:7\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m63\u001b[0m\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m    + for<'a> Product<&'a Self>\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m      \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;10m^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;10mrequired by this bound in `Field`\u001b[0m\n\n"}
{"message":"a value of type `fq::Fq` cannot be made by summing an iterator over elements of type `&'a fq::Fq`","code":{"code":"E0277","explanation":"You tried to use a type which doesn't implement some trait in a place which\nexpected that trait.\n\nErroneous code example:\n\n```compile_fail,E0277\n// here we declare the Foo trait with a bar method\ntrait Foo {\n    fn bar(&self);\n}\n\n// we now declare a function which takes an object implementing the Foo trait\nfn some_func<T: Foo>(foo: T) {\n    foo.bar();\n}\n\nfn main() {\n    // we now call the method with the i32 type, which doesn't implement\n    // the Foo trait\n    some_func(5i32); // error: the trait bound `i32 : Foo` is not satisfied\n}\n```\n\nIn order to fix this error, verify that the type you're using does implement\nthe trait. Example:\n\n```\ntrait Foo {\n    fn bar(&self);\n}\n\n// we implement the trait on the i32 type\nimpl Foo for i32 {\n    fn bar(&self) {}\n}\n\nfn some_func<T: Foo>(foo: T) {\n    foo.bar(); // we can now use this method since i32 implements the\n               // Foo trait\n}\n\nfn main() {\n    some_func(5i32); // ok!\n}\n```\n\nOr in a generic context, an erroneous code example would look like:\n\n```compile_fail,E0277\nfn some_func<T>(foo: T) {\n    println!(\"{:?}\", foo); // error: the trait `core::fmt::Debug` is not\n                           //        implemented for the type `T`\n}\n\nfn main() {\n    // We now call the method with the i32 type,\n    // which *does* implement the Debug trait.\n    some_func(5i32);\n}\n```\n\nNote that the error here is in the definition of the generic function. Although\nwe only call it with a parameter that does implement `Debug`, the compiler\nstill rejects the function. It must work with all possible input types. In\norder to make this example compile, we need to restrict the generic type we're\naccepting:\n\n```\nuse std::fmt;\n\n// Restrict the input type to types that implement Debug.\nfn some_func<T: fmt::Debug>(foo: T) {\n    println!(\"{:?}\", foo);\n}\n\nfn main() {\n    // Calling the method is still fine, as i32 implements Debug.\n    some_func(5i32);\n\n    // This would fail to compile now:\n    // struct WithoutDebug;\n    // some_func(WithoutDebug);\n}\n```\n\nRust only looks at the signature of the called function, as such it must\nalready specify all requirements that will be used for every type parameter.\n"},"level":"error","spans":[{"file_name":"/Users/yugo/.cargo/git/checkouts/pairing-e1005e25456a4f82/868f527/src/bn256/fq.rs","byte_start":4700,"byte_end":4702,"line_start":156,"line_end":156,"column_start":20,"column_end":22,"is_primary":true,"text":[{"text":"impl ff::Field for Fq {","highlight_start":20,"highlight_end":22}],"label":"value of type `fq::Fq` cannot be made by summing a `std::iter::Iterator<Item=&'a fq::Fq>`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"the trait `for<'a> Sum<&'a fq::Fq>` is not implemented for `fq::Fq`","code":null,"level":"help","spans":[],"children":[],"rendered":null},{"message":"the following other types implement trait `Sum<A>`:\n  <Duration as Sum<&'a Duration>>\n  <Duration as Sum>\n  <Gt as Sum<T>>\n  <Option<T> as Sum<Option<U>>>\n  <Result<T, E> as Sum<Result<U, E>>>\n  <Simd<f32, LANES> as Sum<&'a Simd<f32, LANES>>>\n  <Simd<f32, LANES> as Sum>\n  <Simd<f64, LANES> as Sum<&'a Simd<f64, LANES>>>\nand 76 others","code":null,"level":"help","spans":[],"children":[],"rendered":null},{"message":"required by a bound in `ff::Field`","code":null,"level":"note","spans":[{"file_name":"/Users/yugo/.cargo/registry/src/index.crates.io-6f17d22bba15001f/ff-0.13.0/src/lib.rs","byte_start":1480,"byte_end":1501,"line_start":62,"line_end":62,"column_start":7,"column_end":28,"is_primary":true,"text":[{"text":"    + for<'a> Sum<&'a Self>","highlight_start":7,"highlight_end":28}],"label":"required by this bound in `Field`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0277]\u001b[0m\u001b[0m\u001b[1m: a value of type `fq::Fq` cannot be made by summing an iterator over elements of type `&'a fq::Fq`\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0m/Users/yugo/.cargo/git/checkouts/pairing-e1005e25456a4f82/868f527/src/bn256/fq.rs:156:20\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m156\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0mimpl ff::Field for Fq {\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m                   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9mvalue of type `fq::Fq` cannot be made by summing a `std::iter::Iterator<Item=&'a fq::Fq>`\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mhelp\u001b[0m\u001b[0m: the trait `for<'a> Sum<&'a fq::Fq>` is not implemented for `fq::Fq`\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mhelp\u001b[0m\u001b[0m: the following other types implement trait `Sum<A>`:\u001b[0m\n\u001b[0m              <Duration as Sum<&'a Duration>>\u001b[0m\n\u001b[0m              <Duration as Sum>\u001b[0m\n\u001b[0m              <Gt as Sum<T>>\u001b[0m\n\u001b[0m              <Option<T> as Sum<Option<U>>>\u001b[0m\n\u001b[0m              <Result<T, E> as Sum<Result<U, E>>>\u001b[0m\n\u001b[0m              <Simd<f32, LANES> as Sum<&'a Simd<f32, LANES>>>\u001b[0m\n\u001b[0m              <Simd<f32, LANES> as Sum>\u001b[0m\n\u001b[0m              <Simd<f64, LANES> as Sum<&'a Simd<f64, LANES>>>\u001b[0m\n\u001b[0m            and 76 others\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;10mnote\u001b[0m\u001b[0m: required by a bound in `ff::Field`\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0m/Users/yugo/.cargo/registry/src/index.crates.io-6f17d22bba15001f/ff-0.13.0/src/lib.rs:62:7\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m62\u001b[0m\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m    + for<'a> Sum<&'a Self>\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m      \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;10m^^^^^^^^^^^^^^^^^^^^^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;10mrequired by this bound in `Field`\u001b[0m\n\n"}
{"message":"a value of type `fq::Fq` cannot be made by multiplying all elements of type `fq::Fq` from an iterator","code":{"code":"E0277","explanation":"You tried to use a type which doesn't implement some trait in a place which\nexpected that trait.\n\nErroneous code example:\n\n```compile_fail,E0277\n// here we declare the Foo trait with a bar method\ntrait Foo {\n    fn bar(&self);\n}\n\n// we now declare a function which takes an object implementing the Foo trait\nfn some_func<T: Foo>(foo: T) {\n    foo.bar();\n}\n\nfn main() {\n    // we now call the method with the i32 type, which doesn't implement\n    // the Foo trait\n    some_func(5i32); // error: the trait bound `i32 : Foo` is not satisfied\n}\n```\n\nIn order to fix this error, verify that the type you're using does implement\nthe trait. Example:\n\n```\ntrait Foo {\n    fn bar(&self);\n}\n\n// we implement the trait on the i32 type\nimpl Foo for i32 {\n    fn bar(&self) {}\n}\n\nfn some_func<T: Foo>(foo: T) {\n    foo.bar(); // we can now use this method since i32 implements the\n               // Foo trait\n}\n\nfn main() {\n    some_func(5i32); // ok!\n}\n```\n\nOr in a generic context, an erroneous code example would look like:\n\n```compile_fail,E0277\nfn some_func<T>(foo: T) {\n    println!(\"{:?}\", foo); // error: the trait `core::fmt::Debug` is not\n                           //        implemented for the type `T`\n}\n\nfn main() {\n    // We now call the method with the i32 type,\n    // which *does* implement the Debug trait.\n    some_func(5i32);\n}\n```\n\nNote that the error here is in the definition of the generic function. Although\nwe only call it with a parameter that does implement `Debug`, the compiler\nstill rejects the function. It must work with all possible input types. In\norder to make this example compile, we need to restrict the generic type we're\naccepting:\n\n```\nuse std::fmt;\n\n// Restrict the input type to types that implement Debug.\nfn some_func<T: fmt::Debug>(foo: T) {\n    println!(\"{:?}\", foo);\n}\n\nfn main() {\n    // Calling the method is still fine, as i32 implements Debug.\n    some_func(5i32);\n\n    // This would fail to compile now:\n    // struct WithoutDebug;\n    // some_func(WithoutDebug);\n}\n```\n\nRust only looks at the signature of the called function, as such it must\nalready specify all requirements that will be used for every type parameter.\n"},"level":"error","spans":[{"file_name":"/Users/yugo/.cargo/git/checkouts/pairing-e1005e25456a4f82/868f527/src/bn256/fq.rs","byte_start":4700,"byte_end":4702,"line_start":156,"line_end":156,"column_start":20,"column_end":22,"is_primary":true,"text":[{"text":"impl ff::Field for Fq {","highlight_start":20,"highlight_end":22}],"label":"value of type `fq::Fq` cannot be made by multiplying all elements from a `std::iter::Iterator<Item=fq::Fq>`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"the trait `Product` is not implemented for `fq::Fq`","code":null,"level":"help","spans":[],"children":[],"rendered":null},{"message":"the following other types implement trait `Product<A>`:\n  <Option<T> as Product<Option<U>>>\n  <Result<T, E> as Product<Result<U, E>>>\n  <Simd<f32, LANES> as Product<&'a Simd<f32, LANES>>>\n  <Simd<f32, LANES> as Product>\n  <Simd<f64, LANES> as Product<&'a Simd<f64, LANES>>>\n  <Simd<f64, LANES> as Product>\n  <Simd<i16, LANES> as Product<&'a Simd<i16, LANES>>>\n  <Simd<i16, LANES> as Product>\nand 70 others","code":null,"level":"help","spans":[],"children":[],"rendered":null},{"message":"required by a bound in `ff::Field`","code":null,"level":"note","spans":[{"file_name":"/Users/yugo/.cargo/registry/src/index.crates.io-6f17d22bba15001f/ff-0.13.0/src/lib.rs","byte_start":1337,"byte_end":1344,"line_start":58,"line_end":58,"column_start":7,"column_end":14,"is_primary":true,"text":[{"text":"    + Product","highlight_start":7,"highlight_end":14}],"label":"required by this bound in `Field`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0277]\u001b[0m\u001b[0m\u001b[1m: a value of type `fq::Fq` cannot be made by multiplying all elements of type `fq::Fq` from an iterator\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0m/Users/yugo/.cargo/git/checkouts/pairing-e1005e25456a4f82/868f527/src/bn256/fq.rs:156:20\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m156\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0mimpl ff::Field for Fq {\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m                   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9mvalue of type `fq::Fq` cannot be made by multiplying all elements from a `std::iter::Iterator<Item=fq::Fq>`\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mhelp\u001b[0m\u001b[0m: the trait `Product` is not implemented for `fq::Fq`\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mhelp\u001b[0m\u001b[0m: the following other types implement trait `Product<A>`:\u001b[0m\n\u001b[0m              <Option<T> as Product<Option<U>>>\u001b[0m\n\u001b[0m              <Result<T, E> as Product<Result<U, E>>>\u001b[0m\n\u001b[0m              <Simd<f32, LANES> as Product<&'a Simd<f32, LANES>>>\u001b[0m\n\u001b[0m              <Simd<f32, LANES> as Product>\u001b[0m\n\u001b[0m              <Simd<f64, LANES> as Product<&'a Simd<f64, LANES>>>\u001b[0m\n\u001b[0m              <Simd<f64, LANES> as Product>\u001b[0m\n\u001b[0m              <Simd<i16, LANES> as Product<&'a Simd<i16, LANES>>>\u001b[0m\n\u001b[0m              <Simd<i16, LANES> as Product>\u001b[0m\n\u001b[0m            and 70 others\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;10mnote\u001b[0m\u001b[0m: required by a bound in `ff::Field`\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0m/Users/yugo/.cargo/registry/src/index.crates.io-6f17d22bba15001f/ff-0.13.0/src/lib.rs:58:7\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m58\u001b[0m\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m    + Product\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m      \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;10m^^^^^^^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;10mrequired by this bound in `Field`\u001b[0m\n\n"}
{"message":"a value of type `fq::Fq` cannot be made by summing an iterator over elements of type `fq::Fq`","code":{"code":"E0277","explanation":"You tried to use a type which doesn't implement some trait in a place which\nexpected that trait.\n\nErroneous code example:\n\n```compile_fail,E0277\n// here we declare the Foo trait with a bar method\ntrait Foo {\n    fn bar(&self);\n}\n\n// we now declare a function which takes an object implementing the Foo trait\nfn some_func<T: Foo>(foo: T) {\n    foo.bar();\n}\n\nfn main() {\n    // we now call the method with the i32 type, which doesn't implement\n    // the Foo trait\n    some_func(5i32); // error: the trait bound `i32 : Foo` is not satisfied\n}\n```\n\nIn order to fix this error, verify that the type you're using does implement\nthe trait. Example:\n\n```\ntrait Foo {\n    fn bar(&self);\n}\n\n// we implement the trait on the i32 type\nimpl Foo for i32 {\n    fn bar(&self) {}\n}\n\nfn some_func<T: Foo>(foo: T) {\n    foo.bar(); // we can now use this method since i32 implements the\n               // Foo trait\n}\n\nfn main() {\n    some_func(5i32); // ok!\n}\n```\n\nOr in a generic context, an erroneous code example would look like:\n\n```compile_fail,E0277\nfn some_func<T>(foo: T) {\n    println!(\"{:?}\", foo); // error: the trait `core::fmt::Debug` is not\n                           //        implemented for the type `T`\n}\n\nfn main() {\n    // We now call the method with the i32 type,\n    // which *does* implement the Debug trait.\n    some_func(5i32);\n}\n```\n\nNote that the error here is in the definition of the generic function. Although\nwe only call it with a parameter that does implement `Debug`, the compiler\nstill rejects the function. It must work with all possible input types. In\norder to make this example compile, we need to restrict the generic type we're\naccepting:\n\n```\nuse std::fmt;\n\n// Restrict the input type to types that implement Debug.\nfn some_func<T: fmt::Debug>(foo: T) {\n    println!(\"{:?}\", foo);\n}\n\nfn main() {\n    // Calling the method is still fine, as i32 implements Debug.\n    some_func(5i32);\n\n    // This would fail to compile now:\n    // struct WithoutDebug;\n    // some_func(WithoutDebug);\n}\n```\n\nRust only looks at the signature of the called function, as such it must\nalready specify all requirements that will be used for every type parameter.\n"},"level":"error","spans":[{"file_name":"/Users/yugo/.cargo/git/checkouts/pairing-e1005e25456a4f82/868f527/src/bn256/fq.rs","byte_start":4700,"byte_end":4702,"line_start":156,"line_end":156,"column_start":20,"column_end":22,"is_primary":true,"text":[{"text":"impl ff::Field for Fq {","highlight_start":20,"highlight_end":22}],"label":"value of type `fq::Fq` cannot be made by summing a `std::iter::Iterator<Item=fq::Fq>`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"the trait `Sum` is not implemented for `fq::Fq`","code":null,"level":"help","spans":[],"children":[],"rendered":null},{"message":"the following other types implement trait `Sum<A>`:\n  <Duration as Sum<&'a Duration>>\n  <Duration as Sum>\n  <Gt as Sum<T>>\n  <Option<T> as Sum<Option<U>>>\n  <Result<T, E> as Sum<Result<U, E>>>\n  <Simd<f32, LANES> as Sum<&'a Simd<f32, LANES>>>\n  <Simd<f32, LANES> as Sum>\n  <Simd<f64, LANES> as Sum<&'a Simd<f64, LANES>>>\nand 76 others","code":null,"level":"help","spans":[],"children":[],"rendered":null},{"message":"required by a bound in `ff::Field`","code":null,"level":"note","spans":[{"file_name":"/Users/yugo/.cargo/registry/src/index.crates.io-6f17d22bba15001f/ff-0.13.0/src/lib.rs","byte_start":1327,"byte_end":1330,"line_start":57,"line_end":57,"column_start":7,"column_end":10,"is_primary":true,"text":[{"text":"    + Sum","highlight_start":7,"highlight_end":10}],"label":"required by this bound in `Field`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0277]\u001b[0m\u001b[0m\u001b[1m: a value of type `fq::Fq` cannot be made by summing an iterator over elements of type `fq::Fq`\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0m/Users/yugo/.cargo/git/checkouts/pairing-e1005e25456a4f82/868f527/src/bn256/fq.rs:156:20\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m156\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0mimpl ff::Field for Fq {\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m                   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9mvalue of type `fq::Fq` cannot be made by summing a `std::iter::Iterator<Item=fq::Fq>`\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mhelp\u001b[0m\u001b[0m: the trait `Sum` is not implemented for `fq::Fq`\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mhelp\u001b[0m\u001b[0m: the following other types implement trait `Sum<A>`:\u001b[0m\n\u001b[0m              <Duration as Sum<&'a Duration>>\u001b[0m\n\u001b[0m              <Duration as Sum>\u001b[0m\n\u001b[0m              <Gt as Sum<T>>\u001b[0m\n\u001b[0m              <Option<T> as Sum<Option<U>>>\u001b[0m\n\u001b[0m              <Result<T, E> as Sum<Result<U, E>>>\u001b[0m\n\u001b[0m              <Simd<f32, LANES> as Sum<&'a Simd<f32, LANES>>>\u001b[0m\n\u001b[0m              <Simd<f32, LANES> as Sum>\u001b[0m\n\u001b[0m              <Simd<f64, LANES> as Sum<&'a Simd<f64, LANES>>>\u001b[0m\n\u001b[0m            and 76 others\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;10mnote\u001b[0m\u001b[0m: required by a bound in `ff::Field`\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0m/Users/yugo/.cargo/registry/src/index.crates.io-6f17d22bba15001f/ff-0.13.0/src/lib.rs:57:7\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m57\u001b[0m\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m    + Sum\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m      \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;10m^^^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;10mrequired by this bound in `Field`\u001b[0m\n\n"}
{"message":"a value of type `fq::Fq` cannot be made by multiplying all elements of type `&'a fq::Fq` from an iterator","code":{"code":"E0277","explanation":"You tried to use a type which doesn't implement some trait in a place which\nexpected that trait.\n\nErroneous code example:\n\n```compile_fail,E0277\n// here we declare the Foo trait with a bar method\ntrait Foo {\n    fn bar(&self);\n}\n\n// we now declare a function which takes an object implementing the Foo trait\nfn some_func<T: Foo>(foo: T) {\n    foo.bar();\n}\n\nfn main() {\n    // we now call the method with the i32 type, which doesn't implement\n    // the Foo trait\n    some_func(5i32); // error: the trait bound `i32 : Foo` is not satisfied\n}\n```\n\nIn order to fix this error, verify that the type you're using does implement\nthe trait. Example:\n\n```\ntrait Foo {\n    fn bar(&self);\n}\n\n// we implement the trait on the i32 type\nimpl Foo for i32 {\n    fn bar(&self) {}\n}\n\nfn some_func<T: Foo>(foo: T) {\n    foo.bar(); // we can now use this method since i32 implements the\n               // Foo trait\n}\n\nfn main() {\n    some_func(5i32); // ok!\n}\n```\n\nOr in a generic context, an erroneous code example would look like:\n\n```compile_fail,E0277\nfn some_func<T>(foo: T) {\n    println!(\"{:?}\", foo); // error: the trait `core::fmt::Debug` is not\n                           //        implemented for the type `T`\n}\n\nfn main() {\n    // We now call the method with the i32 type,\n    // which *does* implement the Debug trait.\n    some_func(5i32);\n}\n```\n\nNote that the error here is in the definition of the generic function. Although\nwe only call it with a parameter that does implement `Debug`, the compiler\nstill rejects the function. It must work with all possible input types. In\norder to make this example compile, we need to restrict the generic type we're\naccepting:\n\n```\nuse std::fmt;\n\n// Restrict the input type to types that implement Debug.\nfn some_func<T: fmt::Debug>(foo: T) {\n    println!(\"{:?}\", foo);\n}\n\nfn main() {\n    // Calling the method is still fine, as i32 implements Debug.\n    some_func(5i32);\n\n    // This would fail to compile now:\n    // struct WithoutDebug;\n    // some_func(WithoutDebug);\n}\n```\n\nRust only looks at the signature of the called function, as such it must\nalready specify all requirements that will be used for every type parameter.\n"},"level":"error","spans":[{"file_name":"/Users/yugo/.cargo/git/checkouts/pairing-e1005e25456a4f82/868f527/src/bn256/fq.rs","byte_start":5938,"byte_end":5940,"line_start":211,"line_end":211,"column_start":25,"column_end":27,"is_primary":true,"text":[{"text":"impl ff::PrimeField for Fq {","highlight_start":25,"highlight_end":27}],"label":"value of type `fq::Fq` cannot be made by multiplying all elements from a `std::iter::Iterator<Item=&'a fq::Fq>`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"the trait `for<'a> Product<&'a fq::Fq>` is not implemented for `fq::Fq`","code":null,"level":"help","spans":[],"children":[],"rendered":null},{"message":"the following other types implement trait `Product<A>`:\n  <Option<T> as Product<Option<U>>>\n  <Result<T, E> as Product<Result<U, E>>>\n  <Simd<f32, LANES> as Product<&'a Simd<f32, LANES>>>\n  <Simd<f32, LANES> as Product>\n  <Simd<f64, LANES> as Product<&'a Simd<f64, LANES>>>\n  <Simd<f64, LANES> as Product>\n  <Simd<i16, LANES> as Product<&'a Simd<i16, LANES>>>\n  <Simd<i16, LANES> as Product>\nand 70 others","code":null,"level":"help","spans":[],"children":[],"rendered":null},{"message":"required for `fq::Fq` to implement `ff::Field`","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"required by a bound in `ff::PrimeField`","code":null,"level":"note","spans":[{"file_name":"/Users/yugo/.cargo/registry/src/index.crates.io-6f17d22bba15001f/ff-0.13.0/src/lib.rs","byte_start":5874,"byte_end":5879,"line_start":195,"line_end":195,"column_start":23,"column_end":28,"is_primary":true,"text":[{"text":"pub trait PrimeField: Field + From<u64> {","highlight_start":23,"highlight_end":28}],"label":"required by this bound in `PrimeField`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0277]\u001b[0m\u001b[0m\u001b[1m: a value of type `fq::Fq` cannot be made by multiplying all elements of type `&'a fq::Fq` from an iterator\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0m/Users/yugo/.cargo/git/checkouts/pairing-e1005e25456a4f82/868f527/src/bn256/fq.rs:211:25\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m211\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0mimpl ff::PrimeField for Fq {\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m                        \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9mvalue of type `fq::Fq` cannot be made by multiplying all elements from a `std::iter::Iterator<Item=&'a fq::Fq>`\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mhelp\u001b[0m\u001b[0m: the trait `for<'a> Product<&'a fq::Fq>` is not implemented for `fq::Fq`\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mhelp\u001b[0m\u001b[0m: the following other types implement trait `Product<A>`:\u001b[0m\n\u001b[0m              <Option<T> as Product<Option<U>>>\u001b[0m\n\u001b[0m              <Result<T, E> as Product<Result<U, E>>>\u001b[0m\n\u001b[0m              <Simd<f32, LANES> as Product<&'a Simd<f32, LANES>>>\u001b[0m\n\u001b[0m              <Simd<f32, LANES> as Product>\u001b[0m\n\u001b[0m              <Simd<f64, LANES> as Product<&'a Simd<f64, LANES>>>\u001b[0m\n\u001b[0m              <Simd<f64, LANES> as Product>\u001b[0m\n\u001b[0m              <Simd<i16, LANES> as Product<&'a Simd<i16, LANES>>>\u001b[0m\n\u001b[0m              <Simd<i16, LANES> as Product>\u001b[0m\n\u001b[0m            and 70 others\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mnote\u001b[0m\u001b[0m: required for `fq::Fq` to implement `ff::Field`\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;10mnote\u001b[0m\u001b[0m: required by a bound in `ff::PrimeField`\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0m/Users/yugo/.cargo/registry/src/index.crates.io-6f17d22bba15001f/ff-0.13.0/src/lib.rs:195:23\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m195\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0mpub trait PrimeField: Field + From<u64> {\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m                      \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;10m^^^^^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;10mrequired by this bound in `PrimeField`\u001b[0m\n\n"}
{"message":"a value of type `fq::Fq` cannot be made by summing an iterator over elements of type `&'a fq::Fq`","code":{"code":"E0277","explanation":"You tried to use a type which doesn't implement some trait in a place which\nexpected that trait.\n\nErroneous code example:\n\n```compile_fail,E0277\n// here we declare the Foo trait with a bar method\ntrait Foo {\n    fn bar(&self);\n}\n\n// we now declare a function which takes an object implementing the Foo trait\nfn some_func<T: Foo>(foo: T) {\n    foo.bar();\n}\n\nfn main() {\n    // we now call the method with the i32 type, which doesn't implement\n    // the Foo trait\n    some_func(5i32); // error: the trait bound `i32 : Foo` is not satisfied\n}\n```\n\nIn order to fix this error, verify that the type you're using does implement\nthe trait. Example:\n\n```\ntrait Foo {\n    fn bar(&self);\n}\n\n// we implement the trait on the i32 type\nimpl Foo for i32 {\n    fn bar(&self) {}\n}\n\nfn some_func<T: Foo>(foo: T) {\n    foo.bar(); // we can now use this method since i32 implements the\n               // Foo trait\n}\n\nfn main() {\n    some_func(5i32); // ok!\n}\n```\n\nOr in a generic context, an erroneous code example would look like:\n\n```compile_fail,E0277\nfn some_func<T>(foo: T) {\n    println!(\"{:?}\", foo); // error: the trait `core::fmt::Debug` is not\n                           //        implemented for the type `T`\n}\n\nfn main() {\n    // We now call the method with the i32 type,\n    // which *does* implement the Debug trait.\n    some_func(5i32);\n}\n```\n\nNote that the error here is in the definition of the generic function. Although\nwe only call it with a parameter that does implement `Debug`, the compiler\nstill rejects the function. It must work with all possible input types. In\norder to make this example compile, we need to restrict the generic type we're\naccepting:\n\n```\nuse std::fmt;\n\n// Restrict the input type to types that implement Debug.\nfn some_func<T: fmt::Debug>(foo: T) {\n    println!(\"{:?}\", foo);\n}\n\nfn main() {\n    // Calling the method is still fine, as i32 implements Debug.\n    some_func(5i32);\n\n    // This would fail to compile now:\n    // struct WithoutDebug;\n    // some_func(WithoutDebug);\n}\n```\n\nRust only looks at the signature of the called function, as such it must\nalready specify all requirements that will be used for every type parameter.\n"},"level":"error","spans":[{"file_name":"/Users/yugo/.cargo/git/checkouts/pairing-e1005e25456a4f82/868f527/src/bn256/fq.rs","byte_start":5938,"byte_end":5940,"line_start":211,"line_end":211,"column_start":25,"column_end":27,"is_primary":true,"text":[{"text":"impl ff::PrimeField for Fq {","highlight_start":25,"highlight_end":27}],"label":"value of type `fq::Fq` cannot be made by summing a `std::iter::Iterator<Item=&'a fq::Fq>`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"the trait `for<'a> Sum<&'a fq::Fq>` is not implemented for `fq::Fq`","code":null,"level":"help","spans":[],"children":[],"rendered":null},{"message":"the following other types implement trait `Sum<A>`:\n  <Duration as Sum<&'a Duration>>\n  <Duration as Sum>\n  <Gt as Sum<T>>\n  <Option<T> as Sum<Option<U>>>\n  <Result<T, E> as Sum<Result<U, E>>>\n  <Simd<f32, LANES> as Sum<&'a Simd<f32, LANES>>>\n  <Simd<f32, LANES> as Sum>\n  <Simd<f64, LANES> as Sum<&'a Simd<f64, LANES>>>\nand 76 others","code":null,"level":"help","spans":[],"children":[],"rendered":null},{"message":"required for `fq::Fq` to implement `ff::Field`","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"required by a bound in `ff::PrimeField`","code":null,"level":"note","spans":[{"file_name":"/Users/yugo/.cargo/registry/src/index.crates.io-6f17d22bba15001f/ff-0.13.0/src/lib.rs","byte_start":5874,"byte_end":5879,"line_start":195,"line_end":195,"column_start":23,"column_end":28,"is_primary":true,"text":[{"text":"pub trait PrimeField: Field + From<u64> {","highlight_start":23,"highlight_end":28}],"label":"required by this bound in `PrimeField`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0277]\u001b[0m\u001b[0m\u001b[1m: a value of type `fq::Fq` cannot be made by summing an iterator over elements of type `&'a fq::Fq`\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0m/Users/yugo/.cargo/git/checkouts/pairing-e1005e25456a4f82/868f527/src/bn256/fq.rs:211:25\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m211\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0mimpl ff::PrimeField for Fq {\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m                        \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9mvalue of type `fq::Fq` cannot be made by summing a `std::iter::Iterator<Item=&'a fq::Fq>`\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mhelp\u001b[0m\u001b[0m: the trait `for<'a> Sum<&'a fq::Fq>` is not implemented for `fq::Fq`\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mhelp\u001b[0m\u001b[0m: the following other types implement trait `Sum<A>`:\u001b[0m\n\u001b[0m              <Duration as Sum<&'a Duration>>\u001b[0m\n\u001b[0m              <Duration as Sum>\u001b[0m\n\u001b[0m              <Gt as Sum<T>>\u001b[0m\n\u001b[0m              <Option<T> as Sum<Option<U>>>\u001b[0m\n\u001b[0m              <Result<T, E> as Sum<Result<U, E>>>\u001b[0m\n\u001b[0m              <Simd<f32, LANES> as Sum<&'a Simd<f32, LANES>>>\u001b[0m\n\u001b[0m              <Simd<f32, LANES> as Sum>\u001b[0m\n\u001b[0m              <Simd<f64, LANES> as Sum<&'a Simd<f64, LANES>>>\u001b[0m\n\u001b[0m            and 76 others\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mnote\u001b[0m\u001b[0m: required for `fq::Fq` to implement `ff::Field`\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;10mnote\u001b[0m\u001b[0m: required by a bound in `ff::PrimeField`\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0m/Users/yugo/.cargo/registry/src/index.crates.io-6f17d22bba15001f/ff-0.13.0/src/lib.rs:195:23\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m195\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0mpub trait PrimeField: Field + From<u64> {\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m                      \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;10m^^^^^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;10mrequired by this bound in `PrimeField`\u001b[0m\n\n"}
{"message":"a value of type `fq::Fq` cannot be made by multiplying all elements of type `fq::Fq` from an iterator","code":{"code":"E0277","explanation":"You tried to use a type which doesn't implement some trait in a place which\nexpected that trait.\n\nErroneous code example:\n\n```compile_fail,E0277\n// here we declare the Foo trait with a bar method\ntrait Foo {\n    fn bar(&self);\n}\n\n// we now declare a function which takes an object implementing the Foo trait\nfn some_func<T: Foo>(foo: T) {\n    foo.bar();\n}\n\nfn main() {\n    // we now call the method with the i32 type, which doesn't implement\n    // the Foo trait\n    some_func(5i32); // error: the trait bound `i32 : Foo` is not satisfied\n}\n```\n\nIn order to fix this error, verify that the type you're using does implement\nthe trait. Example:\n\n```\ntrait Foo {\n    fn bar(&self);\n}\n\n// we implement the trait on the i32 type\nimpl Foo for i32 {\n    fn bar(&self) {}\n}\n\nfn some_func<T: Foo>(foo: T) {\n    foo.bar(); // we can now use this method since i32 implements the\n               // Foo trait\n}\n\nfn main() {\n    some_func(5i32); // ok!\n}\n```\n\nOr in a generic context, an erroneous code example would look like:\n\n```compile_fail,E0277\nfn some_func<T>(foo: T) {\n    println!(\"{:?}\", foo); // error: the trait `core::fmt::Debug` is not\n                           //        implemented for the type `T`\n}\n\nfn main() {\n    // We now call the method with the i32 type,\n    // which *does* implement the Debug trait.\n    some_func(5i32);\n}\n```\n\nNote that the error here is in the definition of the generic function. Although\nwe only call it with a parameter that does implement `Debug`, the compiler\nstill rejects the function. It must work with all possible input types. In\norder to make this example compile, we need to restrict the generic type we're\naccepting:\n\n```\nuse std::fmt;\n\n// Restrict the input type to types that implement Debug.\nfn some_func<T: fmt::Debug>(foo: T) {\n    println!(\"{:?}\", foo);\n}\n\nfn main() {\n    // Calling the method is still fine, as i32 implements Debug.\n    some_func(5i32);\n\n    // This would fail to compile now:\n    // struct WithoutDebug;\n    // some_func(WithoutDebug);\n}\n```\n\nRust only looks at the signature of the called function, as such it must\nalready specify all requirements that will be used for every type parameter.\n"},"level":"error","spans":[{"file_name":"/Users/yugo/.cargo/git/checkouts/pairing-e1005e25456a4f82/868f527/src/bn256/fq.rs","byte_start":5938,"byte_end":5940,"line_start":211,"line_end":211,"column_start":25,"column_end":27,"is_primary":true,"text":[{"text":"impl ff::PrimeField for Fq {","highlight_start":25,"highlight_end":27}],"label":"value of type `fq::Fq` cannot be made by multiplying all elements from a `std::iter::Iterator<Item=fq::Fq>`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"the trait `Product` is not implemented for `fq::Fq`","code":null,"level":"help","spans":[],"children":[],"rendered":null},{"message":"the following other types implement trait `Product<A>`:\n  <Option<T> as Product<Option<U>>>\n  <Result<T, E> as Product<Result<U, E>>>\n  <Simd<f32, LANES> as Product<&'a Simd<f32, LANES>>>\n  <Simd<f32, LANES> as Product>\n  <Simd<f64, LANES> as Product<&'a Simd<f64, LANES>>>\n  <Simd<f64, LANES> as Product>\n  <Simd<i16, LANES> as Product<&'a Simd<i16, LANES>>>\n  <Simd<i16, LANES> as Product>\nand 70 others","code":null,"level":"help","spans":[],"children":[],"rendered":null},{"message":"required for `fq::Fq` to implement `ff::Field`","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"required by a bound in `ff::PrimeField`","code":null,"level":"note","spans":[{"file_name":"/Users/yugo/.cargo/registry/src/index.crates.io-6f17d22bba15001f/ff-0.13.0/src/lib.rs","byte_start":5874,"byte_end":5879,"line_start":195,"line_end":195,"column_start":23,"column_end":28,"is_primary":true,"text":[{"text":"pub trait PrimeField: Field + From<u64> {","highlight_start":23,"highlight_end":28}],"label":"required by this bound in `PrimeField`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0277]\u001b[0m\u001b[0m\u001b[1m: a value of type `fq::Fq` cannot be made by multiplying all elements of type `fq::Fq` from an iterator\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0m/Users/yugo/.cargo/git/checkouts/pairing-e1005e25456a4f82/868f527/src/bn256/fq.rs:211:25\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m211\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0mimpl ff::PrimeField for Fq {\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m                        \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9mvalue of type `fq::Fq` cannot be made by multiplying all elements from a `std::iter::Iterator<Item=fq::Fq>`\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mhelp\u001b[0m\u001b[0m: the trait `Product` is not implemented for `fq::Fq`\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mhelp\u001b[0m\u001b[0m: the following other types implement trait `Product<A>`:\u001b[0m\n\u001b[0m              <Option<T> as Product<Option<U>>>\u001b[0m\n\u001b[0m              <Result<T, E> as Product<Result<U, E>>>\u001b[0m\n\u001b[0m              <Simd<f32, LANES> as Product<&'a Simd<f32, LANES>>>\u001b[0m\n\u001b[0m              <Simd<f32, LANES> as Product>\u001b[0m\n\u001b[0m              <Simd<f64, LANES> as Product<&'a Simd<f64, LANES>>>\u001b[0m\n\u001b[0m              <Simd<f64, LANES> as Product>\u001b[0m\n\u001b[0m              <Simd<i16, LANES> as Product<&'a Simd<i16, LANES>>>\u001b[0m\n\u001b[0m              <Simd<i16, LANES> as Product>\u001b[0m\n\u001b[0m            and 70 others\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mnote\u001b[0m\u001b[0m: required for `fq::Fq` to implement `ff::Field`\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;10mnote\u001b[0m\u001b[0m: required by a bound in `ff::PrimeField`\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0m/Users/yugo/.cargo/registry/src/index.crates.io-6f17d22bba15001f/ff-0.13.0/src/lib.rs:195:23\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m195\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0mpub trait PrimeField: Field + From<u64> {\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m                      \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;10m^^^^^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;10mrequired by this bound in `PrimeField`\u001b[0m\n\n"}
{"message":"a value of type `fq::Fq` cannot be made by summing an iterator over elements of type `fq::Fq`","code":{"code":"E0277","explanation":"You tried to use a type which doesn't implement some trait in a place which\nexpected that trait.\n\nErroneous code example:\n\n```compile_fail,E0277\n// here we declare the Foo trait with a bar method\ntrait Foo {\n    fn bar(&self);\n}\n\n// we now declare a function which takes an object implementing the Foo trait\nfn some_func<T: Foo>(foo: T) {\n    foo.bar();\n}\n\nfn main() {\n    // we now call the method with the i32 type, which doesn't implement\n    // the Foo trait\n    some_func(5i32); // error: the trait bound `i32 : Foo` is not satisfied\n}\n```\n\nIn order to fix this error, verify that the type you're using does implement\nthe trait. Example:\n\n```\ntrait Foo {\n    fn bar(&self);\n}\n\n// we implement the trait on the i32 type\nimpl Foo for i32 {\n    fn bar(&self) {}\n}\n\nfn some_func<T: Foo>(foo: T) {\n    foo.bar(); // we can now use this method since i32 implements the\n               // Foo trait\n}\n\nfn main() {\n    some_func(5i32); // ok!\n}\n```\n\nOr in a generic context, an erroneous code example would look like:\n\n```compile_fail,E0277\nfn some_func<T>(foo: T) {\n    println!(\"{:?}\", foo); // error: the trait `core::fmt::Debug` is not\n                           //        implemented for the type `T`\n}\n\nfn main() {\n    // We now call the method with the i32 type,\n    // which *does* implement the Debug trait.\n    some_func(5i32);\n}\n```\n\nNote that the error here is in the definition of the generic function. Although\nwe only call it with a parameter that does implement `Debug`, the compiler\nstill rejects the function. It must work with all possible input types. In\norder to make this example compile, we need to restrict the generic type we're\naccepting:\n\n```\nuse std::fmt;\n\n// Restrict the input type to types that implement Debug.\nfn some_func<T: fmt::Debug>(foo: T) {\n    println!(\"{:?}\", foo);\n}\n\nfn main() {\n    // Calling the method is still fine, as i32 implements Debug.\n    some_func(5i32);\n\n    // This would fail to compile now:\n    // struct WithoutDebug;\n    // some_func(WithoutDebug);\n}\n```\n\nRust only looks at the signature of the called function, as such it must\nalready specify all requirements that will be used for every type parameter.\n"},"level":"error","spans":[{"file_name":"/Users/yugo/.cargo/git/checkouts/pairing-e1005e25456a4f82/868f527/src/bn256/fq.rs","byte_start":5938,"byte_end":5940,"line_start":211,"line_end":211,"column_start":25,"column_end":27,"is_primary":true,"text":[{"text":"impl ff::PrimeField for Fq {","highlight_start":25,"highlight_end":27}],"label":"value of type `fq::Fq` cannot be made by summing a `std::iter::Iterator<Item=fq::Fq>`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"the trait `Sum` is not implemented for `fq::Fq`","code":null,"level":"help","spans":[],"children":[],"rendered":null},{"message":"the following other types implement trait `Sum<A>`:\n  <Duration as Sum<&'a Duration>>\n  <Duration as Sum>\n  <Gt as Sum<T>>\n  <Option<T> as Sum<Option<U>>>\n  <Result<T, E> as Sum<Result<U, E>>>\n  <Simd<f32, LANES> as Sum<&'a Simd<f32, LANES>>>\n  <Simd<f32, LANES> as Sum>\n  <Simd<f64, LANES> as Sum<&'a Simd<f64, LANES>>>\nand 76 others","code":null,"level":"help","spans":[],"children":[],"rendered":null},{"message":"required for `fq::Fq` to implement `ff::Field`","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"required by a bound in `ff::PrimeField`","code":null,"level":"note","spans":[{"file_name":"/Users/yugo/.cargo/registry/src/index.crates.io-6f17d22bba15001f/ff-0.13.0/src/lib.rs","byte_start":5874,"byte_end":5879,"line_start":195,"line_end":195,"column_start":23,"column_end":28,"is_primary":true,"text":[{"text":"pub trait PrimeField: Field + From<u64> {","highlight_start":23,"highlight_end":28}],"label":"required by this bound in `PrimeField`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0277]\u001b[0m\u001b[0m\u001b[1m: a value of type `fq::Fq` cannot be made by summing an iterator over elements of type `fq::Fq`\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0m/Users/yugo/.cargo/git/checkouts/pairing-e1005e25456a4f82/868f527/src/bn256/fq.rs:211:25\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m211\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0mimpl ff::PrimeField for Fq {\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m                        \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9mvalue of type `fq::Fq` cannot be made by summing a `std::iter::Iterator<Item=fq::Fq>`\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mhelp\u001b[0m\u001b[0m: the trait `Sum` is not implemented for `fq::Fq`\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mhelp\u001b[0m\u001b[0m: the following other types implement trait `Sum<A>`:\u001b[0m\n\u001b[0m              <Duration as Sum<&'a Duration>>\u001b[0m\n\u001b[0m              <Duration as Sum>\u001b[0m\n\u001b[0m              <Gt as Sum<T>>\u001b[0m\n\u001b[0m              <Option<T> as Sum<Option<U>>>\u001b[0m\n\u001b[0m              <Result<T, E> as Sum<Result<U, E>>>\u001b[0m\n\u001b[0m              <Simd<f32, LANES> as Sum<&'a Simd<f32, LANES>>>\u001b[0m\n\u001b[0m              <Simd<f32, LANES> as Sum>\u001b[0m\n\u001b[0m              <Simd<f64, LANES> as Sum<&'a Simd<f64, LANES>>>\u001b[0m\n\u001b[0m            and 76 others\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mnote\u001b[0m\u001b[0m: required for `fq::Fq` to implement `ff::Field`\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;10mnote\u001b[0m\u001b[0m: required by a bound in `ff::PrimeField`\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0m/Users/yugo/.cargo/registry/src/index.crates.io-6f17d22bba15001f/ff-0.13.0/src/lib.rs:195:23\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m195\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0mpub trait PrimeField: Field + From<u64> {\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m                      \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;10m^^^^^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;10mrequired by this bound in `PrimeField`\u001b[0m\n\n"}
{"message":"a value of type `fq12::Fq12` cannot be made by multiplying all elements of type `&'a fq12::Fq12` from an iterator","code":{"code":"E0277","explanation":"You tried to use a type which doesn't implement some trait in a place which\nexpected that trait.\n\nErroneous code example:\n\n```compile_fail,E0277\n// here we declare the Foo trait with a bar method\ntrait Foo {\n    fn bar(&self);\n}\n\n// we now declare a function which takes an object implementing the Foo trait\nfn some_func<T: Foo>(foo: T) {\n    foo.bar();\n}\n\nfn main() {\n    // we now call the method with the i32 type, which doesn't implement\n    // the Foo trait\n    some_func(5i32); // error: the trait bound `i32 : Foo` is not satisfied\n}\n```\n\nIn order to fix this error, verify that the type you're using does implement\nthe trait. Example:\n\n```\ntrait Foo {\n    fn bar(&self);\n}\n\n// we implement the trait on the i32 type\nimpl Foo for i32 {\n    fn bar(&self) {}\n}\n\nfn some_func<T: Foo>(foo: T) {\n    foo.bar(); // we can now use this method since i32 implements the\n               // Foo trait\n}\n\nfn main() {\n    some_func(5i32); // ok!\n}\n```\n\nOr in a generic context, an erroneous code example would look like:\n\n```compile_fail,E0277\nfn some_func<T>(foo: T) {\n    println!(\"{:?}\", foo); // error: the trait `core::fmt::Debug` is not\n                           //        implemented for the type `T`\n}\n\nfn main() {\n    // We now call the method with the i32 type,\n    // which *does* implement the Debug trait.\n    some_func(5i32);\n}\n```\n\nNote that the error here is in the definition of the generic function. Although\nwe only call it with a parameter that does implement `Debug`, the compiler\nstill rejects the function. It must work with all possible input types. In\norder to make this example compile, we need to restrict the generic type we're\naccepting:\n\n```\nuse std::fmt;\n\n// Restrict the input type to types that implement Debug.\nfn some_func<T: fmt::Debug>(foo: T) {\n    println!(\"{:?}\", foo);\n}\n\nfn main() {\n    // Calling the method is still fine, as i32 implements Debug.\n    some_func(5i32);\n\n    // This would fail to compile now:\n    // struct WithoutDebug;\n    // some_func(WithoutDebug);\n}\n```\n\nRust only looks at the signature of the called function, as such it must\nalready specify all requirements that will be used for every type parameter.\n"},"level":"error","spans":[{"file_name":"/Users/yugo/.cargo/git/checkouts/pairing-e1005e25456a4f82/868f527/src/bn256/fq12.rs","byte_start":6378,"byte_end":6382,"line_start":274,"line_end":274,"column_start":16,"column_end":20,"is_primary":true,"text":[{"text":"impl Field for Fq12 {","highlight_start":16,"highlight_end":20}],"label":"value of type `fq12::Fq12` cannot be made by multiplying all elements from a `std::iter::Iterator<Item=&'a fq12::Fq12>`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"the trait `for<'a> Product<&'a fq12::Fq12>` is not implemented for `fq12::Fq12`","code":null,"level":"help","spans":[],"children":[],"rendered":null},{"message":"the following other types implement trait `Product<A>`:\n  <Option<T> as Product<Option<U>>>\n  <Result<T, E> as Product<Result<U, E>>>\n  <Simd<f32, LANES> as Product<&'a Simd<f32, LANES>>>\n  <Simd<f32, LANES> as Product>\n  <Simd<f64, LANES> as Product<&'a Simd<f64, LANES>>>\n  <Simd<f64, LANES> as Product>\n  <Simd<i16, LANES> as Product<&'a Simd<i16, LANES>>>\n  <Simd<i16, LANES> as Product>\nand 70 others","code":null,"level":"help","spans":[],"children":[],"rendered":null},{"message":"required by a bound in `ff::Field`","code":null,"level":"note","spans":[{"file_name":"/Users/yugo/.cargo/registry/src/index.crates.io-6f17d22bba15001f/ff-0.13.0/src/lib.rs","byte_start":1508,"byte_end":1533,"line_start":63,"line_end":63,"column_start":7,"column_end":32,"is_primary":true,"text":[{"text":"    + for<'a> Product<&'a Self>","highlight_start":7,"highlight_end":32}],"label":"required by this bound in `Field`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0277]\u001b[0m\u001b[0m\u001b[1m: a value of type `fq12::Fq12` cannot be made by multiplying all elements of type `&'a fq12::Fq12` from an iterator\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0m/Users/yugo/.cargo/git/checkouts/pairing-e1005e25456a4f82/868f527/src/bn256/fq12.rs:274:16\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m274\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0mimpl Field for Fq12 {\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m               \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^^^^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9mvalue of type `fq12::Fq12` cannot be made by multiplying all elements from a `std::iter::Iterator<Item=&'a fq12::Fq12>`\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mhelp\u001b[0m\u001b[0m: the trait `for<'a> Product<&'a fq12::Fq12>` is not implemented for `fq12::Fq12`\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mhelp\u001b[0m\u001b[0m: the following other types implement trait `Product<A>`:\u001b[0m\n\u001b[0m              <Option<T> as Product<Option<U>>>\u001b[0m\n\u001b[0m              <Result<T, E> as Product<Result<U, E>>>\u001b[0m\n\u001b[0m              <Simd<f32, LANES> as Product<&'a Simd<f32, LANES>>>\u001b[0m\n\u001b[0m              <Simd<f32, LANES> as Product>\u001b[0m\n\u001b[0m              <Simd<f64, LANES> as Product<&'a Simd<f64, LANES>>>\u001b[0m\n\u001b[0m              <Simd<f64, LANES> as Product>\u001b[0m\n\u001b[0m              <Simd<i16, LANES> as Product<&'a Simd<i16, LANES>>>\u001b[0m\n\u001b[0m              <Simd<i16, LANES> as Product>\u001b[0m\n\u001b[0m            and 70 others\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;10mnote\u001b[0m\u001b[0m: required by a bound in `ff::Field`\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0m/Users/yugo/.cargo/registry/src/index.crates.io-6f17d22bba15001f/ff-0.13.0/src/lib.rs:63:7\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m63\u001b[0m\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m    + for<'a> Product<&'a Self>\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m      \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;10m^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;10mrequired by this bound in `Field`\u001b[0m\n\n"}
{"message":"a value of type `fq12::Fq12` cannot be made by summing an iterator over elements of type `&'a fq12::Fq12`","code":{"code":"E0277","explanation":"You tried to use a type which doesn't implement some trait in a place which\nexpected that trait.\n\nErroneous code example:\n\n```compile_fail,E0277\n// here we declare the Foo trait with a bar method\ntrait Foo {\n    fn bar(&self);\n}\n\n// we now declare a function which takes an object implementing the Foo trait\nfn some_func<T: Foo>(foo: T) {\n    foo.bar();\n}\n\nfn main() {\n    // we now call the method with the i32 type, which doesn't implement\n    // the Foo trait\n    some_func(5i32); // error: the trait bound `i32 : Foo` is not satisfied\n}\n```\n\nIn order to fix this error, verify that the type you're using does implement\nthe trait. Example:\n\n```\ntrait Foo {\n    fn bar(&self);\n}\n\n// we implement the trait on the i32 type\nimpl Foo for i32 {\n    fn bar(&self) {}\n}\n\nfn some_func<T: Foo>(foo: T) {\n    foo.bar(); // we can now use this method since i32 implements the\n               // Foo trait\n}\n\nfn main() {\n    some_func(5i32); // ok!\n}\n```\n\nOr in a generic context, an erroneous code example would look like:\n\n```compile_fail,E0277\nfn some_func<T>(foo: T) {\n    println!(\"{:?}\", foo); // error: the trait `core::fmt::Debug` is not\n                           //        implemented for the type `T`\n}\n\nfn main() {\n    // We now call the method with the i32 type,\n    // which *does* implement the Debug trait.\n    some_func(5i32);\n}\n```\n\nNote that the error here is in the definition of the generic function. Although\nwe only call it with a parameter that does implement `Debug`, the compiler\nstill rejects the function. It must work with all possible input types. In\norder to make this example compile, we need to restrict the generic type we're\naccepting:\n\n```\nuse std::fmt;\n\n// Restrict the input type to types that implement Debug.\nfn some_func<T: fmt::Debug>(foo: T) {\n    println!(\"{:?}\", foo);\n}\n\nfn main() {\n    // Calling the method is still fine, as i32 implements Debug.\n    some_func(5i32);\n\n    // This would fail to compile now:\n    // struct WithoutDebug;\n    // some_func(WithoutDebug);\n}\n```\n\nRust only looks at the signature of the called function, as such it must\nalready specify all requirements that will be used for every type parameter.\n"},"level":"error","spans":[{"file_name":"/Users/yugo/.cargo/git/checkouts/pairing-e1005e25456a4f82/868f527/src/bn256/fq12.rs","byte_start":6378,"byte_end":6382,"line_start":274,"line_end":274,"column_start":16,"column_end":20,"is_primary":true,"text":[{"text":"impl Field for Fq12 {","highlight_start":16,"highlight_end":20}],"label":"value of type `fq12::Fq12` cannot be made by summing a `std::iter::Iterator<Item=&'a fq12::Fq12>`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"the trait `for<'a> Sum<&'a fq12::Fq12>` is not implemented for `fq12::Fq12`","code":null,"level":"help","spans":[],"children":[],"rendered":null},{"message":"the following other types implement trait `Sum<A>`:\n  <Duration as Sum<&'a Duration>>\n  <Duration as Sum>\n  <Gt as Sum<T>>\n  <Option<T> as Sum<Option<U>>>\n  <Result<T, E> as Sum<Result<U, E>>>\n  <Simd<f32, LANES> as Sum<&'a Simd<f32, LANES>>>\n  <Simd<f32, LANES> as Sum>\n  <Simd<f64, LANES> as Sum<&'a Simd<f64, LANES>>>\nand 76 others","code":null,"level":"help","spans":[],"children":[],"rendered":null},{"message":"required by a bound in `ff::Field`","code":null,"level":"note","spans":[{"file_name":"/Users/yugo/.cargo/registry/src/index.crates.io-6f17d22bba15001f/ff-0.13.0/src/lib.rs","byte_start":1480,"byte_end":1501,"line_start":62,"line_end":62,"column_start":7,"column_end":28,"is_primary":true,"text":[{"text":"    + for<'a> Sum<&'a Self>","highlight_start":7,"highlight_end":28}],"label":"required by this bound in `Field`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0277]\u001b[0m\u001b[0m\u001b[1m: a value of type `fq12::Fq12` cannot be made by summing an iterator over elements of type `&'a fq12::Fq12`\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0m/Users/yugo/.cargo/git/checkouts/pairing-e1005e25456a4f82/868f527/src/bn256/fq12.rs:274:16\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m274\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0mimpl Field for Fq12 {\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m               \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^^^^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9mvalue of type `fq12::Fq12` cannot be made by summing a `std::iter::Iterator<Item=&'a fq12::Fq12>`\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mhelp\u001b[0m\u001b[0m: the trait `for<'a> Sum<&'a fq12::Fq12>` is not implemented for `fq12::Fq12`\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mhelp\u001b[0m\u001b[0m: the following other types implement trait `Sum<A>`:\u001b[0m\n\u001b[0m              <Duration as Sum<&'a Duration>>\u001b[0m\n\u001b[0m              <Duration as Sum>\u001b[0m\n\u001b[0m              <Gt as Sum<T>>\u001b[0m\n\u001b[0m              <Option<T> as Sum<Option<U>>>\u001b[0m\n\u001b[0m              <Result<T, E> as Sum<Result<U, E>>>\u001b[0m\n\u001b[0m              <Simd<f32, LANES> as Sum<&'a Simd<f32, LANES>>>\u001b[0m\n\u001b[0m              <Simd<f32, LANES> as Sum>\u001b[0m\n\u001b[0m              <Simd<f64, LANES> as Sum<&'a Simd<f64, LANES>>>\u001b[0m\n\u001b[0m            and 76 others\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;10mnote\u001b[0m\u001b[0m: required by a bound in `ff::Field`\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0m/Users/yugo/.cargo/registry/src/index.crates.io-6f17d22bba15001f/ff-0.13.0/src/lib.rs:62:7\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m62\u001b[0m\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m    + for<'a> Sum<&'a Self>\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m      \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;10m^^^^^^^^^^^^^^^^^^^^^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;10mrequired by this bound in `Field`\u001b[0m\n\n"}
{"message":"a value of type `fq12::Fq12` cannot be made by multiplying all elements of type `fq12::Fq12` from an iterator","code":{"code":"E0277","explanation":"You tried to use a type which doesn't implement some trait in a place which\nexpected that trait.\n\nErroneous code example:\n\n```compile_fail,E0277\n// here we declare the Foo trait with a bar method\ntrait Foo {\n    fn bar(&self);\n}\n\n// we now declare a function which takes an object implementing the Foo trait\nfn some_func<T: Foo>(foo: T) {\n    foo.bar();\n}\n\nfn main() {\n    // we now call the method with the i32 type, which doesn't implement\n    // the Foo trait\n    some_func(5i32); // error: the trait bound `i32 : Foo` is not satisfied\n}\n```\n\nIn order to fix this error, verify that the type you're using does implement\nthe trait. Example:\n\n```\ntrait Foo {\n    fn bar(&self);\n}\n\n// we implement the trait on the i32 type\nimpl Foo for i32 {\n    fn bar(&self) {}\n}\n\nfn some_func<T: Foo>(foo: T) {\n    foo.bar(); // we can now use this method since i32 implements the\n               // Foo trait\n}\n\nfn main() {\n    some_func(5i32); // ok!\n}\n```\n\nOr in a generic context, an erroneous code example would look like:\n\n```compile_fail,E0277\nfn some_func<T>(foo: T) {\n    println!(\"{:?}\", foo); // error: the trait `core::fmt::Debug` is not\n                           //        implemented for the type `T`\n}\n\nfn main() {\n    // We now call the method with the i32 type,\n    // which *does* implement the Debug trait.\n    some_func(5i32);\n}\n```\n\nNote that the error here is in the definition of the generic function. Although\nwe only call it with a parameter that does implement `Debug`, the compiler\nstill rejects the function. It must work with all possible input types. In\norder to make this example compile, we need to restrict the generic type we're\naccepting:\n\n```\nuse std::fmt;\n\n// Restrict the input type to types that implement Debug.\nfn some_func<T: fmt::Debug>(foo: T) {\n    println!(\"{:?}\", foo);\n}\n\nfn main() {\n    // Calling the method is still fine, as i32 implements Debug.\n    some_func(5i32);\n\n    // This would fail to compile now:\n    // struct WithoutDebug;\n    // some_func(WithoutDebug);\n}\n```\n\nRust only looks at the signature of the called function, as such it must\nalready specify all requirements that will be used for every type parameter.\n"},"level":"error","spans":[{"file_name":"/Users/yugo/.cargo/git/checkouts/pairing-e1005e25456a4f82/868f527/src/bn256/fq12.rs","byte_start":6378,"byte_end":6382,"line_start":274,"line_end":274,"column_start":16,"column_end":20,"is_primary":true,"text":[{"text":"impl Field for Fq12 {","highlight_start":16,"highlight_end":20}],"label":"value of type `fq12::Fq12` cannot be made by multiplying all elements from a `std::iter::Iterator<Item=fq12::Fq12>`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"the trait `Product` is not implemented for `fq12::Fq12`","code":null,"level":"help","spans":[],"children":[],"rendered":null},{"message":"the following other types implement trait `Product<A>`:\n  <Option<T> as Product<Option<U>>>\n  <Result<T, E> as Product<Result<U, E>>>\n  <Simd<f32, LANES> as Product<&'a Simd<f32, LANES>>>\n  <Simd<f32, LANES> as Product>\n  <Simd<f64, LANES> as Product<&'a Simd<f64, LANES>>>\n  <Simd<f64, LANES> as Product>\n  <Simd<i16, LANES> as Product<&'a Simd<i16, LANES>>>\n  <Simd<i16, LANES> as Product>\nand 70 others","code":null,"level":"help","spans":[],"children":[],"rendered":null},{"message":"required by a bound in `ff::Field`","code":null,"level":"note","spans":[{"file_name":"/Users/yugo/.cargo/registry/src/index.crates.io-6f17d22bba15001f/ff-0.13.0/src/lib.rs","byte_start":1337,"byte_end":1344,"line_start":58,"line_end":58,"column_start":7,"column_end":14,"is_primary":true,"text":[{"text":"    + Product","highlight_start":7,"highlight_end":14}],"label":"required by this bound in `Field`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0277]\u001b[0m\u001b[0m\u001b[1m: a value of type `fq12::Fq12` cannot be made by multiplying all elements of type `fq12::Fq12` from an iterator\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0m/Users/yugo/.cargo/git/checkouts/pairing-e1005e25456a4f82/868f527/src/bn256/fq12.rs:274:16\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m274\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0mimpl Field for Fq12 {\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m               \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^^^^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9mvalue of type `fq12::Fq12` cannot be made by multiplying all elements from a `std::iter::Iterator<Item=fq12::Fq12>`\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mhelp\u001b[0m\u001b[0m: the trait `Product` is not implemented for `fq12::Fq12`\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mhelp\u001b[0m\u001b[0m: the following other types implement trait `Product<A>`:\u001b[0m\n\u001b[0m              <Option<T> as Product<Option<U>>>\u001b[0m\n\u001b[0m              <Result<T, E> as Product<Result<U, E>>>\u001b[0m\n\u001b[0m              <Simd<f32, LANES> as Product<&'a Simd<f32, LANES>>>\u001b[0m\n\u001b[0m              <Simd<f32, LANES> as Product>\u001b[0m\n\u001b[0m              <Simd<f64, LANES> as Product<&'a Simd<f64, LANES>>>\u001b[0m\n\u001b[0m              <Simd<f64, LANES> as Product>\u001b[0m\n\u001b[0m              <Simd<i16, LANES> as Product<&'a Simd<i16, LANES>>>\u001b[0m\n\u001b[0m              <Simd<i16, LANES> as Product>\u001b[0m\n\u001b[0m            and 70 others\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;10mnote\u001b[0m\u001b[0m: required by a bound in `ff::Field`\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0m/Users/yugo/.cargo/registry/src/index.crates.io-6f17d22bba15001f/ff-0.13.0/src/lib.rs:58:7\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m58\u001b[0m\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m    + Product\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m      \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;10m^^^^^^^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;10mrequired by this bound in `Field`\u001b[0m\n\n"}
{"message":"a value of type `fq12::Fq12` cannot be made by summing an iterator over elements of type `fq12::Fq12`","code":{"code":"E0277","explanation":"You tried to use a type which doesn't implement some trait in a place which\nexpected that trait.\n\nErroneous code example:\n\n```compile_fail,E0277\n// here we declare the Foo trait with a bar method\ntrait Foo {\n    fn bar(&self);\n}\n\n// we now declare a function which takes an object implementing the Foo trait\nfn some_func<T: Foo>(foo: T) {\n    foo.bar();\n}\n\nfn main() {\n    // we now call the method with the i32 type, which doesn't implement\n    // the Foo trait\n    some_func(5i32); // error: the trait bound `i32 : Foo` is not satisfied\n}\n```\n\nIn order to fix this error, verify that the type you're using does implement\nthe trait. Example:\n\n```\ntrait Foo {\n    fn bar(&self);\n}\n\n// we implement the trait on the i32 type\nimpl Foo for i32 {\n    fn bar(&self) {}\n}\n\nfn some_func<T: Foo>(foo: T) {\n    foo.bar(); // we can now use this method since i32 implements the\n               // Foo trait\n}\n\nfn main() {\n    some_func(5i32); // ok!\n}\n```\n\nOr in a generic context, an erroneous code example would look like:\n\n```compile_fail,E0277\nfn some_func<T>(foo: T) {\n    println!(\"{:?}\", foo); // error: the trait `core::fmt::Debug` is not\n                           //        implemented for the type `T`\n}\n\nfn main() {\n    // We now call the method with the i32 type,\n    // which *does* implement the Debug trait.\n    some_func(5i32);\n}\n```\n\nNote that the error here is in the definition of the generic function. Although\nwe only call it with a parameter that does implement `Debug`, the compiler\nstill rejects the function. It must work with all possible input types. In\norder to make this example compile, we need to restrict the generic type we're\naccepting:\n\n```\nuse std::fmt;\n\n// Restrict the input type to types that implement Debug.\nfn some_func<T: fmt::Debug>(foo: T) {\n    println!(\"{:?}\", foo);\n}\n\nfn main() {\n    // Calling the method is still fine, as i32 implements Debug.\n    some_func(5i32);\n\n    // This would fail to compile now:\n    // struct WithoutDebug;\n    // some_func(WithoutDebug);\n}\n```\n\nRust only looks at the signature of the called function, as such it must\nalready specify all requirements that will be used for every type parameter.\n"},"level":"error","spans":[{"file_name":"/Users/yugo/.cargo/git/checkouts/pairing-e1005e25456a4f82/868f527/src/bn256/fq12.rs","byte_start":6378,"byte_end":6382,"line_start":274,"line_end":274,"column_start":16,"column_end":20,"is_primary":true,"text":[{"text":"impl Field for Fq12 {","highlight_start":16,"highlight_end":20}],"label":"value of type `fq12::Fq12` cannot be made by summing a `std::iter::Iterator<Item=fq12::Fq12>`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"the trait `Sum` is not implemented for `fq12::Fq12`","code":null,"level":"help","spans":[],"children":[],"rendered":null},{"message":"the following other types implement trait `Sum<A>`:\n  <Duration as Sum<&'a Duration>>\n  <Duration as Sum>\n  <Gt as Sum<T>>\n  <Option<T> as Sum<Option<U>>>\n  <Result<T, E> as Sum<Result<U, E>>>\n  <Simd<f32, LANES> as Sum<&'a Simd<f32, LANES>>>\n  <Simd<f32, LANES> as Sum>\n  <Simd<f64, LANES> as Sum<&'a Simd<f64, LANES>>>\nand 76 others","code":null,"level":"help","spans":[],"children":[],"rendered":null},{"message":"required by a bound in `ff::Field`","code":null,"level":"note","spans":[{"file_name":"/Users/yugo/.cargo/registry/src/index.crates.io-6f17d22bba15001f/ff-0.13.0/src/lib.rs","byte_start":1327,"byte_end":1330,"line_start":57,"line_end":57,"column_start":7,"column_end":10,"is_primary":true,"text":[{"text":"    + Sum","highlight_start":7,"highlight_end":10}],"label":"required by this bound in `Field`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0277]\u001b[0m\u001b[0m\u001b[1m: a value of type `fq12::Fq12` cannot be made by summing an iterator over elements of type `fq12::Fq12`\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0m/Users/yugo/.cargo/git/checkouts/pairing-e1005e25456a4f82/868f527/src/bn256/fq12.rs:274:16\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m274\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0mimpl Field for Fq12 {\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m               \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^^^^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9mvalue of type `fq12::Fq12` cannot be made by summing a `std::iter::Iterator<Item=fq12::Fq12>`\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mhelp\u001b[0m\u001b[0m: the trait `Sum` is not implemented for `fq12::Fq12`\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mhelp\u001b[0m\u001b[0m: the following other types implement trait `Sum<A>`:\u001b[0m\n\u001b[0m              <Duration as Sum<&'a Duration>>\u001b[0m\n\u001b[0m              <Duration as Sum>\u001b[0m\n\u001b[0m              <Gt as Sum<T>>\u001b[0m\n\u001b[0m              <Option<T> as Sum<Option<U>>>\u001b[0m\n\u001b[0m              <Result<T, E> as Sum<Result<U, E>>>\u001b[0m\n\u001b[0m              <Simd<f32, LANES> as Sum<&'a Simd<f32, LANES>>>\u001b[0m\n\u001b[0m              <Simd<f32, LANES> as Sum>\u001b[0m\n\u001b[0m              <Simd<f64, LANES> as Sum<&'a Simd<f64, LANES>>>\u001b[0m\n\u001b[0m            and 76 others\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;10mnote\u001b[0m\u001b[0m: required by a bound in `ff::Field`\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0m/Users/yugo/.cargo/registry/src/index.crates.io-6f17d22bba15001f/ff-0.13.0/src/lib.rs:57:7\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m57\u001b[0m\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m    + Sum\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m      \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;10m^^^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;10mrequired by this bound in `Field`\u001b[0m\n\n"}
{"message":"a value of type `fq2::Fq2` cannot be made by multiplying all elements of type `&'a fq2::Fq2` from an iterator","code":{"code":"E0277","explanation":"You tried to use a type which doesn't implement some trait in a place which\nexpected that trait.\n\nErroneous code example:\n\n```compile_fail,E0277\n// here we declare the Foo trait with a bar method\ntrait Foo {\n    fn bar(&self);\n}\n\n// we now declare a function which takes an object implementing the Foo trait\nfn some_func<T: Foo>(foo: T) {\n    foo.bar();\n}\n\nfn main() {\n    // we now call the method with the i32 type, which doesn't implement\n    // the Foo trait\n    some_func(5i32); // error: the trait bound `i32 : Foo` is not satisfied\n}\n```\n\nIn order to fix this error, verify that the type you're using does implement\nthe trait. Example:\n\n```\ntrait Foo {\n    fn bar(&self);\n}\n\n// we implement the trait on the i32 type\nimpl Foo for i32 {\n    fn bar(&self) {}\n}\n\nfn some_func<T: Foo>(foo: T) {\n    foo.bar(); // we can now use this method since i32 implements the\n               // Foo trait\n}\n\nfn main() {\n    some_func(5i32); // ok!\n}\n```\n\nOr in a generic context, an erroneous code example would look like:\n\n```compile_fail,E0277\nfn some_func<T>(foo: T) {\n    println!(\"{:?}\", foo); // error: the trait `core::fmt::Debug` is not\n                           //        implemented for the type `T`\n}\n\nfn main() {\n    // We now call the method with the i32 type,\n    // which *does* implement the Debug trait.\n    some_func(5i32);\n}\n```\n\nNote that the error here is in the definition of the generic function. Although\nwe only call it with a parameter that does implement `Debug`, the compiler\nstill rejects the function. It must work with all possible input types. In\norder to make this example compile, we need to restrict the generic type we're\naccepting:\n\n```\nuse std::fmt;\n\n// Restrict the input type to types that implement Debug.\nfn some_func<T: fmt::Debug>(foo: T) {\n    println!(\"{:?}\", foo);\n}\n\nfn main() {\n    // Calling the method is still fine, as i32 implements Debug.\n    some_func(5i32);\n\n    // This would fail to compile now:\n    // struct WithoutDebug;\n    // some_func(WithoutDebug);\n}\n```\n\nRust only looks at the signature of the called function, as such it must\nalready specify all requirements that will be used for every type parameter.\n"},"level":"error","spans":[{"file_name":"/Users/yugo/.cargo/git/checkouts/pairing-e1005e25456a4f82/868f527/src/bn256/fq2.rs","byte_start":6822,"byte_end":6825,"line_start":302,"line_end":302,"column_start":16,"column_end":19,"is_primary":true,"text":[{"text":"impl Field for Fq2 {","highlight_start":16,"highlight_end":19}],"label":"value of type `fq2::Fq2` cannot be made by multiplying all elements from a `std::iter::Iterator<Item=&'a fq2::Fq2>`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"the trait `for<'a> Product<&'a fq2::Fq2>` is not implemented for `fq2::Fq2`","code":null,"level":"help","spans":[],"children":[],"rendered":null},{"message":"the following other types implement trait `Product<A>`:\n  <Option<T> as Product<Option<U>>>\n  <Result<T, E> as Product<Result<U, E>>>\n  <Simd<f32, LANES> as Product<&'a Simd<f32, LANES>>>\n  <Simd<f32, LANES> as Product>\n  <Simd<f64, LANES> as Product<&'a Simd<f64, LANES>>>\n  <Simd<f64, LANES> as Product>\n  <Simd<i16, LANES> as Product<&'a Simd<i16, LANES>>>\n  <Simd<i16, LANES> as Product>\nand 70 others","code":null,"level":"help","spans":[],"children":[],"rendered":null},{"message":"required by a bound in `ff::Field`","code":null,"level":"note","spans":[{"file_name":"/Users/yugo/.cargo/registry/src/index.crates.io-6f17d22bba15001f/ff-0.13.0/src/lib.rs","byte_start":1508,"byte_end":1533,"line_start":63,"line_end":63,"column_start":7,"column_end":32,"is_primary":true,"text":[{"text":"    + for<'a> Product<&'a Self>","highlight_start":7,"highlight_end":32}],"label":"required by this bound in `Field`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0277]\u001b[0m\u001b[0m\u001b[1m: a value of type `fq2::Fq2` cannot be made by multiplying all elements of type `&'a fq2::Fq2` from an iterator\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0m/Users/yugo/.cargo/git/checkouts/pairing-e1005e25456a4f82/868f527/src/bn256/fq2.rs:302:16\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m302\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0mimpl Field for Fq2 {\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m               \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^^^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9mvalue of type `fq2::Fq2` cannot be made by multiplying all elements from a `std::iter::Iterator<Item=&'a fq2::Fq2>`\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mhelp\u001b[0m\u001b[0m: the trait `for<'a> Product<&'a fq2::Fq2>` is not implemented for `fq2::Fq2`\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mhelp\u001b[0m\u001b[0m: the following other types implement trait `Product<A>`:\u001b[0m\n\u001b[0m              <Option<T> as Product<Option<U>>>\u001b[0m\n\u001b[0m              <Result<T, E> as Product<Result<U, E>>>\u001b[0m\n\u001b[0m              <Simd<f32, LANES> as Product<&'a Simd<f32, LANES>>>\u001b[0m\n\u001b[0m              <Simd<f32, LANES> as Product>\u001b[0m\n\u001b[0m              <Simd<f64, LANES> as Product<&'a Simd<f64, LANES>>>\u001b[0m\n\u001b[0m              <Simd<f64, LANES> as Product>\u001b[0m\n\u001b[0m              <Simd<i16, LANES> as Product<&'a Simd<i16, LANES>>>\u001b[0m\n\u001b[0m              <Simd<i16, LANES> as Product>\u001b[0m\n\u001b[0m            and 70 others\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;10mnote\u001b[0m\u001b[0m: required by a bound in `ff::Field`\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0m/Users/yugo/.cargo/registry/src/index.crates.io-6f17d22bba15001f/ff-0.13.0/src/lib.rs:63:7\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m63\u001b[0m\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m    + for<'a> Product<&'a Self>\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m      \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;10m^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;10mrequired by this bound in `Field`\u001b[0m\n\n"}
{"message":"a value of type `fq2::Fq2` cannot be made by summing an iterator over elements of type `&'a fq2::Fq2`","code":{"code":"E0277","explanation":"You tried to use a type which doesn't implement some trait in a place which\nexpected that trait.\n\nErroneous code example:\n\n```compile_fail,E0277\n// here we declare the Foo trait with a bar method\ntrait Foo {\n    fn bar(&self);\n}\n\n// we now declare a function which takes an object implementing the Foo trait\nfn some_func<T: Foo>(foo: T) {\n    foo.bar();\n}\n\nfn main() {\n    // we now call the method with the i32 type, which doesn't implement\n    // the Foo trait\n    some_func(5i32); // error: the trait bound `i32 : Foo` is not satisfied\n}\n```\n\nIn order to fix this error, verify that the type you're using does implement\nthe trait. Example:\n\n```\ntrait Foo {\n    fn bar(&self);\n}\n\n// we implement the trait on the i32 type\nimpl Foo for i32 {\n    fn bar(&self) {}\n}\n\nfn some_func<T: Foo>(foo: T) {\n    foo.bar(); // we can now use this method since i32 implements the\n               // Foo trait\n}\n\nfn main() {\n    some_func(5i32); // ok!\n}\n```\n\nOr in a generic context, an erroneous code example would look like:\n\n```compile_fail,E0277\nfn some_func<T>(foo: T) {\n    println!(\"{:?}\", foo); // error: the trait `core::fmt::Debug` is not\n                           //        implemented for the type `T`\n}\n\nfn main() {\n    // We now call the method with the i32 type,\n    // which *does* implement the Debug trait.\n    some_func(5i32);\n}\n```\n\nNote that the error here is in the definition of the generic function. Although\nwe only call it with a parameter that does implement `Debug`, the compiler\nstill rejects the function. It must work with all possible input types. In\norder to make this example compile, we need to restrict the generic type we're\naccepting:\n\n```\nuse std::fmt;\n\n// Restrict the input type to types that implement Debug.\nfn some_func<T: fmt::Debug>(foo: T) {\n    println!(\"{:?}\", foo);\n}\n\nfn main() {\n    // Calling the method is still fine, as i32 implements Debug.\n    some_func(5i32);\n\n    // This would fail to compile now:\n    // struct WithoutDebug;\n    // some_func(WithoutDebug);\n}\n```\n\nRust only looks at the signature of the called function, as such it must\nalready specify all requirements that will be used for every type parameter.\n"},"level":"error","spans":[{"file_name":"/Users/yugo/.cargo/git/checkouts/pairing-e1005e25456a4f82/868f527/src/bn256/fq2.rs","byte_start":6822,"byte_end":6825,"line_start":302,"line_end":302,"column_start":16,"column_end":19,"is_primary":true,"text":[{"text":"impl Field for Fq2 {","highlight_start":16,"highlight_end":19}],"label":"value of type `fq2::Fq2` cannot be made by summing a `std::iter::Iterator<Item=&'a fq2::Fq2>`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"the trait `for<'a> Sum<&'a fq2::Fq2>` is not implemented for `fq2::Fq2`","code":null,"level":"help","spans":[],"children":[],"rendered":null},{"message":"the following other types implement trait `Sum<A>`:\n  <Duration as Sum<&'a Duration>>\n  <Duration as Sum>\n  <Gt as Sum<T>>\n  <Option<T> as Sum<Option<U>>>\n  <Result<T, E> as Sum<Result<U, E>>>\n  <Simd<f32, LANES> as Sum<&'a Simd<f32, LANES>>>\n  <Simd<f32, LANES> as Sum>\n  <Simd<f64, LANES> as Sum<&'a Simd<f64, LANES>>>\nand 76 others","code":null,"level":"help","spans":[],"children":[],"rendered":null},{"message":"required by a bound in `ff::Field`","code":null,"level":"note","spans":[{"file_name":"/Users/yugo/.cargo/registry/src/index.crates.io-6f17d22bba15001f/ff-0.13.0/src/lib.rs","byte_start":1480,"byte_end":1501,"line_start":62,"line_end":62,"column_start":7,"column_end":28,"is_primary":true,"text":[{"text":"    + for<'a> Sum<&'a Self>","highlight_start":7,"highlight_end":28}],"label":"required by this bound in `Field`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0277]\u001b[0m\u001b[0m\u001b[1m: a value of type `fq2::Fq2` cannot be made by summing an iterator over elements of type `&'a fq2::Fq2`\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0m/Users/yugo/.cargo/git/checkouts/pairing-e1005e25456a4f82/868f527/src/bn256/fq2.rs:302:16\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m302\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0mimpl Field for Fq2 {\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m               \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^^^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9mvalue of type `fq2::Fq2` cannot be made by summing a `std::iter::Iterator<Item=&'a fq2::Fq2>`\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mhelp\u001b[0m\u001b[0m: the trait `for<'a> Sum<&'a fq2::Fq2>` is not implemented for `fq2::Fq2`\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mhelp\u001b[0m\u001b[0m: the following other types implement trait `Sum<A>`:\u001b[0m\n\u001b[0m              <Duration as Sum<&'a Duration>>\u001b[0m\n\u001b[0m              <Duration as Sum>\u001b[0m\n\u001b[0m              <Gt as Sum<T>>\u001b[0m\n\u001b[0m              <Option<T> as Sum<Option<U>>>\u001b[0m\n\u001b[0m              <Result<T, E> as Sum<Result<U, E>>>\u001b[0m\n\u001b[0m              <Simd<f32, LANES> as Sum<&'a Simd<f32, LANES>>>\u001b[0m\n\u001b[0m              <Simd<f32, LANES> as Sum>\u001b[0m\n\u001b[0m              <Simd<f64, LANES> as Sum<&'a Simd<f64, LANES>>>\u001b[0m\n\u001b[0m            and 76 others\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;10mnote\u001b[0m\u001b[0m: required by a bound in `ff::Field`\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0m/Users/yugo/.cargo/registry/src/index.crates.io-6f17d22bba15001f/ff-0.13.0/src/lib.rs:62:7\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m62\u001b[0m\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m    + for<'a> Sum<&'a Self>\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m      \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;10m^^^^^^^^^^^^^^^^^^^^^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;10mrequired by this bound in `Field`\u001b[0m\n\n"}
{"message":"a value of type `fq2::Fq2` cannot be made by multiplying all elements of type `fq2::Fq2` from an iterator","code":{"code":"E0277","explanation":"You tried to use a type which doesn't implement some trait in a place which\nexpected that trait.\n\nErroneous code example:\n\n```compile_fail,E0277\n// here we declare the Foo trait with a bar method\ntrait Foo {\n    fn bar(&self);\n}\n\n// we now declare a function which takes an object implementing the Foo trait\nfn some_func<T: Foo>(foo: T) {\n    foo.bar();\n}\n\nfn main() {\n    // we now call the method with the i32 type, which doesn't implement\n    // the Foo trait\n    some_func(5i32); // error: the trait bound `i32 : Foo` is not satisfied\n}\n```\n\nIn order to fix this error, verify that the type you're using does implement\nthe trait. Example:\n\n```\ntrait Foo {\n    fn bar(&self);\n}\n\n// we implement the trait on the i32 type\nimpl Foo for i32 {\n    fn bar(&self) {}\n}\n\nfn some_func<T: Foo>(foo: T) {\n    foo.bar(); // we can now use this method since i32 implements the\n               // Foo trait\n}\n\nfn main() {\n    some_func(5i32); // ok!\n}\n```\n\nOr in a generic context, an erroneous code example would look like:\n\n```compile_fail,E0277\nfn some_func<T>(foo: T) {\n    println!(\"{:?}\", foo); // error: the trait `core::fmt::Debug` is not\n                           //        implemented for the type `T`\n}\n\nfn main() {\n    // We now call the method with the i32 type,\n    // which *does* implement the Debug trait.\n    some_func(5i32);\n}\n```\n\nNote that the error here is in the definition of the generic function. Although\nwe only call it with a parameter that does implement `Debug`, the compiler\nstill rejects the function. It must work with all possible input types. In\norder to make this example compile, we need to restrict the generic type we're\naccepting:\n\n```\nuse std::fmt;\n\n// Restrict the input type to types that implement Debug.\nfn some_func<T: fmt::Debug>(foo: T) {\n    println!(\"{:?}\", foo);\n}\n\nfn main() {\n    // Calling the method is still fine, as i32 implements Debug.\n    some_func(5i32);\n\n    // This would fail to compile now:\n    // struct WithoutDebug;\n    // some_func(WithoutDebug);\n}\n```\n\nRust only looks at the signature of the called function, as such it must\nalready specify all requirements that will be used for every type parameter.\n"},"level":"error","spans":[{"file_name":"/Users/yugo/.cargo/git/checkouts/pairing-e1005e25456a4f82/868f527/src/bn256/fq2.rs","byte_start":6822,"byte_end":6825,"line_start":302,"line_end":302,"column_start":16,"column_end":19,"is_primary":true,"text":[{"text":"impl Field for Fq2 {","highlight_start":16,"highlight_end":19}],"label":"value of type `fq2::Fq2` cannot be made by multiplying all elements from a `std::iter::Iterator<Item=fq2::Fq2>`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"the trait `Product` is not implemented for `fq2::Fq2`","code":null,"level":"help","spans":[],"children":[],"rendered":null},{"message":"the following other types implement trait `Product<A>`:\n  <Option<T> as Product<Option<U>>>\n  <Result<T, E> as Product<Result<U, E>>>\n  <Simd<f32, LANES> as Product<&'a Simd<f32, LANES>>>\n  <Simd<f32, LANES> as Product>\n  <Simd<f64, LANES> as Product<&'a Simd<f64, LANES>>>\n  <Simd<f64, LANES> as Product>\n  <Simd<i16, LANES> as Product<&'a Simd<i16, LANES>>>\n  <Simd<i16, LANES> as Product>\nand 70 others","code":null,"level":"help","spans":[],"children":[],"rendered":null},{"message":"required by a bound in `ff::Field`","code":null,"level":"note","spans":[{"file_name":"/Users/yugo/.cargo/registry/src/index.crates.io-6f17d22bba15001f/ff-0.13.0/src/lib.rs","byte_start":1337,"byte_end":1344,"line_start":58,"line_end":58,"column_start":7,"column_end":14,"is_primary":true,"text":[{"text":"    + Product","highlight_start":7,"highlight_end":14}],"label":"required by this bound in `Field`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0277]\u001b[0m\u001b[0m\u001b[1m: a value of type `fq2::Fq2` cannot be made by multiplying all elements of type `fq2::Fq2` from an iterator\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0m/Users/yugo/.cargo/git/checkouts/pairing-e1005e25456a4f82/868f527/src/bn256/fq2.rs:302:16\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m302\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0mimpl Field for Fq2 {\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m               \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^^^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9mvalue of type `fq2::Fq2` cannot be made by multiplying all elements from a `std::iter::Iterator<Item=fq2::Fq2>`\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mhelp\u001b[0m\u001b[0m: the trait `Product` is not implemented for `fq2::Fq2`\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mhelp\u001b[0m\u001b[0m: the following other types implement trait `Product<A>`:\u001b[0m\n\u001b[0m              <Option<T> as Product<Option<U>>>\u001b[0m\n\u001b[0m              <Result<T, E> as Product<Result<U, E>>>\u001b[0m\n\u001b[0m              <Simd<f32, LANES> as Product<&'a Simd<f32, LANES>>>\u001b[0m\n\u001b[0m              <Simd<f32, LANES> as Product>\u001b[0m\n\u001b[0m              <Simd<f64, LANES> as Product<&'a Simd<f64, LANES>>>\u001b[0m\n\u001b[0m              <Simd<f64, LANES> as Product>\u001b[0m\n\u001b[0m              <Simd<i16, LANES> as Product<&'a Simd<i16, LANES>>>\u001b[0m\n\u001b[0m              <Simd<i16, LANES> as Product>\u001b[0m\n\u001b[0m            and 70 others\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;10mnote\u001b[0m\u001b[0m: required by a bound in `ff::Field`\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0m/Users/yugo/.cargo/registry/src/index.crates.io-6f17d22bba15001f/ff-0.13.0/src/lib.rs:58:7\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m58\u001b[0m\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m    + Product\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m      \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;10m^^^^^^^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;10mrequired by this bound in `Field`\u001b[0m\n\n"}
{"message":"a value of type `fq2::Fq2` cannot be made by summing an iterator over elements of type `fq2::Fq2`","code":{"code":"E0277","explanation":"You tried to use a type which doesn't implement some trait in a place which\nexpected that trait.\n\nErroneous code example:\n\n```compile_fail,E0277\n// here we declare the Foo trait with a bar method\ntrait Foo {\n    fn bar(&self);\n}\n\n// we now declare a function which takes an object implementing the Foo trait\nfn some_func<T: Foo>(foo: T) {\n    foo.bar();\n}\n\nfn main() {\n    // we now call the method with the i32 type, which doesn't implement\n    // the Foo trait\n    some_func(5i32); // error: the trait bound `i32 : Foo` is not satisfied\n}\n```\n\nIn order to fix this error, verify that the type you're using does implement\nthe trait. Example:\n\n```\ntrait Foo {\n    fn bar(&self);\n}\n\n// we implement the trait on the i32 type\nimpl Foo for i32 {\n    fn bar(&self) {}\n}\n\nfn some_func<T: Foo>(foo: T) {\n    foo.bar(); // we can now use this method since i32 implements the\n               // Foo trait\n}\n\nfn main() {\n    some_func(5i32); // ok!\n}\n```\n\nOr in a generic context, an erroneous code example would look like:\n\n```compile_fail,E0277\nfn some_func<T>(foo: T) {\n    println!(\"{:?}\", foo); // error: the trait `core::fmt::Debug` is not\n                           //        implemented for the type `T`\n}\n\nfn main() {\n    // We now call the method with the i32 type,\n    // which *does* implement the Debug trait.\n    some_func(5i32);\n}\n```\n\nNote that the error here is in the definition of the generic function. Although\nwe only call it with a parameter that does implement `Debug`, the compiler\nstill rejects the function. It must work with all possible input types. In\norder to make this example compile, we need to restrict the generic type we're\naccepting:\n\n```\nuse std::fmt;\n\n// Restrict the input type to types that implement Debug.\nfn some_func<T: fmt::Debug>(foo: T) {\n    println!(\"{:?}\", foo);\n}\n\nfn main() {\n    // Calling the method is still fine, as i32 implements Debug.\n    some_func(5i32);\n\n    // This would fail to compile now:\n    // struct WithoutDebug;\n    // some_func(WithoutDebug);\n}\n```\n\nRust only looks at the signature of the called function, as such it must\nalready specify all requirements that will be used for every type parameter.\n"},"level":"error","spans":[{"file_name":"/Users/yugo/.cargo/git/checkouts/pairing-e1005e25456a4f82/868f527/src/bn256/fq2.rs","byte_start":6822,"byte_end":6825,"line_start":302,"line_end":302,"column_start":16,"column_end":19,"is_primary":true,"text":[{"text":"impl Field for Fq2 {","highlight_start":16,"highlight_end":19}],"label":"value of type `fq2::Fq2` cannot be made by summing a `std::iter::Iterator<Item=fq2::Fq2>`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"the trait `Sum` is not implemented for `fq2::Fq2`","code":null,"level":"help","spans":[],"children":[],"rendered":null},{"message":"the following other types implement trait `Sum<A>`:\n  <Duration as Sum<&'a Duration>>\n  <Duration as Sum>\n  <Gt as Sum<T>>\n  <Option<T> as Sum<Option<U>>>\n  <Result<T, E> as Sum<Result<U, E>>>\n  <Simd<f32, LANES> as Sum<&'a Simd<f32, LANES>>>\n  <Simd<f32, LANES> as Sum>\n  <Simd<f64, LANES> as Sum<&'a Simd<f64, LANES>>>\nand 76 others","code":null,"level":"help","spans":[],"children":[],"rendered":null},{"message":"required by a bound in `ff::Field`","code":null,"level":"note","spans":[{"file_name":"/Users/yugo/.cargo/registry/src/index.crates.io-6f17d22bba15001f/ff-0.13.0/src/lib.rs","byte_start":1327,"byte_end":1330,"line_start":57,"line_end":57,"column_start":7,"column_end":10,"is_primary":true,"text":[{"text":"    + Sum","highlight_start":7,"highlight_end":10}],"label":"required by this bound in `Field`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0277]\u001b[0m\u001b[0m\u001b[1m: a value of type `fq2::Fq2` cannot be made by summing an iterator over elements of type `fq2::Fq2`\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0m/Users/yugo/.cargo/git/checkouts/pairing-e1005e25456a4f82/868f527/src/bn256/fq2.rs:302:16\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m302\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0mimpl Field for Fq2 {\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m               \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^^^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9mvalue of type `fq2::Fq2` cannot be made by summing a `std::iter::Iterator<Item=fq2::Fq2>`\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mhelp\u001b[0m\u001b[0m: the trait `Sum` is not implemented for `fq2::Fq2`\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mhelp\u001b[0m\u001b[0m: the following other types implement trait `Sum<A>`:\u001b[0m\n\u001b[0m              <Duration as Sum<&'a Duration>>\u001b[0m\n\u001b[0m              <Duration as Sum>\u001b[0m\n\u001b[0m              <Gt as Sum<T>>\u001b[0m\n\u001b[0m              <Option<T> as Sum<Option<U>>>\u001b[0m\n\u001b[0m              <Result<T, E> as Sum<Result<U, E>>>\u001b[0m\n\u001b[0m              <Simd<f32, LANES> as Sum<&'a Simd<f32, LANES>>>\u001b[0m\n\u001b[0m              <Simd<f32, LANES> as Sum>\u001b[0m\n\u001b[0m              <Simd<f64, LANES> as Sum<&'a Simd<f64, LANES>>>\u001b[0m\n\u001b[0m            and 76 others\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;10mnote\u001b[0m\u001b[0m: required by a bound in `ff::Field`\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0m/Users/yugo/.cargo/registry/src/index.crates.io-6f17d22bba15001f/ff-0.13.0/src/lib.rs:57:7\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m57\u001b[0m\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m    + Sum\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m      \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;10m^^^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;10mrequired by this bound in `Field`\u001b[0m\n\n"}
{"message":"a value of type `fq2::Fq2` cannot be made by multiplying all elements of type `&'a fq2::Fq2` from an iterator","code":{"code":"E0277","explanation":"You tried to use a type which doesn't implement some trait in a place which\nexpected that trait.\n\nErroneous code example:\n\n```compile_fail,E0277\n// here we declare the Foo trait with a bar method\ntrait Foo {\n    fn bar(&self);\n}\n\n// we now declare a function which takes an object implementing the Foo trait\nfn some_func<T: Foo>(foo: T) {\n    foo.bar();\n}\n\nfn main() {\n    // we now call the method with the i32 type, which doesn't implement\n    // the Foo trait\n    some_func(5i32); // error: the trait bound `i32 : Foo` is not satisfied\n}\n```\n\nIn order to fix this error, verify that the type you're using does implement\nthe trait. Example:\n\n```\ntrait Foo {\n    fn bar(&self);\n}\n\n// we implement the trait on the i32 type\nimpl Foo for i32 {\n    fn bar(&self) {}\n}\n\nfn some_func<T: Foo>(foo: T) {\n    foo.bar(); // we can now use this method since i32 implements the\n               // Foo trait\n}\n\nfn main() {\n    some_func(5i32); // ok!\n}\n```\n\nOr in a generic context, an erroneous code example would look like:\n\n```compile_fail,E0277\nfn some_func<T>(foo: T) {\n    println!(\"{:?}\", foo); // error: the trait `core::fmt::Debug` is not\n                           //        implemented for the type `T`\n}\n\nfn main() {\n    // We now call the method with the i32 type,\n    // which *does* implement the Debug trait.\n    some_func(5i32);\n}\n```\n\nNote that the error here is in the definition of the generic function. Although\nwe only call it with a parameter that does implement `Debug`, the compiler\nstill rejects the function. It must work with all possible input types. In\norder to make this example compile, we need to restrict the generic type we're\naccepting:\n\n```\nuse std::fmt;\n\n// Restrict the input type to types that implement Debug.\nfn some_func<T: fmt::Debug>(foo: T) {\n    println!(\"{:?}\", foo);\n}\n\nfn main() {\n    // Calling the method is still fine, as i32 implements Debug.\n    some_func(5i32);\n\n    // This would fail to compile now:\n    // struct WithoutDebug;\n    // some_func(WithoutDebug);\n}\n```\n\nRust only looks at the signature of the called function, as such it must\nalready specify all requirements that will be used for every type parameter.\n"},"level":"error","spans":[{"file_name":"/Users/yugo/.cargo/git/checkouts/pairing-e1005e25456a4f82/868f527/src/bn256/fq2.rs","byte_start":9324,"byte_end":9327,"line_start":397,"line_end":397,"column_start":18,"column_end":21,"is_primary":true,"text":[{"text":"impl BaseExt for Fq2 {","highlight_start":18,"highlight_end":21}],"label":"value of type `fq2::Fq2` cannot be made by multiplying all elements from a `std::iter::Iterator<Item=&'a fq2::Fq2>`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"the trait `for<'a> Product<&'a fq2::Fq2>` is not implemented for `fq2::Fq2`","code":null,"level":"help","spans":[],"children":[],"rendered":null},{"message":"the following other types implement trait `Product<A>`:\n  <Option<T> as Product<Option<U>>>\n  <Result<T, E> as Product<Result<U, E>>>\n  <Simd<f32, LANES> as Product<&'a Simd<f32, LANES>>>\n  <Simd<f32, LANES> as Product>\n  <Simd<f64, LANES> as Product<&'a Simd<f64, LANES>>>\n  <Simd<f64, LANES> as Product>\n  <Simd<i16, LANES> as Product<&'a Simd<i16, LANES>>>\n  <Simd<i16, LANES> as Product>\nand 70 others","code":null,"level":"help","spans":[],"children":[],"rendered":null},{"message":"required for `fq2::Fq2` to implement `ff::Field`","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"required by a bound in `fields::BaseExt`","code":null,"level":"note","spans":[{"file_name":"/Users/yugo/.cargo/git/checkouts/pairing-e1005e25456a4f82/868f527/src/arithmetic/fields.rs","byte_start":422,"byte_end":431,"line_start":15,"line_end":15,"column_start":20,"column_end":29,"is_primary":true,"text":[{"text":"pub trait BaseExt: ff::Field + Ord + ConstantTimeEq {","highlight_start":20,"highlight_end":29}],"label":"required by this bound in `BaseExt`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0277]\u001b[0m\u001b[0m\u001b[1m: a value of type `fq2::Fq2` cannot be made by multiplying all elements of type `&'a fq2::Fq2` from an iterator\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0m/Users/yugo/.cargo/git/checkouts/pairing-e1005e25456a4f82/868f527/src/bn256/fq2.rs:397:18\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m397\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0mimpl BaseExt for Fq2 {\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m                 \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^^^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9mvalue of type `fq2::Fq2` cannot be made by multiplying all elements from a `std::iter::Iterator<Item=&'a fq2::Fq2>`\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mhelp\u001b[0m\u001b[0m: the trait `for<'a> Product<&'a fq2::Fq2>` is not implemented for `fq2::Fq2`\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mhelp\u001b[0m\u001b[0m: the following other types implement trait `Product<A>`:\u001b[0m\n\u001b[0m              <Option<T> as Product<Option<U>>>\u001b[0m\n\u001b[0m              <Result<T, E> as Product<Result<U, E>>>\u001b[0m\n\u001b[0m              <Simd<f32, LANES> as Product<&'a Simd<f32, LANES>>>\u001b[0m\n\u001b[0m              <Simd<f32, LANES> as Product>\u001b[0m\n\u001b[0m              <Simd<f64, LANES> as Product<&'a Simd<f64, LANES>>>\u001b[0m\n\u001b[0m              <Simd<f64, LANES> as Product>\u001b[0m\n\u001b[0m              <Simd<i16, LANES> as Product<&'a Simd<i16, LANES>>>\u001b[0m\n\u001b[0m              <Simd<i16, LANES> as Product>\u001b[0m\n\u001b[0m            and 70 others\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mnote\u001b[0m\u001b[0m: required for `fq2::Fq2` to implement `ff::Field`\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;10mnote\u001b[0m\u001b[0m: required by a bound in `fields::BaseExt`\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0m/Users/yugo/.cargo/git/checkouts/pairing-e1005e25456a4f82/868f527/src/arithmetic/fields.rs:15:20\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m15\u001b[0m\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0mpub trait BaseExt: ff::Field + Ord + ConstantTimeEq {\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m                   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;10m^^^^^^^^^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;10mrequired by this bound in `BaseExt`\u001b[0m\n\n"}
{"message":"a value of type `fq2::Fq2` cannot be made by summing an iterator over elements of type `&'a fq2::Fq2`","code":{"code":"E0277","explanation":"You tried to use a type which doesn't implement some trait in a place which\nexpected that trait.\n\nErroneous code example:\n\n```compile_fail,E0277\n// here we declare the Foo trait with a bar method\ntrait Foo {\n    fn bar(&self);\n}\n\n// we now declare a function which takes an object implementing the Foo trait\nfn some_func<T: Foo>(foo: T) {\n    foo.bar();\n}\n\nfn main() {\n    // we now call the method with the i32 type, which doesn't implement\n    // the Foo trait\n    some_func(5i32); // error: the trait bound `i32 : Foo` is not satisfied\n}\n```\n\nIn order to fix this error, verify that the type you're using does implement\nthe trait. Example:\n\n```\ntrait Foo {\n    fn bar(&self);\n}\n\n// we implement the trait on the i32 type\nimpl Foo for i32 {\n    fn bar(&self) {}\n}\n\nfn some_func<T: Foo>(foo: T) {\n    foo.bar(); // we can now use this method since i32 implements the\n               // Foo trait\n}\n\nfn main() {\n    some_func(5i32); // ok!\n}\n```\n\nOr in a generic context, an erroneous code example would look like:\n\n```compile_fail,E0277\nfn some_func<T>(foo: T) {\n    println!(\"{:?}\", foo); // error: the trait `core::fmt::Debug` is not\n                           //        implemented for the type `T`\n}\n\nfn main() {\n    // We now call the method with the i32 type,\n    // which *does* implement the Debug trait.\n    some_func(5i32);\n}\n```\n\nNote that the error here is in the definition of the generic function. Although\nwe only call it with a parameter that does implement `Debug`, the compiler\nstill rejects the function. It must work with all possible input types. In\norder to make this example compile, we need to restrict the generic type we're\naccepting:\n\n```\nuse std::fmt;\n\n// Restrict the input type to types that implement Debug.\nfn some_func<T: fmt::Debug>(foo: T) {\n    println!(\"{:?}\", foo);\n}\n\nfn main() {\n    // Calling the method is still fine, as i32 implements Debug.\n    some_func(5i32);\n\n    // This would fail to compile now:\n    // struct WithoutDebug;\n    // some_func(WithoutDebug);\n}\n```\n\nRust only looks at the signature of the called function, as such it must\nalready specify all requirements that will be used for every type parameter.\n"},"level":"error","spans":[{"file_name":"/Users/yugo/.cargo/git/checkouts/pairing-e1005e25456a4f82/868f527/src/bn256/fq2.rs","byte_start":9324,"byte_end":9327,"line_start":397,"line_end":397,"column_start":18,"column_end":21,"is_primary":true,"text":[{"text":"impl BaseExt for Fq2 {","highlight_start":18,"highlight_end":21}],"label":"value of type `fq2::Fq2` cannot be made by summing a `std::iter::Iterator<Item=&'a fq2::Fq2>`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"the trait `for<'a> Sum<&'a fq2::Fq2>` is not implemented for `fq2::Fq2`","code":null,"level":"help","spans":[],"children":[],"rendered":null},{"message":"the following other types implement trait `Sum<A>`:\n  <Duration as Sum<&'a Duration>>\n  <Duration as Sum>\n  <Gt as Sum<T>>\n  <Option<T> as Sum<Option<U>>>\n  <Result<T, E> as Sum<Result<U, E>>>\n  <Simd<f32, LANES> as Sum<&'a Simd<f32, LANES>>>\n  <Simd<f32, LANES> as Sum>\n  <Simd<f64, LANES> as Sum<&'a Simd<f64, LANES>>>\nand 76 others","code":null,"level":"help","spans":[],"children":[],"rendered":null},{"message":"required for `fq2::Fq2` to implement `ff::Field`","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"required by a bound in `fields::BaseExt`","code":null,"level":"note","spans":[{"file_name":"/Users/yugo/.cargo/git/checkouts/pairing-e1005e25456a4f82/868f527/src/arithmetic/fields.rs","byte_start":422,"byte_end":431,"line_start":15,"line_end":15,"column_start":20,"column_end":29,"is_primary":true,"text":[{"text":"pub trait BaseExt: ff::Field + Ord + ConstantTimeEq {","highlight_start":20,"highlight_end":29}],"label":"required by this bound in `BaseExt`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0277]\u001b[0m\u001b[0m\u001b[1m: a value of type `fq2::Fq2` cannot be made by summing an iterator over elements of type `&'a fq2::Fq2`\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0m/Users/yugo/.cargo/git/checkouts/pairing-e1005e25456a4f82/868f527/src/bn256/fq2.rs:397:18\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m397\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0mimpl BaseExt for Fq2 {\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m                 \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^^^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9mvalue of type `fq2::Fq2` cannot be made by summing a `std::iter::Iterator<Item=&'a fq2::Fq2>`\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mhelp\u001b[0m\u001b[0m: the trait `for<'a> Sum<&'a fq2::Fq2>` is not implemented for `fq2::Fq2`\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mhelp\u001b[0m\u001b[0m: the following other types implement trait `Sum<A>`:\u001b[0m\n\u001b[0m              <Duration as Sum<&'a Duration>>\u001b[0m\n\u001b[0m              <Duration as Sum>\u001b[0m\n\u001b[0m              <Gt as Sum<T>>\u001b[0m\n\u001b[0m              <Option<T> as Sum<Option<U>>>\u001b[0m\n\u001b[0m              <Result<T, E> as Sum<Result<U, E>>>\u001b[0m\n\u001b[0m              <Simd<f32, LANES> as Sum<&'a Simd<f32, LANES>>>\u001b[0m\n\u001b[0m              <Simd<f32, LANES> as Sum>\u001b[0m\n\u001b[0m              <Simd<f64, LANES> as Sum<&'a Simd<f64, LANES>>>\u001b[0m\n\u001b[0m            and 76 others\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mnote\u001b[0m\u001b[0m: required for `fq2::Fq2` to implement `ff::Field`\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;10mnote\u001b[0m\u001b[0m: required by a bound in `fields::BaseExt`\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0m/Users/yugo/.cargo/git/checkouts/pairing-e1005e25456a4f82/868f527/src/arithmetic/fields.rs:15:20\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m15\u001b[0m\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0mpub trait BaseExt: ff::Field + Ord + ConstantTimeEq {\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m                   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;10m^^^^^^^^^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;10mrequired by this bound in `BaseExt`\u001b[0m\n\n"}
{"message":"a value of type `fq2::Fq2` cannot be made by multiplying all elements of type `fq2::Fq2` from an iterator","code":{"code":"E0277","explanation":"You tried to use a type which doesn't implement some trait in a place which\nexpected that trait.\n\nErroneous code example:\n\n```compile_fail,E0277\n// here we declare the Foo trait with a bar method\ntrait Foo {\n    fn bar(&self);\n}\n\n// we now declare a function which takes an object implementing the Foo trait\nfn some_func<T: Foo>(foo: T) {\n    foo.bar();\n}\n\nfn main() {\n    // we now call the method with the i32 type, which doesn't implement\n    // the Foo trait\n    some_func(5i32); // error: the trait bound `i32 : Foo` is not satisfied\n}\n```\n\nIn order to fix this error, verify that the type you're using does implement\nthe trait. Example:\n\n```\ntrait Foo {\n    fn bar(&self);\n}\n\n// we implement the trait on the i32 type\nimpl Foo for i32 {\n    fn bar(&self) {}\n}\n\nfn some_func<T: Foo>(foo: T) {\n    foo.bar(); // we can now use this method since i32 implements the\n               // Foo trait\n}\n\nfn main() {\n    some_func(5i32); // ok!\n}\n```\n\nOr in a generic context, an erroneous code example would look like:\n\n```compile_fail,E0277\nfn some_func<T>(foo: T) {\n    println!(\"{:?}\", foo); // error: the trait `core::fmt::Debug` is not\n                           //        implemented for the type `T`\n}\n\nfn main() {\n    // We now call the method with the i32 type,\n    // which *does* implement the Debug trait.\n    some_func(5i32);\n}\n```\n\nNote that the error here is in the definition of the generic function. Although\nwe only call it with a parameter that does implement `Debug`, the compiler\nstill rejects the function. It must work with all possible input types. In\norder to make this example compile, we need to restrict the generic type we're\naccepting:\n\n```\nuse std::fmt;\n\n// Restrict the input type to types that implement Debug.\nfn some_func<T: fmt::Debug>(foo: T) {\n    println!(\"{:?}\", foo);\n}\n\nfn main() {\n    // Calling the method is still fine, as i32 implements Debug.\n    some_func(5i32);\n\n    // This would fail to compile now:\n    // struct WithoutDebug;\n    // some_func(WithoutDebug);\n}\n```\n\nRust only looks at the signature of the called function, as such it must\nalready specify all requirements that will be used for every type parameter.\n"},"level":"error","spans":[{"file_name":"/Users/yugo/.cargo/git/checkouts/pairing-e1005e25456a4f82/868f527/src/bn256/fq2.rs","byte_start":9324,"byte_end":9327,"line_start":397,"line_end":397,"column_start":18,"column_end":21,"is_primary":true,"text":[{"text":"impl BaseExt for Fq2 {","highlight_start":18,"highlight_end":21}],"label":"value of type `fq2::Fq2` cannot be made by multiplying all elements from a `std::iter::Iterator<Item=fq2::Fq2>`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"the trait `Product` is not implemented for `fq2::Fq2`","code":null,"level":"help","spans":[],"children":[],"rendered":null},{"message":"the following other types implement trait `Product<A>`:\n  <Option<T> as Product<Option<U>>>\n  <Result<T, E> as Product<Result<U, E>>>\n  <Simd<f32, LANES> as Product<&'a Simd<f32, LANES>>>\n  <Simd<f32, LANES> as Product>\n  <Simd<f64, LANES> as Product<&'a Simd<f64, LANES>>>\n  <Simd<f64, LANES> as Product>\n  <Simd<i16, LANES> as Product<&'a Simd<i16, LANES>>>\n  <Simd<i16, LANES> as Product>\nand 70 others","code":null,"level":"help","spans":[],"children":[],"rendered":null},{"message":"required for `fq2::Fq2` to implement `ff::Field`","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"required by a bound in `fields::BaseExt`","code":null,"level":"note","spans":[{"file_name":"/Users/yugo/.cargo/git/checkouts/pairing-e1005e25456a4f82/868f527/src/arithmetic/fields.rs","byte_start":422,"byte_end":431,"line_start":15,"line_end":15,"column_start":20,"column_end":29,"is_primary":true,"text":[{"text":"pub trait BaseExt: ff::Field + Ord + ConstantTimeEq {","highlight_start":20,"highlight_end":29}],"label":"required by this bound in `BaseExt`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0277]\u001b[0m\u001b[0m\u001b[1m: a value of type `fq2::Fq2` cannot be made by multiplying all elements of type `fq2::Fq2` from an iterator\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0m/Users/yugo/.cargo/git/checkouts/pairing-e1005e25456a4f82/868f527/src/bn256/fq2.rs:397:18\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m397\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0mimpl BaseExt for Fq2 {\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m                 \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^^^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9mvalue of type `fq2::Fq2` cannot be made by multiplying all elements from a `std::iter::Iterator<Item=fq2::Fq2>`\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mhelp\u001b[0m\u001b[0m: the trait `Product` is not implemented for `fq2::Fq2`\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mhelp\u001b[0m\u001b[0m: the following other types implement trait `Product<A>`:\u001b[0m\n\u001b[0m              <Option<T> as Product<Option<U>>>\u001b[0m\n\u001b[0m              <Result<T, E> as Product<Result<U, E>>>\u001b[0m\n\u001b[0m              <Simd<f32, LANES> as Product<&'a Simd<f32, LANES>>>\u001b[0m\n\u001b[0m              <Simd<f32, LANES> as Product>\u001b[0m\n\u001b[0m              <Simd<f64, LANES> as Product<&'a Simd<f64, LANES>>>\u001b[0m\n\u001b[0m              <Simd<f64, LANES> as Product>\u001b[0m\n\u001b[0m              <Simd<i16, LANES> as Product<&'a Simd<i16, LANES>>>\u001b[0m\n\u001b[0m              <Simd<i16, LANES> as Product>\u001b[0m\n\u001b[0m            and 70 others\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mnote\u001b[0m\u001b[0m: required for `fq2::Fq2` to implement `ff::Field`\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;10mnote\u001b[0m\u001b[0m: required by a bound in `fields::BaseExt`\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0m/Users/yugo/.cargo/git/checkouts/pairing-e1005e25456a4f82/868f527/src/arithmetic/fields.rs:15:20\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m15\u001b[0m\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0mpub trait BaseExt: ff::Field + Ord + ConstantTimeEq {\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m                   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;10m^^^^^^^^^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;10mrequired by this bound in `BaseExt`\u001b[0m\n\n"}
{"message":"a value of type `fq2::Fq2` cannot be made by summing an iterator over elements of type `fq2::Fq2`","code":{"code":"E0277","explanation":"You tried to use a type which doesn't implement some trait in a place which\nexpected that trait.\n\nErroneous code example:\n\n```compile_fail,E0277\n// here we declare the Foo trait with a bar method\ntrait Foo {\n    fn bar(&self);\n}\n\n// we now declare a function which takes an object implementing the Foo trait\nfn some_func<T: Foo>(foo: T) {\n    foo.bar();\n}\n\nfn main() {\n    // we now call the method with the i32 type, which doesn't implement\n    // the Foo trait\n    some_func(5i32); // error: the trait bound `i32 : Foo` is not satisfied\n}\n```\n\nIn order to fix this error, verify that the type you're using does implement\nthe trait. Example:\n\n```\ntrait Foo {\n    fn bar(&self);\n}\n\n// we implement the trait on the i32 type\nimpl Foo for i32 {\n    fn bar(&self) {}\n}\n\nfn some_func<T: Foo>(foo: T) {\n    foo.bar(); // we can now use this method since i32 implements the\n               // Foo trait\n}\n\nfn main() {\n    some_func(5i32); // ok!\n}\n```\n\nOr in a generic context, an erroneous code example would look like:\n\n```compile_fail,E0277\nfn some_func<T>(foo: T) {\n    println!(\"{:?}\", foo); // error: the trait `core::fmt::Debug` is not\n                           //        implemented for the type `T`\n}\n\nfn main() {\n    // We now call the method with the i32 type,\n    // which *does* implement the Debug trait.\n    some_func(5i32);\n}\n```\n\nNote that the error here is in the definition of the generic function. Although\nwe only call it with a parameter that does implement `Debug`, the compiler\nstill rejects the function. It must work with all possible input types. In\norder to make this example compile, we need to restrict the generic type we're\naccepting:\n\n```\nuse std::fmt;\n\n// Restrict the input type to types that implement Debug.\nfn some_func<T: fmt::Debug>(foo: T) {\n    println!(\"{:?}\", foo);\n}\n\nfn main() {\n    // Calling the method is still fine, as i32 implements Debug.\n    some_func(5i32);\n\n    // This would fail to compile now:\n    // struct WithoutDebug;\n    // some_func(WithoutDebug);\n}\n```\n\nRust only looks at the signature of the called function, as such it must\nalready specify all requirements that will be used for every type parameter.\n"},"level":"error","spans":[{"file_name":"/Users/yugo/.cargo/git/checkouts/pairing-e1005e25456a4f82/868f527/src/bn256/fq2.rs","byte_start":9324,"byte_end":9327,"line_start":397,"line_end":397,"column_start":18,"column_end":21,"is_primary":true,"text":[{"text":"impl BaseExt for Fq2 {","highlight_start":18,"highlight_end":21}],"label":"value of type `fq2::Fq2` cannot be made by summing a `std::iter::Iterator<Item=fq2::Fq2>`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"the trait `Sum` is not implemented for `fq2::Fq2`","code":null,"level":"help","spans":[],"children":[],"rendered":null},{"message":"the following other types implement trait `Sum<A>`:\n  <Duration as Sum<&'a Duration>>\n  <Duration as Sum>\n  <Gt as Sum<T>>\n  <Option<T> as Sum<Option<U>>>\n  <Result<T, E> as Sum<Result<U, E>>>\n  <Simd<f32, LANES> as Sum<&'a Simd<f32, LANES>>>\n  <Simd<f32, LANES> as Sum>\n  <Simd<f64, LANES> as Sum<&'a Simd<f64, LANES>>>\nand 76 others","code":null,"level":"help","spans":[],"children":[],"rendered":null},{"message":"required for `fq2::Fq2` to implement `ff::Field`","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"required by a bound in `fields::BaseExt`","code":null,"level":"note","spans":[{"file_name":"/Users/yugo/.cargo/git/checkouts/pairing-e1005e25456a4f82/868f527/src/arithmetic/fields.rs","byte_start":422,"byte_end":431,"line_start":15,"line_end":15,"column_start":20,"column_end":29,"is_primary":true,"text":[{"text":"pub trait BaseExt: ff::Field + Ord + ConstantTimeEq {","highlight_start":20,"highlight_end":29}],"label":"required by this bound in `BaseExt`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0277]\u001b[0m\u001b[0m\u001b[1m: a value of type `fq2::Fq2` cannot be made by summing an iterator over elements of type `fq2::Fq2`\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0m/Users/yugo/.cargo/git/checkouts/pairing-e1005e25456a4f82/868f527/src/bn256/fq2.rs:397:18\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m397\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0mimpl BaseExt for Fq2 {\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m                 \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^^^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9mvalue of type `fq2::Fq2` cannot be made by summing a `std::iter::Iterator<Item=fq2::Fq2>`\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mhelp\u001b[0m\u001b[0m: the trait `Sum` is not implemented for `fq2::Fq2`\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mhelp\u001b[0m\u001b[0m: the following other types implement trait `Sum<A>`:\u001b[0m\n\u001b[0m              <Duration as Sum<&'a Duration>>\u001b[0m\n\u001b[0m              <Duration as Sum>\u001b[0m\n\u001b[0m              <Gt as Sum<T>>\u001b[0m\n\u001b[0m              <Option<T> as Sum<Option<U>>>\u001b[0m\n\u001b[0m              <Result<T, E> as Sum<Result<U, E>>>\u001b[0m\n\u001b[0m              <Simd<f32, LANES> as Sum<&'a Simd<f32, LANES>>>\u001b[0m\n\u001b[0m              <Simd<f32, LANES> as Sum>\u001b[0m\n\u001b[0m              <Simd<f64, LANES> as Sum<&'a Simd<f64, LANES>>>\u001b[0m\n\u001b[0m            and 76 others\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mnote\u001b[0m\u001b[0m: required for `fq2::Fq2` to implement `ff::Field`\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;10mnote\u001b[0m\u001b[0m: required by a bound in `fields::BaseExt`\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0m/Users/yugo/.cargo/git/checkouts/pairing-e1005e25456a4f82/868f527/src/arithmetic/fields.rs:15:20\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m15\u001b[0m\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0mpub trait BaseExt: ff::Field + Ord + ConstantTimeEq {\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m                   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;10m^^^^^^^^^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;10mrequired by this bound in `BaseExt`\u001b[0m\n\n"}
{"message":"a value of type `Fq6` cannot be made by multiplying all elements of type `&'a Fq6` from an iterator","code":{"code":"E0277","explanation":"You tried to use a type which doesn't implement some trait in a place which\nexpected that trait.\n\nErroneous code example:\n\n```compile_fail,E0277\n// here we declare the Foo trait with a bar method\ntrait Foo {\n    fn bar(&self);\n}\n\n// we now declare a function which takes an object implementing the Foo trait\nfn some_func<T: Foo>(foo: T) {\n    foo.bar();\n}\n\nfn main() {\n    // we now call the method with the i32 type, which doesn't implement\n    // the Foo trait\n    some_func(5i32); // error: the trait bound `i32 : Foo` is not satisfied\n}\n```\n\nIn order to fix this error, verify that the type you're using does implement\nthe trait. Example:\n\n```\ntrait Foo {\n    fn bar(&self);\n}\n\n// we implement the trait on the i32 type\nimpl Foo for i32 {\n    fn bar(&self) {}\n}\n\nfn some_func<T: Foo>(foo: T) {\n    foo.bar(); // we can now use this method since i32 implements the\n               // Foo trait\n}\n\nfn main() {\n    some_func(5i32); // ok!\n}\n```\n\nOr in a generic context, an erroneous code example would look like:\n\n```compile_fail,E0277\nfn some_func<T>(foo: T) {\n    println!(\"{:?}\", foo); // error: the trait `core::fmt::Debug` is not\n                           //        implemented for the type `T`\n}\n\nfn main() {\n    // We now call the method with the i32 type,\n    // which *does* implement the Debug trait.\n    some_func(5i32);\n}\n```\n\nNote that the error here is in the definition of the generic function. Although\nwe only call it with a parameter that does implement `Debug`, the compiler\nstill rejects the function. It must work with all possible input types. In\norder to make this example compile, we need to restrict the generic type we're\naccepting:\n\n```\nuse std::fmt;\n\n// Restrict the input type to types that implement Debug.\nfn some_func<T: fmt::Debug>(foo: T) {\n    println!(\"{:?}\", foo);\n}\n\nfn main() {\n    // Calling the method is still fine, as i32 implements Debug.\n    some_func(5i32);\n\n    // This would fail to compile now:\n    // struct WithoutDebug;\n    // some_func(WithoutDebug);\n}\n```\n\nRust only looks at the signature of the called function, as such it must\nalready specify all requirements that will be used for every type parameter.\n"},"level":"error","spans":[{"file_name":"/Users/yugo/.cargo/git/checkouts/pairing-e1005e25456a4f82/868f527/src/bn256/fq6.rs","byte_start":8127,"byte_end":8130,"line_start":374,"line_end":374,"column_start":16,"column_end":19,"is_primary":true,"text":[{"text":"impl Field for Fq6 {","highlight_start":16,"highlight_end":19}],"label":"value of type `Fq6` cannot be made by multiplying all elements from a `std::iter::Iterator<Item=&'a Fq6>`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"the trait `for<'a> Product<&'a Fq6>` is not implemented for `Fq6`","code":null,"level":"help","spans":[],"children":[],"rendered":null},{"message":"the following other types implement trait `Product<A>`:\n  <Option<T> as Product<Option<U>>>\n  <Result<T, E> as Product<Result<U, E>>>\n  <Simd<f32, LANES> as Product<&'a Simd<f32, LANES>>>\n  <Simd<f32, LANES> as Product>\n  <Simd<f64, LANES> as Product<&'a Simd<f64, LANES>>>\n  <Simd<f64, LANES> as Product>\n  <Simd<i16, LANES> as Product<&'a Simd<i16, LANES>>>\n  <Simd<i16, LANES> as Product>\nand 70 others","code":null,"level":"help","spans":[],"children":[],"rendered":null},{"message":"required by a bound in `ff::Field`","code":null,"level":"note","spans":[{"file_name":"/Users/yugo/.cargo/registry/src/index.crates.io-6f17d22bba15001f/ff-0.13.0/src/lib.rs","byte_start":1508,"byte_end":1533,"line_start":63,"line_end":63,"column_start":7,"column_end":32,"is_primary":true,"text":[{"text":"    + for<'a> Product<&'a Self>","highlight_start":7,"highlight_end":32}],"label":"required by this bound in `Field`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0277]\u001b[0m\u001b[0m\u001b[1m: a value of type `Fq6` cannot be made by multiplying all elements of type `&'a Fq6` from an iterator\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0m/Users/yugo/.cargo/git/checkouts/pairing-e1005e25456a4f82/868f527/src/bn256/fq6.rs:374:16\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m374\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0mimpl Field for Fq6 {\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m               \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^^^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9mvalue of type `Fq6` cannot be made by multiplying all elements from a `std::iter::Iterator<Item=&'a Fq6>`\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mhelp\u001b[0m\u001b[0m: the trait `for<'a> Product<&'a Fq6>` is not implemented for `Fq6`\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mhelp\u001b[0m\u001b[0m: the following other types implement trait `Product<A>`:\u001b[0m\n\u001b[0m              <Option<T> as Product<Option<U>>>\u001b[0m\n\u001b[0m              <Result<T, E> as Product<Result<U, E>>>\u001b[0m\n\u001b[0m              <Simd<f32, LANES> as Product<&'a Simd<f32, LANES>>>\u001b[0m\n\u001b[0m              <Simd<f32, LANES> as Product>\u001b[0m\n\u001b[0m              <Simd<f64, LANES> as Product<&'a Simd<f64, LANES>>>\u001b[0m\n\u001b[0m              <Simd<f64, LANES> as Product>\u001b[0m\n\u001b[0m              <Simd<i16, LANES> as Product<&'a Simd<i16, LANES>>>\u001b[0m\n\u001b[0m              <Simd<i16, LANES> as Product>\u001b[0m\n\u001b[0m            and 70 others\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;10mnote\u001b[0m\u001b[0m: required by a bound in `ff::Field`\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0m/Users/yugo/.cargo/registry/src/index.crates.io-6f17d22bba15001f/ff-0.13.0/src/lib.rs:63:7\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m63\u001b[0m\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m    + for<'a> Product<&'a Self>\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m      \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;10m^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;10mrequired by this bound in `Field`\u001b[0m\n\n"}
{"message":"a value of type `Fq6` cannot be made by summing an iterator over elements of type `&'a Fq6`","code":{"code":"E0277","explanation":"You tried to use a type which doesn't implement some trait in a place which\nexpected that trait.\n\nErroneous code example:\n\n```compile_fail,E0277\n// here we declare the Foo trait with a bar method\ntrait Foo {\n    fn bar(&self);\n}\n\n// we now declare a function which takes an object implementing the Foo trait\nfn some_func<T: Foo>(foo: T) {\n    foo.bar();\n}\n\nfn main() {\n    // we now call the method with the i32 type, which doesn't implement\n    // the Foo trait\n    some_func(5i32); // error: the trait bound `i32 : Foo` is not satisfied\n}\n```\n\nIn order to fix this error, verify that the type you're using does implement\nthe trait. Example:\n\n```\ntrait Foo {\n    fn bar(&self);\n}\n\n// we implement the trait on the i32 type\nimpl Foo for i32 {\n    fn bar(&self) {}\n}\n\nfn some_func<T: Foo>(foo: T) {\n    foo.bar(); // we can now use this method since i32 implements the\n               // Foo trait\n}\n\nfn main() {\n    some_func(5i32); // ok!\n}\n```\n\nOr in a generic context, an erroneous code example would look like:\n\n```compile_fail,E0277\nfn some_func<T>(foo: T) {\n    println!(\"{:?}\", foo); // error: the trait `core::fmt::Debug` is not\n                           //        implemented for the type `T`\n}\n\nfn main() {\n    // We now call the method with the i32 type,\n    // which *does* implement the Debug trait.\n    some_func(5i32);\n}\n```\n\nNote that the error here is in the definition of the generic function. Although\nwe only call it with a parameter that does implement `Debug`, the compiler\nstill rejects the function. It must work with all possible input types. In\norder to make this example compile, we need to restrict the generic type we're\naccepting:\n\n```\nuse std::fmt;\n\n// Restrict the input type to types that implement Debug.\nfn some_func<T: fmt::Debug>(foo: T) {\n    println!(\"{:?}\", foo);\n}\n\nfn main() {\n    // Calling the method is still fine, as i32 implements Debug.\n    some_func(5i32);\n\n    // This would fail to compile now:\n    // struct WithoutDebug;\n    // some_func(WithoutDebug);\n}\n```\n\nRust only looks at the signature of the called function, as such it must\nalready specify all requirements that will be used for every type parameter.\n"},"level":"error","spans":[{"file_name":"/Users/yugo/.cargo/git/checkouts/pairing-e1005e25456a4f82/868f527/src/bn256/fq6.rs","byte_start":8127,"byte_end":8130,"line_start":374,"line_end":374,"column_start":16,"column_end":19,"is_primary":true,"text":[{"text":"impl Field for Fq6 {","highlight_start":16,"highlight_end":19}],"label":"value of type `Fq6` cannot be made by summing a `std::iter::Iterator<Item=&'a Fq6>`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"the trait `for<'a> Sum<&'a Fq6>` is not implemented for `Fq6`","code":null,"level":"help","spans":[],"children":[],"rendered":null},{"message":"the following other types implement trait `Sum<A>`:\n  <Duration as Sum<&'a Duration>>\n  <Duration as Sum>\n  <Gt as Sum<T>>\n  <Option<T> as Sum<Option<U>>>\n  <Result<T, E> as Sum<Result<U, E>>>\n  <Simd<f32, LANES> as Sum<&'a Simd<f32, LANES>>>\n  <Simd<f32, LANES> as Sum>\n  <Simd<f64, LANES> as Sum<&'a Simd<f64, LANES>>>\nand 76 others","code":null,"level":"help","spans":[],"children":[],"rendered":null},{"message":"required by a bound in `ff::Field`","code":null,"level":"note","spans":[{"file_name":"/Users/yugo/.cargo/registry/src/index.crates.io-6f17d22bba15001f/ff-0.13.0/src/lib.rs","byte_start":1480,"byte_end":1501,"line_start":62,"line_end":62,"column_start":7,"column_end":28,"is_primary":true,"text":[{"text":"    + for<'a> Sum<&'a Self>","highlight_start":7,"highlight_end":28}],"label":"required by this bound in `Field`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0277]\u001b[0m\u001b[0m\u001b[1m: a value of type `Fq6` cannot be made by summing an iterator over elements of type `&'a Fq6`\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0m/Users/yugo/.cargo/git/checkouts/pairing-e1005e25456a4f82/868f527/src/bn256/fq6.rs:374:16\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m374\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0mimpl Field for Fq6 {\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m               \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^^^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9mvalue of type `Fq6` cannot be made by summing a `std::iter::Iterator<Item=&'a Fq6>`\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mhelp\u001b[0m\u001b[0m: the trait `for<'a> Sum<&'a Fq6>` is not implemented for `Fq6`\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mhelp\u001b[0m\u001b[0m: the following other types implement trait `Sum<A>`:\u001b[0m\n\u001b[0m              <Duration as Sum<&'a Duration>>\u001b[0m\n\u001b[0m              <Duration as Sum>\u001b[0m\n\u001b[0m              <Gt as Sum<T>>\u001b[0m\n\u001b[0m              <Option<T> as Sum<Option<U>>>\u001b[0m\n\u001b[0m              <Result<T, E> as Sum<Result<U, E>>>\u001b[0m\n\u001b[0m              <Simd<f32, LANES> as Sum<&'a Simd<f32, LANES>>>\u001b[0m\n\u001b[0m              <Simd<f32, LANES> as Sum>\u001b[0m\n\u001b[0m              <Simd<f64, LANES> as Sum<&'a Simd<f64, LANES>>>\u001b[0m\n\u001b[0m            and 76 others\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;10mnote\u001b[0m\u001b[0m: required by a bound in `ff::Field`\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0m/Users/yugo/.cargo/registry/src/index.crates.io-6f17d22bba15001f/ff-0.13.0/src/lib.rs:62:7\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m62\u001b[0m\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m    + for<'a> Sum<&'a Self>\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m      \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;10m^^^^^^^^^^^^^^^^^^^^^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;10mrequired by this bound in `Field`\u001b[0m\n\n"}
{"message":"a value of type `Fq6` cannot be made by multiplying all elements of type `Fq6` from an iterator","code":{"code":"E0277","explanation":"You tried to use a type which doesn't implement some trait in a place which\nexpected that trait.\n\nErroneous code example:\n\n```compile_fail,E0277\n// here we declare the Foo trait with a bar method\ntrait Foo {\n    fn bar(&self);\n}\n\n// we now declare a function which takes an object implementing the Foo trait\nfn some_func<T: Foo>(foo: T) {\n    foo.bar();\n}\n\nfn main() {\n    // we now call the method with the i32 type, which doesn't implement\n    // the Foo trait\n    some_func(5i32); // error: the trait bound `i32 : Foo` is not satisfied\n}\n```\n\nIn order to fix this error, verify that the type you're using does implement\nthe trait. Example:\n\n```\ntrait Foo {\n    fn bar(&self);\n}\n\n// we implement the trait on the i32 type\nimpl Foo for i32 {\n    fn bar(&self) {}\n}\n\nfn some_func<T: Foo>(foo: T) {\n    foo.bar(); // we can now use this method since i32 implements the\n               // Foo trait\n}\n\nfn main() {\n    some_func(5i32); // ok!\n}\n```\n\nOr in a generic context, an erroneous code example would look like:\n\n```compile_fail,E0277\nfn some_func<T>(foo: T) {\n    println!(\"{:?}\", foo); // error: the trait `core::fmt::Debug` is not\n                           //        implemented for the type `T`\n}\n\nfn main() {\n    // We now call the method with the i32 type,\n    // which *does* implement the Debug trait.\n    some_func(5i32);\n}\n```\n\nNote that the error here is in the definition of the generic function. Although\nwe only call it with a parameter that does implement `Debug`, the compiler\nstill rejects the function. It must work with all possible input types. In\norder to make this example compile, we need to restrict the generic type we're\naccepting:\n\n```\nuse std::fmt;\n\n// Restrict the input type to types that implement Debug.\nfn some_func<T: fmt::Debug>(foo: T) {\n    println!(\"{:?}\", foo);\n}\n\nfn main() {\n    // Calling the method is still fine, as i32 implements Debug.\n    some_func(5i32);\n\n    // This would fail to compile now:\n    // struct WithoutDebug;\n    // some_func(WithoutDebug);\n}\n```\n\nRust only looks at the signature of the called function, as such it must\nalready specify all requirements that will be used for every type parameter.\n"},"level":"error","spans":[{"file_name":"/Users/yugo/.cargo/git/checkouts/pairing-e1005e25456a4f82/868f527/src/bn256/fq6.rs","byte_start":8127,"byte_end":8130,"line_start":374,"line_end":374,"column_start":16,"column_end":19,"is_primary":true,"text":[{"text":"impl Field for Fq6 {","highlight_start":16,"highlight_end":19}],"label":"value of type `Fq6` cannot be made by multiplying all elements from a `std::iter::Iterator<Item=Fq6>`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"the trait `Product` is not implemented for `Fq6`","code":null,"level":"help","spans":[],"children":[],"rendered":null},{"message":"the following other types implement trait `Product<A>`:\n  <Option<T> as Product<Option<U>>>\n  <Result<T, E> as Product<Result<U, E>>>\n  <Simd<f32, LANES> as Product<&'a Simd<f32, LANES>>>\n  <Simd<f32, LANES> as Product>\n  <Simd<f64, LANES> as Product<&'a Simd<f64, LANES>>>\n  <Simd<f64, LANES> as Product>\n  <Simd<i16, LANES> as Product<&'a Simd<i16, LANES>>>\n  <Simd<i16, LANES> as Product>\nand 70 others","code":null,"level":"help","spans":[],"children":[],"rendered":null},{"message":"required by a bound in `ff::Field`","code":null,"level":"note","spans":[{"file_name":"/Users/yugo/.cargo/registry/src/index.crates.io-6f17d22bba15001f/ff-0.13.0/src/lib.rs","byte_start":1337,"byte_end":1344,"line_start":58,"line_end":58,"column_start":7,"column_end":14,"is_primary":true,"text":[{"text":"    + Product","highlight_start":7,"highlight_end":14}],"label":"required by this bound in `Field`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0277]\u001b[0m\u001b[0m\u001b[1m: a value of type `Fq6` cannot be made by multiplying all elements of type `Fq6` from an iterator\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0m/Users/yugo/.cargo/git/checkouts/pairing-e1005e25456a4f82/868f527/src/bn256/fq6.rs:374:16\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m374\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0mimpl Field for Fq6 {\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m               \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^^^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9mvalue of type `Fq6` cannot be made by multiplying all elements from a `std::iter::Iterator<Item=Fq6>`\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mhelp\u001b[0m\u001b[0m: the trait `Product` is not implemented for `Fq6`\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mhelp\u001b[0m\u001b[0m: the following other types implement trait `Product<A>`:\u001b[0m\n\u001b[0m              <Option<T> as Product<Option<U>>>\u001b[0m\n\u001b[0m              <Result<T, E> as Product<Result<U, E>>>\u001b[0m\n\u001b[0m              <Simd<f32, LANES> as Product<&'a Simd<f32, LANES>>>\u001b[0m\n\u001b[0m              <Simd<f32, LANES> as Product>\u001b[0m\n\u001b[0m              <Simd<f64, LANES> as Product<&'a Simd<f64, LANES>>>\u001b[0m\n\u001b[0m              <Simd<f64, LANES> as Product>\u001b[0m\n\u001b[0m              <Simd<i16, LANES> as Product<&'a Simd<i16, LANES>>>\u001b[0m\n\u001b[0m              <Simd<i16, LANES> as Product>\u001b[0m\n\u001b[0m            and 70 others\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;10mnote\u001b[0m\u001b[0m: required by a bound in `ff::Field`\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0m/Users/yugo/.cargo/registry/src/index.crates.io-6f17d22bba15001f/ff-0.13.0/src/lib.rs:58:7\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m58\u001b[0m\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m    + Product\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m      \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;10m^^^^^^^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;10mrequired by this bound in `Field`\u001b[0m\n\n"}
{"message":"a value of type `Fq6` cannot be made by summing an iterator over elements of type `Fq6`","code":{"code":"E0277","explanation":"You tried to use a type which doesn't implement some trait in a place which\nexpected that trait.\n\nErroneous code example:\n\n```compile_fail,E0277\n// here we declare the Foo trait with a bar method\ntrait Foo {\n    fn bar(&self);\n}\n\n// we now declare a function which takes an object implementing the Foo trait\nfn some_func<T: Foo>(foo: T) {\n    foo.bar();\n}\n\nfn main() {\n    // we now call the method with the i32 type, which doesn't implement\n    // the Foo trait\n    some_func(5i32); // error: the trait bound `i32 : Foo` is not satisfied\n}\n```\n\nIn order to fix this error, verify that the type you're using does implement\nthe trait. Example:\n\n```\ntrait Foo {\n    fn bar(&self);\n}\n\n// we implement the trait on the i32 type\nimpl Foo for i32 {\n    fn bar(&self) {}\n}\n\nfn some_func<T: Foo>(foo: T) {\n    foo.bar(); // we can now use this method since i32 implements the\n               // Foo trait\n}\n\nfn main() {\n    some_func(5i32); // ok!\n}\n```\n\nOr in a generic context, an erroneous code example would look like:\n\n```compile_fail,E0277\nfn some_func<T>(foo: T) {\n    println!(\"{:?}\", foo); // error: the trait `core::fmt::Debug` is not\n                           //        implemented for the type `T`\n}\n\nfn main() {\n    // We now call the method with the i32 type,\n    // which *does* implement the Debug trait.\n    some_func(5i32);\n}\n```\n\nNote that the error here is in the definition of the generic function. Although\nwe only call it with a parameter that does implement `Debug`, the compiler\nstill rejects the function. It must work with all possible input types. In\norder to make this example compile, we need to restrict the generic type we're\naccepting:\n\n```\nuse std::fmt;\n\n// Restrict the input type to types that implement Debug.\nfn some_func<T: fmt::Debug>(foo: T) {\n    println!(\"{:?}\", foo);\n}\n\nfn main() {\n    // Calling the method is still fine, as i32 implements Debug.\n    some_func(5i32);\n\n    // This would fail to compile now:\n    // struct WithoutDebug;\n    // some_func(WithoutDebug);\n}\n```\n\nRust only looks at the signature of the called function, as such it must\nalready specify all requirements that will be used for every type parameter.\n"},"level":"error","spans":[{"file_name":"/Users/yugo/.cargo/git/checkouts/pairing-e1005e25456a4f82/868f527/src/bn256/fq6.rs","byte_start":8127,"byte_end":8130,"line_start":374,"line_end":374,"column_start":16,"column_end":19,"is_primary":true,"text":[{"text":"impl Field for Fq6 {","highlight_start":16,"highlight_end":19}],"label":"value of type `Fq6` cannot be made by summing a `std::iter::Iterator<Item=Fq6>`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"the trait `Sum` is not implemented for `Fq6`","code":null,"level":"help","spans":[],"children":[],"rendered":null},{"message":"the following other types implement trait `Sum<A>`:\n  <Duration as Sum<&'a Duration>>\n  <Duration as Sum>\n  <Gt as Sum<T>>\n  <Option<T> as Sum<Option<U>>>\n  <Result<T, E> as Sum<Result<U, E>>>\n  <Simd<f32, LANES> as Sum<&'a Simd<f32, LANES>>>\n  <Simd<f32, LANES> as Sum>\n  <Simd<f64, LANES> as Sum<&'a Simd<f64, LANES>>>\nand 76 others","code":null,"level":"help","spans":[],"children":[],"rendered":null},{"message":"required by a bound in `ff::Field`","code":null,"level":"note","spans":[{"file_name":"/Users/yugo/.cargo/registry/src/index.crates.io-6f17d22bba15001f/ff-0.13.0/src/lib.rs","byte_start":1327,"byte_end":1330,"line_start":57,"line_end":57,"column_start":7,"column_end":10,"is_primary":true,"text":[{"text":"    + Sum","highlight_start":7,"highlight_end":10}],"label":"required by this bound in `Field`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0277]\u001b[0m\u001b[0m\u001b[1m: a value of type `Fq6` cannot be made by summing an iterator over elements of type `Fq6`\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0m/Users/yugo/.cargo/git/checkouts/pairing-e1005e25456a4f82/868f527/src/bn256/fq6.rs:374:16\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m374\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0mimpl Field for Fq6 {\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m               \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^^^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9mvalue of type `Fq6` cannot be made by summing a `std::iter::Iterator<Item=Fq6>`\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mhelp\u001b[0m\u001b[0m: the trait `Sum` is not implemented for `Fq6`\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mhelp\u001b[0m\u001b[0m: the following other types implement trait `Sum<A>`:\u001b[0m\n\u001b[0m              <Duration as Sum<&'a Duration>>\u001b[0m\n\u001b[0m              <Duration as Sum>\u001b[0m\n\u001b[0m              <Gt as Sum<T>>\u001b[0m\n\u001b[0m              <Option<T> as Sum<Option<U>>>\u001b[0m\n\u001b[0m              <Result<T, E> as Sum<Result<U, E>>>\u001b[0m\n\u001b[0m              <Simd<f32, LANES> as Sum<&'a Simd<f32, LANES>>>\u001b[0m\n\u001b[0m              <Simd<f32, LANES> as Sum>\u001b[0m\n\u001b[0m              <Simd<f64, LANES> as Sum<&'a Simd<f64, LANES>>>\u001b[0m\n\u001b[0m            and 76 others\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;10mnote\u001b[0m\u001b[0m: required by a bound in `ff::Field`\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0m/Users/yugo/.cargo/registry/src/index.crates.io-6f17d22bba15001f/ff-0.13.0/src/lib.rs:57:7\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m57\u001b[0m\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m    + Sum\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m      \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;10m^^^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;10mrequired by this bound in `Field`\u001b[0m\n\n"}
{"message":"a value of type `fr::Fr` cannot be made by multiplying all elements of type `&'a fr::Fr` from an iterator","code":{"code":"E0277","explanation":"You tried to use a type which doesn't implement some trait in a place which\nexpected that trait.\n\nErroneous code example:\n\n```compile_fail,E0277\n// here we declare the Foo trait with a bar method\ntrait Foo {\n    fn bar(&self);\n}\n\n// we now declare a function which takes an object implementing the Foo trait\nfn some_func<T: Foo>(foo: T) {\n    foo.bar();\n}\n\nfn main() {\n    // we now call the method with the i32 type, which doesn't implement\n    // the Foo trait\n    some_func(5i32); // error: the trait bound `i32 : Foo` is not satisfied\n}\n```\n\nIn order to fix this error, verify that the type you're using does implement\nthe trait. Example:\n\n```\ntrait Foo {\n    fn bar(&self);\n}\n\n// we implement the trait on the i32 type\nimpl Foo for i32 {\n    fn bar(&self) {}\n}\n\nfn some_func<T: Foo>(foo: T) {\n    foo.bar(); // we can now use this method since i32 implements the\n               // Foo trait\n}\n\nfn main() {\n    some_func(5i32); // ok!\n}\n```\n\nOr in a generic context, an erroneous code example would look like:\n\n```compile_fail,E0277\nfn some_func<T>(foo: T) {\n    println!(\"{:?}\", foo); // error: the trait `core::fmt::Debug` is not\n                           //        implemented for the type `T`\n}\n\nfn main() {\n    // We now call the method with the i32 type,\n    // which *does* implement the Debug trait.\n    some_func(5i32);\n}\n```\n\nNote that the error here is in the definition of the generic function. Although\nwe only call it with a parameter that does implement `Debug`, the compiler\nstill rejects the function. It must work with all possible input types. In\norder to make this example compile, we need to restrict the generic type we're\naccepting:\n\n```\nuse std::fmt;\n\n// Restrict the input type to types that implement Debug.\nfn some_func<T: fmt::Debug>(foo: T) {\n    println!(\"{:?}\", foo);\n}\n\nfn main() {\n    // Calling the method is still fine, as i32 implements Debug.\n    some_func(5i32);\n\n    // This would fail to compile now:\n    // struct WithoutDebug;\n    // some_func(WithoutDebug);\n}\n```\n\nRust only looks at the signature of the called function, as such it must\nalready specify all requirements that will be used for every type parameter.\n"},"level":"error","spans":[{"file_name":"/Users/yugo/.cargo/git/checkouts/pairing-e1005e25456a4f82/868f527/src/bn256/common.rs","byte_start":17937,"byte_end":17943,"line_start":439,"line_end":439,"column_start":26,"column_end":32,"is_primary":true,"text":[{"text":"        impl BaseExt for $field {","highlight_start":26,"highlight_end":32}],"label":"value of type `fr::Fr` cannot be made by multiplying all elements from a `std::iter::Iterator<Item=&'a fr::Fr>`","suggested_replacement":null,"suggestion_applicability":null,"expansion":{"span":{"file_name":"/Users/yugo/.cargo/git/checkouts/pairing-e1005e25456a4f82/868f527/src/bn256/fr.rs","byte_start":2493,"byte_end":2616,"line_start":101,"line_end":110,"column_start":1,"column_end":2,"is_primary":false,"text":[{"text":"common_field!(","highlight_start":1,"highlight_end":15},{"text":"    Fr,","highlight_start":1,"highlight_end":8},{"text":"    MODULUS,","highlight_start":1,"highlight_end":13},{"text":"    INV,","highlight_start":1,"highlight_end":9},{"text":"    BASEEXT_MODULUS,","highlight_start":1,"highlight_end":21},{"text":"    TWO_INV,","highlight_start":1,"highlight_end":13},{"text":"    ROOT_OF_UNITY_INV,","highlight_start":1,"highlight_end":23},{"text":"    DELTA,","highlight_start":1,"highlight_end":11},{"text":"    ZETA","highlight_start":1,"highlight_end":9},{"text":");","highlight_start":1,"highlight_end":2}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null},"macro_decl_name":"common_field!","def_site_span":{"file_name":"/Users/yugo/.cargo/git/checkouts/pairing-e1005e25456a4f82/868f527/src/bn256/common.rs","byte_start":0,"byte_end":25,"line_start":1,"line_end":1,"column_start":1,"column_end":26,"is_primary":false,"text":[{"text":"macro_rules! common_field {","highlight_start":1,"highlight_end":26}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}}}],"children":[{"message":"the trait `for<'a> Product<&'a fr::Fr>` is not implemented for `fr::Fr`","code":null,"level":"help","spans":[],"children":[],"rendered":null},{"message":"the following other types implement trait `Product<A>`:\n  <Option<T> as Product<Option<U>>>\n  <Result<T, E> as Product<Result<U, E>>>\n  <Simd<f32, LANES> as Product<&'a Simd<f32, LANES>>>\n  <Simd<f32, LANES> as Product>\n  <Simd<f64, LANES> as Product<&'a Simd<f64, LANES>>>\n  <Simd<f64, LANES> as Product>\n  <Simd<i16, LANES> as Product<&'a Simd<i16, LANES>>>\n  <Simd<i16, LANES> as Product>\nand 70 others","code":null,"level":"help","spans":[],"children":[],"rendered":null},{"message":"required for `fr::Fr` to implement `ff::Field`","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"required by a bound in `fields::BaseExt`","code":null,"level":"note","spans":[{"file_name":"/Users/yugo/.cargo/git/checkouts/pairing-e1005e25456a4f82/868f527/src/arithmetic/fields.rs","byte_start":422,"byte_end":431,"line_start":15,"line_end":15,"column_start":20,"column_end":29,"is_primary":true,"text":[{"text":"pub trait BaseExt: ff::Field + Ord + ConstantTimeEq {","highlight_start":20,"highlight_end":29}],"label":"required by this bound in `BaseExt`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0277]\u001b[0m\u001b[0m\u001b[1m: a value of type `fr::Fr` cannot be made by multiplying all elements of type `&'a fr::Fr` from an iterator\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0m/Users/yugo/.cargo/git/checkouts/pairing-e1005e25456a4f82/868f527/src/bn256/common.rs:439:26\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m439\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m   \u001b[0m\u001b[0m        impl BaseExt for $field {\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m                           \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^^^^^^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9mvalue of type `fr::Fr` cannot be made by multiplying all elements from a `std::iter::Iterator<Item=&'a fr::Fr>`\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m::: \u001b[0m\u001b[0m/Users/yugo/.cargo/git/checkouts/pairing-e1005e25456a4f82/868f527/src/bn256/fr.rs:101:1\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m101\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m/\u001b[0m\u001b[0m \u001b[0m\u001b[0mcommon_field!(\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m102\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m    Fr,\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m103\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m    MODULUS,\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m104\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m    INV,\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m...\u001b[0m\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m109\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m    ZETA\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m110\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m);\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|_-\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12min this macro invocation\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mhelp\u001b[0m\u001b[0m: the trait `for<'a> Product<&'a fr::Fr>` is not implemented for `fr::Fr`\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mhelp\u001b[0m\u001b[0m: the following other types implement trait `Product<A>`:\u001b[0m\n\u001b[0m              <Option<T> as Product<Option<U>>>\u001b[0m\n\u001b[0m              <Result<T, E> as Product<Result<U, E>>>\u001b[0m\n\u001b[0m              <Simd<f32, LANES> as Product<&'a Simd<f32, LANES>>>\u001b[0m\n\u001b[0m              <Simd<f32, LANES> as Product>\u001b[0m\n\u001b[0m              <Simd<f64, LANES> as Product<&'a Simd<f64, LANES>>>\u001b[0m\n\u001b[0m              <Simd<f64, LANES> as Product>\u001b[0m\n\u001b[0m              <Simd<i16, LANES> as Product<&'a Simd<i16, LANES>>>\u001b[0m\n\u001b[0m              <Simd<i16, LANES> as Product>\u001b[0m\n\u001b[0m            and 70 others\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mnote\u001b[0m\u001b[0m: required for `fr::Fr` to implement `ff::Field`\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;10mnote\u001b[0m\u001b[0m: required by a bound in `fields::BaseExt`\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0m/Users/yugo/.cargo/git/checkouts/pairing-e1005e25456a4f82/868f527/src/arithmetic/fields.rs:15:20\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m15\u001b[0m\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0mpub trait BaseExt: ff::Field + Ord + ConstantTimeEq {\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m                   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;10m^^^^^^^^^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;10mrequired by this bound in `BaseExt`\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mnote\u001b[0m\u001b[0m: this error originates in the macro `common_field` (in Nightly builds, run with -Z macro-backtrace for more info)\u001b[0m\n\n"}
{"message":"a value of type `fr::Fr` cannot be made by summing an iterator over elements of type `&'a fr::Fr`","code":{"code":"E0277","explanation":"You tried to use a type which doesn't implement some trait in a place which\nexpected that trait.\n\nErroneous code example:\n\n```compile_fail,E0277\n// here we declare the Foo trait with a bar method\ntrait Foo {\n    fn bar(&self);\n}\n\n// we now declare a function which takes an object implementing the Foo trait\nfn some_func<T: Foo>(foo: T) {\n    foo.bar();\n}\n\nfn main() {\n    // we now call the method with the i32 type, which doesn't implement\n    // the Foo trait\n    some_func(5i32); // error: the trait bound `i32 : Foo` is not satisfied\n}\n```\n\nIn order to fix this error, verify that the type you're using does implement\nthe trait. Example:\n\n```\ntrait Foo {\n    fn bar(&self);\n}\n\n// we implement the trait on the i32 type\nimpl Foo for i32 {\n    fn bar(&self) {}\n}\n\nfn some_func<T: Foo>(foo: T) {\n    foo.bar(); // we can now use this method since i32 implements the\n               // Foo trait\n}\n\nfn main() {\n    some_func(5i32); // ok!\n}\n```\n\nOr in a generic context, an erroneous code example would look like:\n\n```compile_fail,E0277\nfn some_func<T>(foo: T) {\n    println!(\"{:?}\", foo); // error: the trait `core::fmt::Debug` is not\n                           //        implemented for the type `T`\n}\n\nfn main() {\n    // We now call the method with the i32 type,\n    // which *does* implement the Debug trait.\n    some_func(5i32);\n}\n```\n\nNote that the error here is in the definition of the generic function. Although\nwe only call it with a parameter that does implement `Debug`, the compiler\nstill rejects the function. It must work with all possible input types. In\norder to make this example compile, we need to restrict the generic type we're\naccepting:\n\n```\nuse std::fmt;\n\n// Restrict the input type to types that implement Debug.\nfn some_func<T: fmt::Debug>(foo: T) {\n    println!(\"{:?}\", foo);\n}\n\nfn main() {\n    // Calling the method is still fine, as i32 implements Debug.\n    some_func(5i32);\n\n    // This would fail to compile now:\n    // struct WithoutDebug;\n    // some_func(WithoutDebug);\n}\n```\n\nRust only looks at the signature of the called function, as such it must\nalready specify all requirements that will be used for every type parameter.\n"},"level":"error","spans":[{"file_name":"/Users/yugo/.cargo/git/checkouts/pairing-e1005e25456a4f82/868f527/src/bn256/common.rs","byte_start":17937,"byte_end":17943,"line_start":439,"line_end":439,"column_start":26,"column_end":32,"is_primary":true,"text":[{"text":"        impl BaseExt for $field {","highlight_start":26,"highlight_end":32}],"label":"value of type `fr::Fr` cannot be made by summing a `std::iter::Iterator<Item=&'a fr::Fr>`","suggested_replacement":null,"suggestion_applicability":null,"expansion":{"span":{"file_name":"/Users/yugo/.cargo/git/checkouts/pairing-e1005e25456a4f82/868f527/src/bn256/fr.rs","byte_start":2493,"byte_end":2616,"line_start":101,"line_end":110,"column_start":1,"column_end":2,"is_primary":false,"text":[{"text":"common_field!(","highlight_start":1,"highlight_end":15},{"text":"    Fr,","highlight_start":1,"highlight_end":8},{"text":"    MODULUS,","highlight_start":1,"highlight_end":13},{"text":"    INV,","highlight_start":1,"highlight_end":9},{"text":"    BASEEXT_MODULUS,","highlight_start":1,"highlight_end":21},{"text":"    TWO_INV,","highlight_start":1,"highlight_end":13},{"text":"    ROOT_OF_UNITY_INV,","highlight_start":1,"highlight_end":23},{"text":"    DELTA,","highlight_start":1,"highlight_end":11},{"text":"    ZETA","highlight_start":1,"highlight_end":9},{"text":");","highlight_start":1,"highlight_end":2}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null},"macro_decl_name":"common_field!","def_site_span":{"file_name":"/Users/yugo/.cargo/git/checkouts/pairing-e1005e25456a4f82/868f527/src/bn256/common.rs","byte_start":0,"byte_end":25,"line_start":1,"line_end":1,"column_start":1,"column_end":26,"is_primary":false,"text":[{"text":"macro_rules! common_field {","highlight_start":1,"highlight_end":26}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}}}],"children":[{"message":"the trait `for<'a> Sum<&'a fr::Fr>` is not implemented for `fr::Fr`","code":null,"level":"help","spans":[],"children":[],"rendered":null},{"message":"the following other types implement trait `Sum<A>`:\n  <Duration as Sum<&'a Duration>>\n  <Duration as Sum>\n  <Gt as Sum<T>>\n  <Option<T> as Sum<Option<U>>>\n  <Result<T, E> as Sum<Result<U, E>>>\n  <Simd<f32, LANES> as Sum<&'a Simd<f32, LANES>>>\n  <Simd<f32, LANES> as Sum>\n  <Simd<f64, LANES> as Sum<&'a Simd<f64, LANES>>>\nand 76 others","code":null,"level":"help","spans":[],"children":[],"rendered":null},{"message":"required for `fr::Fr` to implement `ff::Field`","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"required by a bound in `fields::BaseExt`","code":null,"level":"note","spans":[{"file_name":"/Users/yugo/.cargo/git/checkouts/pairing-e1005e25456a4f82/868f527/src/arithmetic/fields.rs","byte_start":422,"byte_end":431,"line_start":15,"line_end":15,"column_start":20,"column_end":29,"is_primary":true,"text":[{"text":"pub trait BaseExt: ff::Field + Ord + ConstantTimeEq {","highlight_start":20,"highlight_end":29}],"label":"required by this bound in `BaseExt`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0277]\u001b[0m\u001b[0m\u001b[1m: a value of type `fr::Fr` cannot be made by summing an iterator over elements of type `&'a fr::Fr`\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0m/Users/yugo/.cargo/git/checkouts/pairing-e1005e25456a4f82/868f527/src/bn256/common.rs:439:26\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m439\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m   \u001b[0m\u001b[0m        impl BaseExt for $field {\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m                           \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^^^^^^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9mvalue of type `fr::Fr` cannot be made by summing a `std::iter::Iterator<Item=&'a fr::Fr>`\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m::: \u001b[0m\u001b[0m/Users/yugo/.cargo/git/checkouts/pairing-e1005e25456a4f82/868f527/src/bn256/fr.rs:101:1\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m101\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m/\u001b[0m\u001b[0m \u001b[0m\u001b[0mcommon_field!(\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m102\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m    Fr,\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m103\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m    MODULUS,\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m104\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m    INV,\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m...\u001b[0m\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m109\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m    ZETA\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m110\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m);\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|_-\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12min this macro invocation\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mhelp\u001b[0m\u001b[0m: the trait `for<'a> Sum<&'a fr::Fr>` is not implemented for `fr::Fr`\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mhelp\u001b[0m\u001b[0m: the following other types implement trait `Sum<A>`:\u001b[0m\n\u001b[0m              <Duration as Sum<&'a Duration>>\u001b[0m\n\u001b[0m              <Duration as Sum>\u001b[0m\n\u001b[0m              <Gt as Sum<T>>\u001b[0m\n\u001b[0m              <Option<T> as Sum<Option<U>>>\u001b[0m\n\u001b[0m              <Result<T, E> as Sum<Result<U, E>>>\u001b[0m\n\u001b[0m              <Simd<f32, LANES> as Sum<&'a Simd<f32, LANES>>>\u001b[0m\n\u001b[0m              <Simd<f32, LANES> as Sum>\u001b[0m\n\u001b[0m              <Simd<f64, LANES> as Sum<&'a Simd<f64, LANES>>>\u001b[0m\n\u001b[0m            and 76 others\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mnote\u001b[0m\u001b[0m: required for `fr::Fr` to implement `ff::Field`\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;10mnote\u001b[0m\u001b[0m: required by a bound in `fields::BaseExt`\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0m/Users/yugo/.cargo/git/checkouts/pairing-e1005e25456a4f82/868f527/src/arithmetic/fields.rs:15:20\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m15\u001b[0m\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0mpub trait BaseExt: ff::Field + Ord + ConstantTimeEq {\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m                   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;10m^^^^^^^^^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;10mrequired by this bound in `BaseExt`\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mnote\u001b[0m\u001b[0m: this error originates in the macro `common_field` (in Nightly builds, run with -Z macro-backtrace for more info)\u001b[0m\n\n"}
{"message":"a value of type `fr::Fr` cannot be made by multiplying all elements of type `fr::Fr` from an iterator","code":{"code":"E0277","explanation":"You tried to use a type which doesn't implement some trait in a place which\nexpected that trait.\n\nErroneous code example:\n\n```compile_fail,E0277\n// here we declare the Foo trait with a bar method\ntrait Foo {\n    fn bar(&self);\n}\n\n// we now declare a function which takes an object implementing the Foo trait\nfn some_func<T: Foo>(foo: T) {\n    foo.bar();\n}\n\nfn main() {\n    // we now call the method with the i32 type, which doesn't implement\n    // the Foo trait\n    some_func(5i32); // error: the trait bound `i32 : Foo` is not satisfied\n}\n```\n\nIn order to fix this error, verify that the type you're using does implement\nthe trait. Example:\n\n```\ntrait Foo {\n    fn bar(&self);\n}\n\n// we implement the trait on the i32 type\nimpl Foo for i32 {\n    fn bar(&self) {}\n}\n\nfn some_func<T: Foo>(foo: T) {\n    foo.bar(); // we can now use this method since i32 implements the\n               // Foo trait\n}\n\nfn main() {\n    some_func(5i32); // ok!\n}\n```\n\nOr in a generic context, an erroneous code example would look like:\n\n```compile_fail,E0277\nfn some_func<T>(foo: T) {\n    println!(\"{:?}\", foo); // error: the trait `core::fmt::Debug` is not\n                           //        implemented for the type `T`\n}\n\nfn main() {\n    // We now call the method with the i32 type,\n    // which *does* implement the Debug trait.\n    some_func(5i32);\n}\n```\n\nNote that the error here is in the definition of the generic function. Although\nwe only call it with a parameter that does implement `Debug`, the compiler\nstill rejects the function. It must work with all possible input types. In\norder to make this example compile, we need to restrict the generic type we're\naccepting:\n\n```\nuse std::fmt;\n\n// Restrict the input type to types that implement Debug.\nfn some_func<T: fmt::Debug>(foo: T) {\n    println!(\"{:?}\", foo);\n}\n\nfn main() {\n    // Calling the method is still fine, as i32 implements Debug.\n    some_func(5i32);\n\n    // This would fail to compile now:\n    // struct WithoutDebug;\n    // some_func(WithoutDebug);\n}\n```\n\nRust only looks at the signature of the called function, as such it must\nalready specify all requirements that will be used for every type parameter.\n"},"level":"error","spans":[{"file_name":"/Users/yugo/.cargo/git/checkouts/pairing-e1005e25456a4f82/868f527/src/bn256/common.rs","byte_start":17937,"byte_end":17943,"line_start":439,"line_end":439,"column_start":26,"column_end":32,"is_primary":true,"text":[{"text":"        impl BaseExt for $field {","highlight_start":26,"highlight_end":32}],"label":"value of type `fr::Fr` cannot be made by multiplying all elements from a `std::iter::Iterator<Item=fr::Fr>`","suggested_replacement":null,"suggestion_applicability":null,"expansion":{"span":{"file_name":"/Users/yugo/.cargo/git/checkouts/pairing-e1005e25456a4f82/868f527/src/bn256/fr.rs","byte_start":2493,"byte_end":2616,"line_start":101,"line_end":110,"column_start":1,"column_end":2,"is_primary":false,"text":[{"text":"common_field!(","highlight_start":1,"highlight_end":15},{"text":"    Fr,","highlight_start":1,"highlight_end":8},{"text":"    MODULUS,","highlight_start":1,"highlight_end":13},{"text":"    INV,","highlight_start":1,"highlight_end":9},{"text":"    BASEEXT_MODULUS,","highlight_start":1,"highlight_end":21},{"text":"    TWO_INV,","highlight_start":1,"highlight_end":13},{"text":"    ROOT_OF_UNITY_INV,","highlight_start":1,"highlight_end":23},{"text":"    DELTA,","highlight_start":1,"highlight_end":11},{"text":"    ZETA","highlight_start":1,"highlight_end":9},{"text":");","highlight_start":1,"highlight_end":2}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null},"macro_decl_name":"common_field!","def_site_span":{"file_name":"/Users/yugo/.cargo/git/checkouts/pairing-e1005e25456a4f82/868f527/src/bn256/common.rs","byte_start":0,"byte_end":25,"line_start":1,"line_end":1,"column_start":1,"column_end":26,"is_primary":false,"text":[{"text":"macro_rules! common_field {","highlight_start":1,"highlight_end":26}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}}}],"children":[{"message":"the trait `Product` is not implemented for `fr::Fr`","code":null,"level":"help","spans":[],"children":[],"rendered":null},{"message":"the following other types implement trait `Product<A>`:\n  <Option<T> as Product<Option<U>>>\n  <Result<T, E> as Product<Result<U, E>>>\n  <Simd<f32, LANES> as Product<&'a Simd<f32, LANES>>>\n  <Simd<f32, LANES> as Product>\n  <Simd<f64, LANES> as Product<&'a Simd<f64, LANES>>>\n  <Simd<f64, LANES> as Product>\n  <Simd<i16, LANES> as Product<&'a Simd<i16, LANES>>>\n  <Simd<i16, LANES> as Product>\nand 70 others","code":null,"level":"help","spans":[],"children":[],"rendered":null},{"message":"required for `fr::Fr` to implement `ff::Field`","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"required by a bound in `fields::BaseExt`","code":null,"level":"note","spans":[{"file_name":"/Users/yugo/.cargo/git/checkouts/pairing-e1005e25456a4f82/868f527/src/arithmetic/fields.rs","byte_start":422,"byte_end":431,"line_start":15,"line_end":15,"column_start":20,"column_end":29,"is_primary":true,"text":[{"text":"pub trait BaseExt: ff::Field + Ord + ConstantTimeEq {","highlight_start":20,"highlight_end":29}],"label":"required by this bound in `BaseExt`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0277]\u001b[0m\u001b[0m\u001b[1m: a value of type `fr::Fr` cannot be made by multiplying all elements of type `fr::Fr` from an iterator\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0m/Users/yugo/.cargo/git/checkouts/pairing-e1005e25456a4f82/868f527/src/bn256/common.rs:439:26\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m439\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m   \u001b[0m\u001b[0m        impl BaseExt for $field {\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m                           \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^^^^^^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9mvalue of type `fr::Fr` cannot be made by multiplying all elements from a `std::iter::Iterator<Item=fr::Fr>`\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m::: \u001b[0m\u001b[0m/Users/yugo/.cargo/git/checkouts/pairing-e1005e25456a4f82/868f527/src/bn256/fr.rs:101:1\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m101\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m/\u001b[0m\u001b[0m \u001b[0m\u001b[0mcommon_field!(\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m102\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m    Fr,\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m103\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m    MODULUS,\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m104\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m    INV,\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m...\u001b[0m\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m109\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m    ZETA\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m110\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m);\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|_-\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12min this macro invocation\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mhelp\u001b[0m\u001b[0m: the trait `Product` is not implemented for `fr::Fr`\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mhelp\u001b[0m\u001b[0m: the following other types implement trait `Product<A>`:\u001b[0m\n\u001b[0m              <Option<T> as Product<Option<U>>>\u001b[0m\n\u001b[0m              <Result<T, E> as Product<Result<U, E>>>\u001b[0m\n\u001b[0m              <Simd<f32, LANES> as Product<&'a Simd<f32, LANES>>>\u001b[0m\n\u001b[0m              <Simd<f32, LANES> as Product>\u001b[0m\n\u001b[0m              <Simd<f64, LANES> as Product<&'a Simd<f64, LANES>>>\u001b[0m\n\u001b[0m              <Simd<f64, LANES> as Product>\u001b[0m\n\u001b[0m              <Simd<i16, LANES> as Product<&'a Simd<i16, LANES>>>\u001b[0m\n\u001b[0m              <Simd<i16, LANES> as Product>\u001b[0m\n\u001b[0m            and 70 others\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mnote\u001b[0m\u001b[0m: required for `fr::Fr` to implement `ff::Field`\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;10mnote\u001b[0m\u001b[0m: required by a bound in `fields::BaseExt`\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0m/Users/yugo/.cargo/git/checkouts/pairing-e1005e25456a4f82/868f527/src/arithmetic/fields.rs:15:20\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m15\u001b[0m\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0mpub trait BaseExt: ff::Field + Ord + ConstantTimeEq {\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m                   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;10m^^^^^^^^^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;10mrequired by this bound in `BaseExt`\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mnote\u001b[0m\u001b[0m: this error originates in the macro `common_field` (in Nightly builds, run with -Z macro-backtrace for more info)\u001b[0m\n\n"}
{"message":"a value of type `fr::Fr` cannot be made by summing an iterator over elements of type `fr::Fr`","code":{"code":"E0277","explanation":"You tried to use a type which doesn't implement some trait in a place which\nexpected that trait.\n\nErroneous code example:\n\n```compile_fail,E0277\n// here we declare the Foo trait with a bar method\ntrait Foo {\n    fn bar(&self);\n}\n\n// we now declare a function which takes an object implementing the Foo trait\nfn some_func<T: Foo>(foo: T) {\n    foo.bar();\n}\n\nfn main() {\n    // we now call the method with the i32 type, which doesn't implement\n    // the Foo trait\n    some_func(5i32); // error: the trait bound `i32 : Foo` is not satisfied\n}\n```\n\nIn order to fix this error, verify that the type you're using does implement\nthe trait. Example:\n\n```\ntrait Foo {\n    fn bar(&self);\n}\n\n// we implement the trait on the i32 type\nimpl Foo for i32 {\n    fn bar(&self) {}\n}\n\nfn some_func<T: Foo>(foo: T) {\n    foo.bar(); // we can now use this method since i32 implements the\n               // Foo trait\n}\n\nfn main() {\n    some_func(5i32); // ok!\n}\n```\n\nOr in a generic context, an erroneous code example would look like:\n\n```compile_fail,E0277\nfn some_func<T>(foo: T) {\n    println!(\"{:?}\", foo); // error: the trait `core::fmt::Debug` is not\n                           //        implemented for the type `T`\n}\n\nfn main() {\n    // We now call the method with the i32 type,\n    // which *does* implement the Debug trait.\n    some_func(5i32);\n}\n```\n\nNote that the error here is in the definition of the generic function. Although\nwe only call it with a parameter that does implement `Debug`, the compiler\nstill rejects the function. It must work with all possible input types. In\norder to make this example compile, we need to restrict the generic type we're\naccepting:\n\n```\nuse std::fmt;\n\n// Restrict the input type to types that implement Debug.\nfn some_func<T: fmt::Debug>(foo: T) {\n    println!(\"{:?}\", foo);\n}\n\nfn main() {\n    // Calling the method is still fine, as i32 implements Debug.\n    some_func(5i32);\n\n    // This would fail to compile now:\n    // struct WithoutDebug;\n    // some_func(WithoutDebug);\n}\n```\n\nRust only looks at the signature of the called function, as such it must\nalready specify all requirements that will be used for every type parameter.\n"},"level":"error","spans":[{"file_name":"/Users/yugo/.cargo/git/checkouts/pairing-e1005e25456a4f82/868f527/src/bn256/common.rs","byte_start":17937,"byte_end":17943,"line_start":439,"line_end":439,"column_start":26,"column_end":32,"is_primary":true,"text":[{"text":"        impl BaseExt for $field {","highlight_start":26,"highlight_end":32}],"label":"value of type `fr::Fr` cannot be made by summing a `std::iter::Iterator<Item=fr::Fr>`","suggested_replacement":null,"suggestion_applicability":null,"expansion":{"span":{"file_name":"/Users/yugo/.cargo/git/checkouts/pairing-e1005e25456a4f82/868f527/src/bn256/fr.rs","byte_start":2493,"byte_end":2616,"line_start":101,"line_end":110,"column_start":1,"column_end":2,"is_primary":false,"text":[{"text":"common_field!(","highlight_start":1,"highlight_end":15},{"text":"    Fr,","highlight_start":1,"highlight_end":8},{"text":"    MODULUS,","highlight_start":1,"highlight_end":13},{"text":"    INV,","highlight_start":1,"highlight_end":9},{"text":"    BASEEXT_MODULUS,","highlight_start":1,"highlight_end":21},{"text":"    TWO_INV,","highlight_start":1,"highlight_end":13},{"text":"    ROOT_OF_UNITY_INV,","highlight_start":1,"highlight_end":23},{"text":"    DELTA,","highlight_start":1,"highlight_end":11},{"text":"    ZETA","highlight_start":1,"highlight_end":9},{"text":");","highlight_start":1,"highlight_end":2}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null},"macro_decl_name":"common_field!","def_site_span":{"file_name":"/Users/yugo/.cargo/git/checkouts/pairing-e1005e25456a4f82/868f527/src/bn256/common.rs","byte_start":0,"byte_end":25,"line_start":1,"line_end":1,"column_start":1,"column_end":26,"is_primary":false,"text":[{"text":"macro_rules! common_field {","highlight_start":1,"highlight_end":26}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}}}],"children":[{"message":"the trait `Sum` is not implemented for `fr::Fr`","code":null,"level":"help","spans":[],"children":[],"rendered":null},{"message":"the following other types implement trait `Sum<A>`:\n  <Duration as Sum<&'a Duration>>\n  <Duration as Sum>\n  <Gt as Sum<T>>\n  <Option<T> as Sum<Option<U>>>\n  <Result<T, E> as Sum<Result<U, E>>>\n  <Simd<f32, LANES> as Sum<&'a Simd<f32, LANES>>>\n  <Simd<f32, LANES> as Sum>\n  <Simd<f64, LANES> as Sum<&'a Simd<f64, LANES>>>\nand 76 others","code":null,"level":"help","spans":[],"children":[],"rendered":null},{"message":"required for `fr::Fr` to implement `ff::Field`","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"required by a bound in `fields::BaseExt`","code":null,"level":"note","spans":[{"file_name":"/Users/yugo/.cargo/git/checkouts/pairing-e1005e25456a4f82/868f527/src/arithmetic/fields.rs","byte_start":422,"byte_end":431,"line_start":15,"line_end":15,"column_start":20,"column_end":29,"is_primary":true,"text":[{"text":"pub trait BaseExt: ff::Field + Ord + ConstantTimeEq {","highlight_start":20,"highlight_end":29}],"label":"required by this bound in `BaseExt`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0277]\u001b[0m\u001b[0m\u001b[1m: a value of type `fr::Fr` cannot be made by summing an iterator over elements of type `fr::Fr`\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0m/Users/yugo/.cargo/git/checkouts/pairing-e1005e25456a4f82/868f527/src/bn256/common.rs:439:26\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m439\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m   \u001b[0m\u001b[0m        impl BaseExt for $field {\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m                           \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^^^^^^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9mvalue of type `fr::Fr` cannot be made by summing a `std::iter::Iterator<Item=fr::Fr>`\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m::: \u001b[0m\u001b[0m/Users/yugo/.cargo/git/checkouts/pairing-e1005e25456a4f82/868f527/src/bn256/fr.rs:101:1\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m101\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m/\u001b[0m\u001b[0m \u001b[0m\u001b[0mcommon_field!(\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m102\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m    Fr,\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m103\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m    MODULUS,\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m104\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m    INV,\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m...\u001b[0m\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m109\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m    ZETA\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m110\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m);\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|_-\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12min this macro invocation\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mhelp\u001b[0m\u001b[0m: the trait `Sum` is not implemented for `fr::Fr`\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mhelp\u001b[0m\u001b[0m: the following other types implement trait `Sum<A>`:\u001b[0m\n\u001b[0m              <Duration as Sum<&'a Duration>>\u001b[0m\n\u001b[0m              <Duration as Sum>\u001b[0m\n\u001b[0m              <Gt as Sum<T>>\u001b[0m\n\u001b[0m              <Option<T> as Sum<Option<U>>>\u001b[0m\n\u001b[0m              <Result<T, E> as Sum<Result<U, E>>>\u001b[0m\n\u001b[0m              <Simd<f32, LANES> as Sum<&'a Simd<f32, LANES>>>\u001b[0m\n\u001b[0m              <Simd<f32, LANES> as Sum>\u001b[0m\n\u001b[0m              <Simd<f64, LANES> as Sum<&'a Simd<f64, LANES>>>\u001b[0m\n\u001b[0m            and 76 others\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mnote\u001b[0m\u001b[0m: required for `fr::Fr` to implement `ff::Field`\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;10mnote\u001b[0m\u001b[0m: required by a bound in `fields::BaseExt`\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0m/Users/yugo/.cargo/git/checkouts/pairing-e1005e25456a4f82/868f527/src/arithmetic/fields.rs:15:20\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m15\u001b[0m\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0mpub trait BaseExt: ff::Field + Ord + ConstantTimeEq {\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m                   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;10m^^^^^^^^^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;10mrequired by this bound in `BaseExt`\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mnote\u001b[0m\u001b[0m: this error originates in the macro `common_field` (in Nightly builds, run with -Z macro-backtrace for more info)\u001b[0m\n\n"}
{"message":"a value of type `fr::Fr` cannot be made by multiplying all elements of type `&'a fr::Fr` from an iterator","code":{"code":"E0277","explanation":"You tried to use a type which doesn't implement some trait in a place which\nexpected that trait.\n\nErroneous code example:\n\n```compile_fail,E0277\n// here we declare the Foo trait with a bar method\ntrait Foo {\n    fn bar(&self);\n}\n\n// we now declare a function which takes an object implementing the Foo trait\nfn some_func<T: Foo>(foo: T) {\n    foo.bar();\n}\n\nfn main() {\n    // we now call the method with the i32 type, which doesn't implement\n    // the Foo trait\n    some_func(5i32); // error: the trait bound `i32 : Foo` is not satisfied\n}\n```\n\nIn order to fix this error, verify that the type you're using does implement\nthe trait. Example:\n\n```\ntrait Foo {\n    fn bar(&self);\n}\n\n// we implement the trait on the i32 type\nimpl Foo for i32 {\n    fn bar(&self) {}\n}\n\nfn some_func<T: Foo>(foo: T) {\n    foo.bar(); // we can now use this method since i32 implements the\n               // Foo trait\n}\n\nfn main() {\n    some_func(5i32); // ok!\n}\n```\n\nOr in a generic context, an erroneous code example would look like:\n\n```compile_fail,E0277\nfn some_func<T>(foo: T) {\n    println!(\"{:?}\", foo); // error: the trait `core::fmt::Debug` is not\n                           //        implemented for the type `T`\n}\n\nfn main() {\n    // We now call the method with the i32 type,\n    // which *does* implement the Debug trait.\n    some_func(5i32);\n}\n```\n\nNote that the error here is in the definition of the generic function. Although\nwe only call it with a parameter that does implement `Debug`, the compiler\nstill rejects the function. It must work with all possible input types. In\norder to make this example compile, we need to restrict the generic type we're\naccepting:\n\n```\nuse std::fmt;\n\n// Restrict the input type to types that implement Debug.\nfn some_func<T: fmt::Debug>(foo: T) {\n    println!(\"{:?}\", foo);\n}\n\nfn main() {\n    // Calling the method is still fine, as i32 implements Debug.\n    some_func(5i32);\n\n    // This would fail to compile now:\n    // struct WithoutDebug;\n    // some_func(WithoutDebug);\n}\n```\n\nRust only looks at the signature of the called function, as such it must\nalready specify all requirements that will be used for every type parameter.\n"},"level":"error","spans":[{"file_name":"/Users/yugo/.cargo/git/checkouts/pairing-e1005e25456a4f82/868f527/src/bn256/common.rs","byte_start":19738,"byte_end":19744,"line_start":478,"line_end":478,"column_start":27,"column_end":33,"is_primary":true,"text":[{"text":"        impl FieldExt for $field {","highlight_start":27,"highlight_end":33}],"label":"value of type `fr::Fr` cannot be made by multiplying all elements from a `std::iter::Iterator<Item=&'a fr::Fr>`","suggested_replacement":null,"suggestion_applicability":null,"expansion":{"span":{"file_name":"/Users/yugo/.cargo/git/checkouts/pairing-e1005e25456a4f82/868f527/src/bn256/fr.rs","byte_start":2493,"byte_end":2616,"line_start":101,"line_end":110,"column_start":1,"column_end":2,"is_primary":false,"text":[{"text":"common_field!(","highlight_start":1,"highlight_end":15},{"text":"    Fr,","highlight_start":1,"highlight_end":8},{"text":"    MODULUS,","highlight_start":1,"highlight_end":13},{"text":"    INV,","highlight_start":1,"highlight_end":9},{"text":"    BASEEXT_MODULUS,","highlight_start":1,"highlight_end":21},{"text":"    TWO_INV,","highlight_start":1,"highlight_end":13},{"text":"    ROOT_OF_UNITY_INV,","highlight_start":1,"highlight_end":23},{"text":"    DELTA,","highlight_start":1,"highlight_end":11},{"text":"    ZETA","highlight_start":1,"highlight_end":9},{"text":");","highlight_start":1,"highlight_end":2}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null},"macro_decl_name":"common_field!","def_site_span":{"file_name":"/Users/yugo/.cargo/git/checkouts/pairing-e1005e25456a4f82/868f527/src/bn256/common.rs","byte_start":0,"byte_end":25,"line_start":1,"line_end":1,"column_start":1,"column_end":26,"is_primary":false,"text":[{"text":"macro_rules! common_field {","highlight_start":1,"highlight_end":26}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}}}],"children":[{"message":"the trait `for<'a> Product<&'a fr::Fr>` is not implemented for `fr::Fr`","code":null,"level":"help","spans":[],"children":[],"rendered":null},{"message":"the following other types implement trait `Product<A>`:\n  <Option<T> as Product<Option<U>>>\n  <Result<T, E> as Product<Result<U, E>>>\n  <Simd<f32, LANES> as Product<&'a Simd<f32, LANES>>>\n  <Simd<f32, LANES> as Product>\n  <Simd<f64, LANES> as Product<&'a Simd<f64, LANES>>>\n  <Simd<f64, LANES> as Product>\n  <Simd<i16, LANES> as Product<&'a Simd<i16, LANES>>>\n  <Simd<i16, LANES> as Product>\nand 70 others","code":null,"level":"help","spans":[],"children":[],"rendered":null},{"message":"required for `fr::Fr` to implement `ff::Field`","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"required for `fr::Fr` to implement `fields::BaseExt`","code":null,"level":"note","spans":[{"file_name":"/Users/yugo/.cargo/git/checkouts/pairing-e1005e25456a4f82/868f527/src/arithmetic/fields.rs","byte_start":413,"byte_end":420,"line_start":15,"line_end":15,"column_start":11,"column_end":18,"is_primary":true,"text":[{"text":"pub trait BaseExt: ff::Field + Ord + ConstantTimeEq {","highlight_start":11,"highlight_end":18}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null},{"message":"required by a bound in `fields::FieldExt`","code":null,"level":"note","spans":[{"file_name":"/Users/yugo/.cargo/git/checkouts/pairing-e1005e25456a4f82/868f527/src/arithmetic/fields.rs","byte_start":1823,"byte_end":1830,"line_start":56,"line_end":56,"column_start":38,"column_end":45,"is_primary":true,"text":[{"text":"pub trait FieldExt: ff::PrimeField + BaseExt + Group<Scalar = Self> + From<bool> {","highlight_start":38,"highlight_end":45}],"label":"required by this bound in `FieldExt`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0277]\u001b[0m\u001b[0m\u001b[1m: a value of type `fr::Fr` cannot be made by multiplying all elements of type `&'a fr::Fr` from an iterator\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0m/Users/yugo/.cargo/git/checkouts/pairing-e1005e25456a4f82/868f527/src/bn256/common.rs:478:27\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m478\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m   \u001b[0m\u001b[0m        impl FieldExt for $field {\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m                            \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^^^^^^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9mvalue of type `fr::Fr` cannot be made by multiplying all elements from a `std::iter::Iterator<Item=&'a fr::Fr>`\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m::: \u001b[0m\u001b[0m/Users/yugo/.cargo/git/checkouts/pairing-e1005e25456a4f82/868f527/src/bn256/fr.rs:101:1\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m101\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m/\u001b[0m\u001b[0m \u001b[0m\u001b[0mcommon_field!(\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m102\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m    Fr,\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m103\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m    MODULUS,\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m104\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m    INV,\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m...\u001b[0m\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m109\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m    ZETA\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m110\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m);\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|_-\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12min this macro invocation\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mhelp\u001b[0m\u001b[0m: the trait `for<'a> Product<&'a fr::Fr>` is not implemented for `fr::Fr`\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mhelp\u001b[0m\u001b[0m: the following other types implement trait `Product<A>`:\u001b[0m\n\u001b[0m              <Option<T> as Product<Option<U>>>\u001b[0m\n\u001b[0m              <Result<T, E> as Product<Result<U, E>>>\u001b[0m\n\u001b[0m              <Simd<f32, LANES> as Product<&'a Simd<f32, LANES>>>\u001b[0m\n\u001b[0m              <Simd<f32, LANES> as Product>\u001b[0m\n\u001b[0m              <Simd<f64, LANES> as Product<&'a Simd<f64, LANES>>>\u001b[0m\n\u001b[0m              <Simd<f64, LANES> as Product>\u001b[0m\n\u001b[0m              <Simd<i16, LANES> as Product<&'a Simd<i16, LANES>>>\u001b[0m\n\u001b[0m              <Simd<i16, LANES> as Product>\u001b[0m\n\u001b[0m            and 70 others\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mnote\u001b[0m\u001b[0m: required for `fr::Fr` to implement `ff::Field`\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;10mnote\u001b[0m\u001b[0m: required for `fr::Fr` to implement `fields::BaseExt`\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0m/Users/yugo/.cargo/git/checkouts/pairing-e1005e25456a4f82/868f527/src/arithmetic/fields.rs:15:11\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m15\u001b[0m\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0mpub trait BaseExt: ff::Field + Ord + ConstantTimeEq {\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m          \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;10m^^^^^^^\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;10mnote\u001b[0m\u001b[0m: required by a bound in `fields::FieldExt`\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0m/Users/yugo/.cargo/git/checkouts/pairing-e1005e25456a4f82/868f527/src/arithmetic/fields.rs:56:38\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m56\u001b[0m\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0mpub trait FieldExt: ff::PrimeField + BaseExt + Group<Scalar = Self> + From<bool> {\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m                                     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;10m^^^^^^^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;10mrequired by this bound in `FieldExt`\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mnote\u001b[0m\u001b[0m: this error originates in the macro `common_field` (in Nightly builds, run with -Z macro-backtrace for more info)\u001b[0m\n\n"}
{"message":"a value of type `fr::Fr` cannot be made by summing an iterator over elements of type `&'a fr::Fr`","code":{"code":"E0277","explanation":"You tried to use a type which doesn't implement some trait in a place which\nexpected that trait.\n\nErroneous code example:\n\n```compile_fail,E0277\n// here we declare the Foo trait with a bar method\ntrait Foo {\n    fn bar(&self);\n}\n\n// we now declare a function which takes an object implementing the Foo trait\nfn some_func<T: Foo>(foo: T) {\n    foo.bar();\n}\n\nfn main() {\n    // we now call the method with the i32 type, which doesn't implement\n    // the Foo trait\n    some_func(5i32); // error: the trait bound `i32 : Foo` is not satisfied\n}\n```\n\nIn order to fix this error, verify that the type you're using does implement\nthe trait. Example:\n\n```\ntrait Foo {\n    fn bar(&self);\n}\n\n// we implement the trait on the i32 type\nimpl Foo for i32 {\n    fn bar(&self) {}\n}\n\nfn some_func<T: Foo>(foo: T) {\n    foo.bar(); // we can now use this method since i32 implements the\n               // Foo trait\n}\n\nfn main() {\n    some_func(5i32); // ok!\n}\n```\n\nOr in a generic context, an erroneous code example would look like:\n\n```compile_fail,E0277\nfn some_func<T>(foo: T) {\n    println!(\"{:?}\", foo); // error: the trait `core::fmt::Debug` is not\n                           //        implemented for the type `T`\n}\n\nfn main() {\n    // We now call the method with the i32 type,\n    // which *does* implement the Debug trait.\n    some_func(5i32);\n}\n```\n\nNote that the error here is in the definition of the generic function. Although\nwe only call it with a parameter that does implement `Debug`, the compiler\nstill rejects the function. It must work with all possible input types. In\norder to make this example compile, we need to restrict the generic type we're\naccepting:\n\n```\nuse std::fmt;\n\n// Restrict the input type to types that implement Debug.\nfn some_func<T: fmt::Debug>(foo: T) {\n    println!(\"{:?}\", foo);\n}\n\nfn main() {\n    // Calling the method is still fine, as i32 implements Debug.\n    some_func(5i32);\n\n    // This would fail to compile now:\n    // struct WithoutDebug;\n    // some_func(WithoutDebug);\n}\n```\n\nRust only looks at the signature of the called function, as such it must\nalready specify all requirements that will be used for every type parameter.\n"},"level":"error","spans":[{"file_name":"/Users/yugo/.cargo/git/checkouts/pairing-e1005e25456a4f82/868f527/src/bn256/common.rs","byte_start":19738,"byte_end":19744,"line_start":478,"line_end":478,"column_start":27,"column_end":33,"is_primary":true,"text":[{"text":"        impl FieldExt for $field {","highlight_start":27,"highlight_end":33}],"label":"value of type `fr::Fr` cannot be made by summing a `std::iter::Iterator<Item=&'a fr::Fr>`","suggested_replacement":null,"suggestion_applicability":null,"expansion":{"span":{"file_name":"/Users/yugo/.cargo/git/checkouts/pairing-e1005e25456a4f82/868f527/src/bn256/fr.rs","byte_start":2493,"byte_end":2616,"line_start":101,"line_end":110,"column_start":1,"column_end":2,"is_primary":false,"text":[{"text":"common_field!(","highlight_start":1,"highlight_end":15},{"text":"    Fr,","highlight_start":1,"highlight_end":8},{"text":"    MODULUS,","highlight_start":1,"highlight_end":13},{"text":"    INV,","highlight_start":1,"highlight_end":9},{"text":"    BASEEXT_MODULUS,","highlight_start":1,"highlight_end":21},{"text":"    TWO_INV,","highlight_start":1,"highlight_end":13},{"text":"    ROOT_OF_UNITY_INV,","highlight_start":1,"highlight_end":23},{"text":"    DELTA,","highlight_start":1,"highlight_end":11},{"text":"    ZETA","highlight_start":1,"highlight_end":9},{"text":");","highlight_start":1,"highlight_end":2}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null},"macro_decl_name":"common_field!","def_site_span":{"file_name":"/Users/yugo/.cargo/git/checkouts/pairing-e1005e25456a4f82/868f527/src/bn256/common.rs","byte_start":0,"byte_end":25,"line_start":1,"line_end":1,"column_start":1,"column_end":26,"is_primary":false,"text":[{"text":"macro_rules! common_field {","highlight_start":1,"highlight_end":26}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}}}],"children":[{"message":"the trait `for<'a> Sum<&'a fr::Fr>` is not implemented for `fr::Fr`","code":null,"level":"help","spans":[],"children":[],"rendered":null},{"message":"the following other types implement trait `Sum<A>`:\n  <Duration as Sum<&'a Duration>>\n  <Duration as Sum>\n  <Gt as Sum<T>>\n  <Option<T> as Sum<Option<U>>>\n  <Result<T, E> as Sum<Result<U, E>>>\n  <Simd<f32, LANES> as Sum<&'a Simd<f32, LANES>>>\n  <Simd<f32, LANES> as Sum>\n  <Simd<f64, LANES> as Sum<&'a Simd<f64, LANES>>>\nand 76 others","code":null,"level":"help","spans":[],"children":[],"rendered":null},{"message":"required for `fr::Fr` to implement `ff::Field`","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"required for `fr::Fr` to implement `fields::BaseExt`","code":null,"level":"note","spans":[{"file_name":"/Users/yugo/.cargo/git/checkouts/pairing-e1005e25456a4f82/868f527/src/arithmetic/fields.rs","byte_start":413,"byte_end":420,"line_start":15,"line_end":15,"column_start":11,"column_end":18,"is_primary":true,"text":[{"text":"pub trait BaseExt: ff::Field + Ord + ConstantTimeEq {","highlight_start":11,"highlight_end":18}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null},{"message":"required by a bound in `fields::FieldExt`","code":null,"level":"note","spans":[{"file_name":"/Users/yugo/.cargo/git/checkouts/pairing-e1005e25456a4f82/868f527/src/arithmetic/fields.rs","byte_start":1823,"byte_end":1830,"line_start":56,"line_end":56,"column_start":38,"column_end":45,"is_primary":true,"text":[{"text":"pub trait FieldExt: ff::PrimeField + BaseExt + Group<Scalar = Self> + From<bool> {","highlight_start":38,"highlight_end":45}],"label":"required by this bound in `FieldExt`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0277]\u001b[0m\u001b[0m\u001b[1m: a value of type `fr::Fr` cannot be made by summing an iterator over elements of type `&'a fr::Fr`\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0m/Users/yugo/.cargo/git/checkouts/pairing-e1005e25456a4f82/868f527/src/bn256/common.rs:478:27\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m478\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m   \u001b[0m\u001b[0m        impl FieldExt for $field {\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m                            \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^^^^^^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9mvalue of type `fr::Fr` cannot be made by summing a `std::iter::Iterator<Item=&'a fr::Fr>`\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m::: \u001b[0m\u001b[0m/Users/yugo/.cargo/git/checkouts/pairing-e1005e25456a4f82/868f527/src/bn256/fr.rs:101:1\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m101\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m/\u001b[0m\u001b[0m \u001b[0m\u001b[0mcommon_field!(\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m102\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m    Fr,\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m103\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m    MODULUS,\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m104\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m    INV,\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m...\u001b[0m\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m109\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m    ZETA\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m110\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m);\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|_-\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12min this macro invocation\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mhelp\u001b[0m\u001b[0m: the trait `for<'a> Sum<&'a fr::Fr>` is not implemented for `fr::Fr`\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mhelp\u001b[0m\u001b[0m: the following other types implement trait `Sum<A>`:\u001b[0m\n\u001b[0m              <Duration as Sum<&'a Duration>>\u001b[0m\n\u001b[0m              <Duration as Sum>\u001b[0m\n\u001b[0m              <Gt as Sum<T>>\u001b[0m\n\u001b[0m              <Option<T> as Sum<Option<U>>>\u001b[0m\n\u001b[0m              <Result<T, E> as Sum<Result<U, E>>>\u001b[0m\n\u001b[0m              <Simd<f32, LANES> as Sum<&'a Simd<f32, LANES>>>\u001b[0m\n\u001b[0m              <Simd<f32, LANES> as Sum>\u001b[0m\n\u001b[0m              <Simd<f64, LANES> as Sum<&'a Simd<f64, LANES>>>\u001b[0m\n\u001b[0m            and 76 others\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mnote\u001b[0m\u001b[0m: required for `fr::Fr` to implement `ff::Field`\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;10mnote\u001b[0m\u001b[0m: required for `fr::Fr` to implement `fields::BaseExt`\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0m/Users/yugo/.cargo/git/checkouts/pairing-e1005e25456a4f82/868f527/src/arithmetic/fields.rs:15:11\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m15\u001b[0m\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0mpub trait BaseExt: ff::Field + Ord + ConstantTimeEq {\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m          \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;10m^^^^^^^\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;10mnote\u001b[0m\u001b[0m: required by a bound in `fields::FieldExt`\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0m/Users/yugo/.cargo/git/checkouts/pairing-e1005e25456a4f82/868f527/src/arithmetic/fields.rs:56:38\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m56\u001b[0m\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0mpub trait FieldExt: ff::PrimeField + BaseExt + Group<Scalar = Self> + From<bool> {\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m                                     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;10m^^^^^^^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;10mrequired by this bound in `FieldExt`\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mnote\u001b[0m\u001b[0m: this error originates in the macro `common_field` (in Nightly builds, run with -Z macro-backtrace for more info)\u001b[0m\n\n"}
{"message":"a value of type `fr::Fr` cannot be made by multiplying all elements of type `fr::Fr` from an iterator","code":{"code":"E0277","explanation":"You tried to use a type which doesn't implement some trait in a place which\nexpected that trait.\n\nErroneous code example:\n\n```compile_fail,E0277\n// here we declare the Foo trait with a bar method\ntrait Foo {\n    fn bar(&self);\n}\n\n// we now declare a function which takes an object implementing the Foo trait\nfn some_func<T: Foo>(foo: T) {\n    foo.bar();\n}\n\nfn main() {\n    // we now call the method with the i32 type, which doesn't implement\n    // the Foo trait\n    some_func(5i32); // error: the trait bound `i32 : Foo` is not satisfied\n}\n```\n\nIn order to fix this error, verify that the type you're using does implement\nthe trait. Example:\n\n```\ntrait Foo {\n    fn bar(&self);\n}\n\n// we implement the trait on the i32 type\nimpl Foo for i32 {\n    fn bar(&self) {}\n}\n\nfn some_func<T: Foo>(foo: T) {\n    foo.bar(); // we can now use this method since i32 implements the\n               // Foo trait\n}\n\nfn main() {\n    some_func(5i32); // ok!\n}\n```\n\nOr in a generic context, an erroneous code example would look like:\n\n```compile_fail,E0277\nfn some_func<T>(foo: T) {\n    println!(\"{:?}\", foo); // error: the trait `core::fmt::Debug` is not\n                           //        implemented for the type `T`\n}\n\nfn main() {\n    // We now call the method with the i32 type,\n    // which *does* implement the Debug trait.\n    some_func(5i32);\n}\n```\n\nNote that the error here is in the definition of the generic function. Although\nwe only call it with a parameter that does implement `Debug`, the compiler\nstill rejects the function. It must work with all possible input types. In\norder to make this example compile, we need to restrict the generic type we're\naccepting:\n\n```\nuse std::fmt;\n\n// Restrict the input type to types that implement Debug.\nfn some_func<T: fmt::Debug>(foo: T) {\n    println!(\"{:?}\", foo);\n}\n\nfn main() {\n    // Calling the method is still fine, as i32 implements Debug.\n    some_func(5i32);\n\n    // This would fail to compile now:\n    // struct WithoutDebug;\n    // some_func(WithoutDebug);\n}\n```\n\nRust only looks at the signature of the called function, as such it must\nalready specify all requirements that will be used for every type parameter.\n"},"level":"error","spans":[{"file_name":"/Users/yugo/.cargo/git/checkouts/pairing-e1005e25456a4f82/868f527/src/bn256/common.rs","byte_start":19738,"byte_end":19744,"line_start":478,"line_end":478,"column_start":27,"column_end":33,"is_primary":true,"text":[{"text":"        impl FieldExt for $field {","highlight_start":27,"highlight_end":33}],"label":"value of type `fr::Fr` cannot be made by multiplying all elements from a `std::iter::Iterator<Item=fr::Fr>`","suggested_replacement":null,"suggestion_applicability":null,"expansion":{"span":{"file_name":"/Users/yugo/.cargo/git/checkouts/pairing-e1005e25456a4f82/868f527/src/bn256/fr.rs","byte_start":2493,"byte_end":2616,"line_start":101,"line_end":110,"column_start":1,"column_end":2,"is_primary":false,"text":[{"text":"common_field!(","highlight_start":1,"highlight_end":15},{"text":"    Fr,","highlight_start":1,"highlight_end":8},{"text":"    MODULUS,","highlight_start":1,"highlight_end":13},{"text":"    INV,","highlight_start":1,"highlight_end":9},{"text":"    BASEEXT_MODULUS,","highlight_start":1,"highlight_end":21},{"text":"    TWO_INV,","highlight_start":1,"highlight_end":13},{"text":"    ROOT_OF_UNITY_INV,","highlight_start":1,"highlight_end":23},{"text":"    DELTA,","highlight_start":1,"highlight_end":11},{"text":"    ZETA","highlight_start":1,"highlight_end":9},{"text":");","highlight_start":1,"highlight_end":2}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null},"macro_decl_name":"common_field!","def_site_span":{"file_name":"/Users/yugo/.cargo/git/checkouts/pairing-e1005e25456a4f82/868f527/src/bn256/common.rs","byte_start":0,"byte_end":25,"line_start":1,"line_end":1,"column_start":1,"column_end":26,"is_primary":false,"text":[{"text":"macro_rules! common_field {","highlight_start":1,"highlight_end":26}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}}}],"children":[{"message":"the trait `Product` is not implemented for `fr::Fr`","code":null,"level":"help","spans":[],"children":[],"rendered":null},{"message":"the following other types implement trait `Product<A>`:\n  <Option<T> as Product<Option<U>>>\n  <Result<T, E> as Product<Result<U, E>>>\n  <Simd<f32, LANES> as Product<&'a Simd<f32, LANES>>>\n  <Simd<f32, LANES> as Product>\n  <Simd<f64, LANES> as Product<&'a Simd<f64, LANES>>>\n  <Simd<f64, LANES> as Product>\n  <Simd<i16, LANES> as Product<&'a Simd<i16, LANES>>>\n  <Simd<i16, LANES> as Product>\nand 70 others","code":null,"level":"help","spans":[],"children":[],"rendered":null},{"message":"required for `fr::Fr` to implement `ff::Field`","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"required for `fr::Fr` to implement `fields::BaseExt`","code":null,"level":"note","spans":[{"file_name":"/Users/yugo/.cargo/git/checkouts/pairing-e1005e25456a4f82/868f527/src/arithmetic/fields.rs","byte_start":413,"byte_end":420,"line_start":15,"line_end":15,"column_start":11,"column_end":18,"is_primary":true,"text":[{"text":"pub trait BaseExt: ff::Field + Ord + ConstantTimeEq {","highlight_start":11,"highlight_end":18}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null},{"message":"required by a bound in `fields::FieldExt`","code":null,"level":"note","spans":[{"file_name":"/Users/yugo/.cargo/git/checkouts/pairing-e1005e25456a4f82/868f527/src/arithmetic/fields.rs","byte_start":1823,"byte_end":1830,"line_start":56,"line_end":56,"column_start":38,"column_end":45,"is_primary":true,"text":[{"text":"pub trait FieldExt: ff::PrimeField + BaseExt + Group<Scalar = Self> + From<bool> {","highlight_start":38,"highlight_end":45}],"label":"required by this bound in `FieldExt`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0277]\u001b[0m\u001b[0m\u001b[1m: a value of type `fr::Fr` cannot be made by multiplying all elements of type `fr::Fr` from an iterator\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0m/Users/yugo/.cargo/git/checkouts/pairing-e1005e25456a4f82/868f527/src/bn256/common.rs:478:27\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m478\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m   \u001b[0m\u001b[0m        impl FieldExt for $field {\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m                            \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^^^^^^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9mvalue of type `fr::Fr` cannot be made by multiplying all elements from a `std::iter::Iterator<Item=fr::Fr>`\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m::: \u001b[0m\u001b[0m/Users/yugo/.cargo/git/checkouts/pairing-e1005e25456a4f82/868f527/src/bn256/fr.rs:101:1\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m101\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m/\u001b[0m\u001b[0m \u001b[0m\u001b[0mcommon_field!(\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m102\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m    Fr,\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m103\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m    MODULUS,\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m104\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m    INV,\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m...\u001b[0m\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m109\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m    ZETA\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m110\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m);\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|_-\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12min this macro invocation\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mhelp\u001b[0m\u001b[0m: the trait `Product` is not implemented for `fr::Fr`\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mhelp\u001b[0m\u001b[0m: the following other types implement trait `Product<A>`:\u001b[0m\n\u001b[0m              <Option<T> as Product<Option<U>>>\u001b[0m\n\u001b[0m              <Result<T, E> as Product<Result<U, E>>>\u001b[0m\n\u001b[0m              <Simd<f32, LANES> as Product<&'a Simd<f32, LANES>>>\u001b[0m\n\u001b[0m              <Simd<f32, LANES> as Product>\u001b[0m\n\u001b[0m              <Simd<f64, LANES> as Product<&'a Simd<f64, LANES>>>\u001b[0m\n\u001b[0m              <Simd<f64, LANES> as Product>\u001b[0m\n\u001b[0m              <Simd<i16, LANES> as Product<&'a Simd<i16, LANES>>>\u001b[0m\n\u001b[0m              <Simd<i16, LANES> as Product>\u001b[0m\n\u001b[0m            and 70 others\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mnote\u001b[0m\u001b[0m: required for `fr::Fr` to implement `ff::Field`\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;10mnote\u001b[0m\u001b[0m: required for `fr::Fr` to implement `fields::BaseExt`\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0m/Users/yugo/.cargo/git/checkouts/pairing-e1005e25456a4f82/868f527/src/arithmetic/fields.rs:15:11\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m15\u001b[0m\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0mpub trait BaseExt: ff::Field + Ord + ConstantTimeEq {\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m          \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;10m^^^^^^^\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;10mnote\u001b[0m\u001b[0m: required by a bound in `fields::FieldExt`\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0m/Users/yugo/.cargo/git/checkouts/pairing-e1005e25456a4f82/868f527/src/arithmetic/fields.rs:56:38\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m56\u001b[0m\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0mpub trait FieldExt: ff::PrimeField + BaseExt + Group<Scalar = Self> + From<bool> {\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m                                     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;10m^^^^^^^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;10mrequired by this bound in `FieldExt`\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mnote\u001b[0m\u001b[0m: this error originates in the macro `common_field` (in Nightly builds, run with -Z macro-backtrace for more info)\u001b[0m\n\n"}
{"message":"a value of type `fr::Fr` cannot be made by summing an iterator over elements of type `fr::Fr`","code":{"code":"E0277","explanation":"You tried to use a type which doesn't implement some trait in a place which\nexpected that trait.\n\nErroneous code example:\n\n```compile_fail,E0277\n// here we declare the Foo trait with a bar method\ntrait Foo {\n    fn bar(&self);\n}\n\n// we now declare a function which takes an object implementing the Foo trait\nfn some_func<T: Foo>(foo: T) {\n    foo.bar();\n}\n\nfn main() {\n    // we now call the method with the i32 type, which doesn't implement\n    // the Foo trait\n    some_func(5i32); // error: the trait bound `i32 : Foo` is not satisfied\n}\n```\n\nIn order to fix this error, verify that the type you're using does implement\nthe trait. Example:\n\n```\ntrait Foo {\n    fn bar(&self);\n}\n\n// we implement the trait on the i32 type\nimpl Foo for i32 {\n    fn bar(&self) {}\n}\n\nfn some_func<T: Foo>(foo: T) {\n    foo.bar(); // we can now use this method since i32 implements the\n               // Foo trait\n}\n\nfn main() {\n    some_func(5i32); // ok!\n}\n```\n\nOr in a generic context, an erroneous code example would look like:\n\n```compile_fail,E0277\nfn some_func<T>(foo: T) {\n    println!(\"{:?}\", foo); // error: the trait `core::fmt::Debug` is not\n                           //        implemented for the type `T`\n}\n\nfn main() {\n    // We now call the method with the i32 type,\n    // which *does* implement the Debug trait.\n    some_func(5i32);\n}\n```\n\nNote that the error here is in the definition of the generic function. Although\nwe only call it with a parameter that does implement `Debug`, the compiler\nstill rejects the function. It must work with all possible input types. In\norder to make this example compile, we need to restrict the generic type we're\naccepting:\n\n```\nuse std::fmt;\n\n// Restrict the input type to types that implement Debug.\nfn some_func<T: fmt::Debug>(foo: T) {\n    println!(\"{:?}\", foo);\n}\n\nfn main() {\n    // Calling the method is still fine, as i32 implements Debug.\n    some_func(5i32);\n\n    // This would fail to compile now:\n    // struct WithoutDebug;\n    // some_func(WithoutDebug);\n}\n```\n\nRust only looks at the signature of the called function, as such it must\nalready specify all requirements that will be used for every type parameter.\n"},"level":"error","spans":[{"file_name":"/Users/yugo/.cargo/git/checkouts/pairing-e1005e25456a4f82/868f527/src/bn256/common.rs","byte_start":19738,"byte_end":19744,"line_start":478,"line_end":478,"column_start":27,"column_end":33,"is_primary":true,"text":[{"text":"        impl FieldExt for $field {","highlight_start":27,"highlight_end":33}],"label":"value of type `fr::Fr` cannot be made by summing a `std::iter::Iterator<Item=fr::Fr>`","suggested_replacement":null,"suggestion_applicability":null,"expansion":{"span":{"file_name":"/Users/yugo/.cargo/git/checkouts/pairing-e1005e25456a4f82/868f527/src/bn256/fr.rs","byte_start":2493,"byte_end":2616,"line_start":101,"line_end":110,"column_start":1,"column_end":2,"is_primary":false,"text":[{"text":"common_field!(","highlight_start":1,"highlight_end":15},{"text":"    Fr,","highlight_start":1,"highlight_end":8},{"text":"    MODULUS,","highlight_start":1,"highlight_end":13},{"text":"    INV,","highlight_start":1,"highlight_end":9},{"text":"    BASEEXT_MODULUS,","highlight_start":1,"highlight_end":21},{"text":"    TWO_INV,","highlight_start":1,"highlight_end":13},{"text":"    ROOT_OF_UNITY_INV,","highlight_start":1,"highlight_end":23},{"text":"    DELTA,","highlight_start":1,"highlight_end":11},{"text":"    ZETA","highlight_start":1,"highlight_end":9},{"text":");","highlight_start":1,"highlight_end":2}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null},"macro_decl_name":"common_field!","def_site_span":{"file_name":"/Users/yugo/.cargo/git/checkouts/pairing-e1005e25456a4f82/868f527/src/bn256/common.rs","byte_start":0,"byte_end":25,"line_start":1,"line_end":1,"column_start":1,"column_end":26,"is_primary":false,"text":[{"text":"macro_rules! common_field {","highlight_start":1,"highlight_end":26}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}}}],"children":[{"message":"the trait `Sum` is not implemented for `fr::Fr`","code":null,"level":"help","spans":[],"children":[],"rendered":null},{"message":"the following other types implement trait `Sum<A>`:\n  <Duration as Sum<&'a Duration>>\n  <Duration as Sum>\n  <Gt as Sum<T>>\n  <Option<T> as Sum<Option<U>>>\n  <Result<T, E> as Sum<Result<U, E>>>\n  <Simd<f32, LANES> as Sum<&'a Simd<f32, LANES>>>\n  <Simd<f32, LANES> as Sum>\n  <Simd<f64, LANES> as Sum<&'a Simd<f64, LANES>>>\nand 76 others","code":null,"level":"help","spans":[],"children":[],"rendered":null},{"message":"required for `fr::Fr` to implement `ff::Field`","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"required for `fr::Fr` to implement `fields::BaseExt`","code":null,"level":"note","spans":[{"file_name":"/Users/yugo/.cargo/git/checkouts/pairing-e1005e25456a4f82/868f527/src/arithmetic/fields.rs","byte_start":413,"byte_end":420,"line_start":15,"line_end":15,"column_start":11,"column_end":18,"is_primary":true,"text":[{"text":"pub trait BaseExt: ff::Field + Ord + ConstantTimeEq {","highlight_start":11,"highlight_end":18}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null},{"message":"required by a bound in `fields::FieldExt`","code":null,"level":"note","spans":[{"file_name":"/Users/yugo/.cargo/git/checkouts/pairing-e1005e25456a4f82/868f527/src/arithmetic/fields.rs","byte_start":1823,"byte_end":1830,"line_start":56,"line_end":56,"column_start":38,"column_end":45,"is_primary":true,"text":[{"text":"pub trait FieldExt: ff::PrimeField + BaseExt + Group<Scalar = Self> + From<bool> {","highlight_start":38,"highlight_end":45}],"label":"required by this bound in `FieldExt`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0277]\u001b[0m\u001b[0m\u001b[1m: a value of type `fr::Fr` cannot be made by summing an iterator over elements of type `fr::Fr`\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0m/Users/yugo/.cargo/git/checkouts/pairing-e1005e25456a4f82/868f527/src/bn256/common.rs:478:27\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m478\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m   \u001b[0m\u001b[0m        impl FieldExt for $field {\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m                            \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^^^^^^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9mvalue of type `fr::Fr` cannot be made by summing a `std::iter::Iterator<Item=fr::Fr>`\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m::: \u001b[0m\u001b[0m/Users/yugo/.cargo/git/checkouts/pairing-e1005e25456a4f82/868f527/src/bn256/fr.rs:101:1\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m101\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m/\u001b[0m\u001b[0m \u001b[0m\u001b[0mcommon_field!(\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m102\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m    Fr,\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m103\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m    MODULUS,\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m104\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m    INV,\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m...\u001b[0m\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m109\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m    ZETA\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m110\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m);\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|_-\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12min this macro invocation\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mhelp\u001b[0m\u001b[0m: the trait `Sum` is not implemented for `fr::Fr`\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mhelp\u001b[0m\u001b[0m: the following other types implement trait `Sum<A>`:\u001b[0m\n\u001b[0m              <Duration as Sum<&'a Duration>>\u001b[0m\n\u001b[0m              <Duration as Sum>\u001b[0m\n\u001b[0m              <Gt as Sum<T>>\u001b[0m\n\u001b[0m              <Option<T> as Sum<Option<U>>>\u001b[0m\n\u001b[0m              <Result<T, E> as Sum<Result<U, E>>>\u001b[0m\n\u001b[0m              <Simd<f32, LANES> as Sum<&'a Simd<f32, LANES>>>\u001b[0m\n\u001b[0m              <Simd<f32, LANES> as Sum>\u001b[0m\n\u001b[0m              <Simd<f64, LANES> as Sum<&'a Simd<f64, LANES>>>\u001b[0m\n\u001b[0m            and 76 others\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mnote\u001b[0m\u001b[0m: required for `fr::Fr` to implement `ff::Field`\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;10mnote\u001b[0m\u001b[0m: required for `fr::Fr` to implement `fields::BaseExt`\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0m/Users/yugo/.cargo/git/checkouts/pairing-e1005e25456a4f82/868f527/src/arithmetic/fields.rs:15:11\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m15\u001b[0m\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0mpub trait BaseExt: ff::Field + Ord + ConstantTimeEq {\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m          \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;10m^^^^^^^\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;10mnote\u001b[0m\u001b[0m: required by a bound in `fields::FieldExt`\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0m/Users/yugo/.cargo/git/checkouts/pairing-e1005e25456a4f82/868f527/src/arithmetic/fields.rs:56:38\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m56\u001b[0m\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0mpub trait FieldExt: ff::PrimeField + BaseExt + Group<Scalar = Self> + From<bool> {\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m                                     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;10m^^^^^^^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;10mrequired by this bound in `FieldExt`\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mnote\u001b[0m\u001b[0m: this error originates in the macro `common_field` (in Nightly builds, run with -Z macro-backtrace for more info)\u001b[0m\n\n"}
{"message":"a value of type `fr::Fr` cannot be made by multiplying all elements of type `&'a fr::Fr` from an iterator","code":{"code":"E0277","explanation":"You tried to use a type which doesn't implement some trait in a place which\nexpected that trait.\n\nErroneous code example:\n\n```compile_fail,E0277\n// here we declare the Foo trait with a bar method\ntrait Foo {\n    fn bar(&self);\n}\n\n// we now declare a function which takes an object implementing the Foo trait\nfn some_func<T: Foo>(foo: T) {\n    foo.bar();\n}\n\nfn main() {\n    // we now call the method with the i32 type, which doesn't implement\n    // the Foo trait\n    some_func(5i32); // error: the trait bound `i32 : Foo` is not satisfied\n}\n```\n\nIn order to fix this error, verify that the type you're using does implement\nthe trait. Example:\n\n```\ntrait Foo {\n    fn bar(&self);\n}\n\n// we implement the trait on the i32 type\nimpl Foo for i32 {\n    fn bar(&self) {}\n}\n\nfn some_func<T: Foo>(foo: T) {\n    foo.bar(); // we can now use this method since i32 implements the\n               // Foo trait\n}\n\nfn main() {\n    some_func(5i32); // ok!\n}\n```\n\nOr in a generic context, an erroneous code example would look like:\n\n```compile_fail,E0277\nfn some_func<T>(foo: T) {\n    println!(\"{:?}\", foo); // error: the trait `core::fmt::Debug` is not\n                           //        implemented for the type `T`\n}\n\nfn main() {\n    // We now call the method with the i32 type,\n    // which *does* implement the Debug trait.\n    some_func(5i32);\n}\n```\n\nNote that the error here is in the definition of the generic function. Although\nwe only call it with a parameter that does implement `Debug`, the compiler\nstill rejects the function. It must work with all possible input types. In\norder to make this example compile, we need to restrict the generic type we're\naccepting:\n\n```\nuse std::fmt;\n\n// Restrict the input type to types that implement Debug.\nfn some_func<T: fmt::Debug>(foo: T) {\n    println!(\"{:?}\", foo);\n}\n\nfn main() {\n    // Calling the method is still fine, as i32 implements Debug.\n    some_func(5i32);\n\n    // This would fail to compile now:\n    // struct WithoutDebug;\n    // some_func(WithoutDebug);\n}\n```\n\nRust only looks at the signature of the called function, as such it must\nalready specify all requirements that will be used for every type parameter.\n"},"level":"error","spans":[{"file_name":"/Users/yugo/.cargo/git/checkouts/pairing-e1005e25456a4f82/868f527/src/bn256/fr.rs","byte_start":2818,"byte_end":2820,"line_start":121,"line_end":121,"column_start":20,"column_end":22,"is_primary":true,"text":[{"text":"impl ff::Field for Fr {","highlight_start":20,"highlight_end":22}],"label":"value of type `fr::Fr` cannot be made by multiplying all elements from a `std::iter::Iterator<Item=&'a fr::Fr>`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"the trait `for<'a> Product<&'a fr::Fr>` is not implemented for `fr::Fr`","code":null,"level":"help","spans":[],"children":[],"rendered":null},{"message":"the following other types implement trait `Product<A>`:\n  <Option<T> as Product<Option<U>>>\n  <Result<T, E> as Product<Result<U, E>>>\n  <Simd<f32, LANES> as Product<&'a Simd<f32, LANES>>>\n  <Simd<f32, LANES> as Product>\n  <Simd<f64, LANES> as Product<&'a Simd<f64, LANES>>>\n  <Simd<f64, LANES> as Product>\n  <Simd<i16, LANES> as Product<&'a Simd<i16, LANES>>>\n  <Simd<i16, LANES> as Product>\nand 70 others","code":null,"level":"help","spans":[],"children":[],"rendered":null},{"message":"required by a bound in `ff::Field`","code":null,"level":"note","spans":[{"file_name":"/Users/yugo/.cargo/registry/src/index.crates.io-6f17d22bba15001f/ff-0.13.0/src/lib.rs","byte_start":1508,"byte_end":1533,"line_start":63,"line_end":63,"column_start":7,"column_end":32,"is_primary":true,"text":[{"text":"    + for<'a> Product<&'a Self>","highlight_start":7,"highlight_end":32}],"label":"required by this bound in `Field`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0277]\u001b[0m\u001b[0m\u001b[1m: a value of type `fr::Fr` cannot be made by multiplying all elements of type `&'a fr::Fr` from an iterator\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0m/Users/yugo/.cargo/git/checkouts/pairing-e1005e25456a4f82/868f527/src/bn256/fr.rs:121:20\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m121\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0mimpl ff::Field for Fr {\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m                   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9mvalue of type `fr::Fr` cannot be made by multiplying all elements from a `std::iter::Iterator<Item=&'a fr::Fr>`\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mhelp\u001b[0m\u001b[0m: the trait `for<'a> Product<&'a fr::Fr>` is not implemented for `fr::Fr`\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mhelp\u001b[0m\u001b[0m: the following other types implement trait `Product<A>`:\u001b[0m\n\u001b[0m              <Option<T> as Product<Option<U>>>\u001b[0m\n\u001b[0m              <Result<T, E> as Product<Result<U, E>>>\u001b[0m\n\u001b[0m              <Simd<f32, LANES> as Product<&'a Simd<f32, LANES>>>\u001b[0m\n\u001b[0m              <Simd<f32, LANES> as Product>\u001b[0m\n\u001b[0m              <Simd<f64, LANES> as Product<&'a Simd<f64, LANES>>>\u001b[0m\n\u001b[0m              <Simd<f64, LANES> as Product>\u001b[0m\n\u001b[0m              <Simd<i16, LANES> as Product<&'a Simd<i16, LANES>>>\u001b[0m\n\u001b[0m              <Simd<i16, LANES> as Product>\u001b[0m\n\u001b[0m            and 70 others\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;10mnote\u001b[0m\u001b[0m: required by a bound in `ff::Field`\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0m/Users/yugo/.cargo/registry/src/index.crates.io-6f17d22bba15001f/ff-0.13.0/src/lib.rs:63:7\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m63\u001b[0m\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m    + for<'a> Product<&'a Self>\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m      \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;10m^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;10mrequired by this bound in `Field`\u001b[0m\n\n"}
{"message":"a value of type `fr::Fr` cannot be made by summing an iterator over elements of type `&'a fr::Fr`","code":{"code":"E0277","explanation":"You tried to use a type which doesn't implement some trait in a place which\nexpected that trait.\n\nErroneous code example:\n\n```compile_fail,E0277\n// here we declare the Foo trait with a bar method\ntrait Foo {\n    fn bar(&self);\n}\n\n// we now declare a function which takes an object implementing the Foo trait\nfn some_func<T: Foo>(foo: T) {\n    foo.bar();\n}\n\nfn main() {\n    // we now call the method with the i32 type, which doesn't implement\n    // the Foo trait\n    some_func(5i32); // error: the trait bound `i32 : Foo` is not satisfied\n}\n```\n\nIn order to fix this error, verify that the type you're using does implement\nthe trait. Example:\n\n```\ntrait Foo {\n    fn bar(&self);\n}\n\n// we implement the trait on the i32 type\nimpl Foo for i32 {\n    fn bar(&self) {}\n}\n\nfn some_func<T: Foo>(foo: T) {\n    foo.bar(); // we can now use this method since i32 implements the\n               // Foo trait\n}\n\nfn main() {\n    some_func(5i32); // ok!\n}\n```\n\nOr in a generic context, an erroneous code example would look like:\n\n```compile_fail,E0277\nfn some_func<T>(foo: T) {\n    println!(\"{:?}\", foo); // error: the trait `core::fmt::Debug` is not\n                           //        implemented for the type `T`\n}\n\nfn main() {\n    // We now call the method with the i32 type,\n    // which *does* implement the Debug trait.\n    some_func(5i32);\n}\n```\n\nNote that the error here is in the definition of the generic function. Although\nwe only call it with a parameter that does implement `Debug`, the compiler\nstill rejects the function. It must work with all possible input types. In\norder to make this example compile, we need to restrict the generic type we're\naccepting:\n\n```\nuse std::fmt;\n\n// Restrict the input type to types that implement Debug.\nfn some_func<T: fmt::Debug>(foo: T) {\n    println!(\"{:?}\", foo);\n}\n\nfn main() {\n    // Calling the method is still fine, as i32 implements Debug.\n    some_func(5i32);\n\n    // This would fail to compile now:\n    // struct WithoutDebug;\n    // some_func(WithoutDebug);\n}\n```\n\nRust only looks at the signature of the called function, as such it must\nalready specify all requirements that will be used for every type parameter.\n"},"level":"error","spans":[{"file_name":"/Users/yugo/.cargo/git/checkouts/pairing-e1005e25456a4f82/868f527/src/bn256/fr.rs","byte_start":2818,"byte_end":2820,"line_start":121,"line_end":121,"column_start":20,"column_end":22,"is_primary":true,"text":[{"text":"impl ff::Field for Fr {","highlight_start":20,"highlight_end":22}],"label":"value of type `fr::Fr` cannot be made by summing a `std::iter::Iterator<Item=&'a fr::Fr>`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"the trait `for<'a> Sum<&'a fr::Fr>` is not implemented for `fr::Fr`","code":null,"level":"help","spans":[],"children":[],"rendered":null},{"message":"the following other types implement trait `Sum<A>`:\n  <Duration as Sum<&'a Duration>>\n  <Duration as Sum>\n  <Gt as Sum<T>>\n  <Option<T> as Sum<Option<U>>>\n  <Result<T, E> as Sum<Result<U, E>>>\n  <Simd<f32, LANES> as Sum<&'a Simd<f32, LANES>>>\n  <Simd<f32, LANES> as Sum>\n  <Simd<f64, LANES> as Sum<&'a Simd<f64, LANES>>>\nand 76 others","code":null,"level":"help","spans":[],"children":[],"rendered":null},{"message":"required by a bound in `ff::Field`","code":null,"level":"note","spans":[{"file_name":"/Users/yugo/.cargo/registry/src/index.crates.io-6f17d22bba15001f/ff-0.13.0/src/lib.rs","byte_start":1480,"byte_end":1501,"line_start":62,"line_end":62,"column_start":7,"column_end":28,"is_primary":true,"text":[{"text":"    + for<'a> Sum<&'a Self>","highlight_start":7,"highlight_end":28}],"label":"required by this bound in `Field`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0277]\u001b[0m\u001b[0m\u001b[1m: a value of type `fr::Fr` cannot be made by summing an iterator over elements of type `&'a fr::Fr`\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0m/Users/yugo/.cargo/git/checkouts/pairing-e1005e25456a4f82/868f527/src/bn256/fr.rs:121:20\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m121\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0mimpl ff::Field for Fr {\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m                   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9mvalue of type `fr::Fr` cannot be made by summing a `std::iter::Iterator<Item=&'a fr::Fr>`\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mhelp\u001b[0m\u001b[0m: the trait `for<'a> Sum<&'a fr::Fr>` is not implemented for `fr::Fr`\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mhelp\u001b[0m\u001b[0m: the following other types implement trait `Sum<A>`:\u001b[0m\n\u001b[0m              <Duration as Sum<&'a Duration>>\u001b[0m\n\u001b[0m              <Duration as Sum>\u001b[0m\n\u001b[0m              <Gt as Sum<T>>\u001b[0m\n\u001b[0m              <Option<T> as Sum<Option<U>>>\u001b[0m\n\u001b[0m              <Result<T, E> as Sum<Result<U, E>>>\u001b[0m\n\u001b[0m              <Simd<f32, LANES> as Sum<&'a Simd<f32, LANES>>>\u001b[0m\n\u001b[0m              <Simd<f32, LANES> as Sum>\u001b[0m\n\u001b[0m              <Simd<f64, LANES> as Sum<&'a Simd<f64, LANES>>>\u001b[0m\n\u001b[0m            and 76 others\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;10mnote\u001b[0m\u001b[0m: required by a bound in `ff::Field`\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0m/Users/yugo/.cargo/registry/src/index.crates.io-6f17d22bba15001f/ff-0.13.0/src/lib.rs:62:7\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m62\u001b[0m\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m    + for<'a> Sum<&'a Self>\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m      \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;10m^^^^^^^^^^^^^^^^^^^^^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;10mrequired by this bound in `Field`\u001b[0m\n\n"}
{"message":"a value of type `fr::Fr` cannot be made by multiplying all elements of type `fr::Fr` from an iterator","code":{"code":"E0277","explanation":"You tried to use a type which doesn't implement some trait in a place which\nexpected that trait.\n\nErroneous code example:\n\n```compile_fail,E0277\n// here we declare the Foo trait with a bar method\ntrait Foo {\n    fn bar(&self);\n}\n\n// we now declare a function which takes an object implementing the Foo trait\nfn some_func<T: Foo>(foo: T) {\n    foo.bar();\n}\n\nfn main() {\n    // we now call the method with the i32 type, which doesn't implement\n    // the Foo trait\n    some_func(5i32); // error: the trait bound `i32 : Foo` is not satisfied\n}\n```\n\nIn order to fix this error, verify that the type you're using does implement\nthe trait. Example:\n\n```\ntrait Foo {\n    fn bar(&self);\n}\n\n// we implement the trait on the i32 type\nimpl Foo for i32 {\n    fn bar(&self) {}\n}\n\nfn some_func<T: Foo>(foo: T) {\n    foo.bar(); // we can now use this method since i32 implements the\n               // Foo trait\n}\n\nfn main() {\n    some_func(5i32); // ok!\n}\n```\n\nOr in a generic context, an erroneous code example would look like:\n\n```compile_fail,E0277\nfn some_func<T>(foo: T) {\n    println!(\"{:?}\", foo); // error: the trait `core::fmt::Debug` is not\n                           //        implemented for the type `T`\n}\n\nfn main() {\n    // We now call the method with the i32 type,\n    // which *does* implement the Debug trait.\n    some_func(5i32);\n}\n```\n\nNote that the error here is in the definition of the generic function. Although\nwe only call it with a parameter that does implement `Debug`, the compiler\nstill rejects the function. It must work with all possible input types. In\norder to make this example compile, we need to restrict the generic type we're\naccepting:\n\n```\nuse std::fmt;\n\n// Restrict the input type to types that implement Debug.\nfn some_func<T: fmt::Debug>(foo: T) {\n    println!(\"{:?}\", foo);\n}\n\nfn main() {\n    // Calling the method is still fine, as i32 implements Debug.\n    some_func(5i32);\n\n    // This would fail to compile now:\n    // struct WithoutDebug;\n    // some_func(WithoutDebug);\n}\n```\n\nRust only looks at the signature of the called function, as such it must\nalready specify all requirements that will be used for every type parameter.\n"},"level":"error","spans":[{"file_name":"/Users/yugo/.cargo/git/checkouts/pairing-e1005e25456a4f82/868f527/src/bn256/fr.rs","byte_start":2818,"byte_end":2820,"line_start":121,"line_end":121,"column_start":20,"column_end":22,"is_primary":true,"text":[{"text":"impl ff::Field for Fr {","highlight_start":20,"highlight_end":22}],"label":"value of type `fr::Fr` cannot be made by multiplying all elements from a `std::iter::Iterator<Item=fr::Fr>`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"the trait `Product` is not implemented for `fr::Fr`","code":null,"level":"help","spans":[],"children":[],"rendered":null},{"message":"the following other types implement trait `Product<A>`:\n  <Option<T> as Product<Option<U>>>\n  <Result<T, E> as Product<Result<U, E>>>\n  <Simd<f32, LANES> as Product<&'a Simd<f32, LANES>>>\n  <Simd<f32, LANES> as Product>\n  <Simd<f64, LANES> as Product<&'a Simd<f64, LANES>>>\n  <Simd<f64, LANES> as Product>\n  <Simd<i16, LANES> as Product<&'a Simd<i16, LANES>>>\n  <Simd<i16, LANES> as Product>\nand 70 others","code":null,"level":"help","spans":[],"children":[],"rendered":null},{"message":"required by a bound in `ff::Field`","code":null,"level":"note","spans":[{"file_name":"/Users/yugo/.cargo/registry/src/index.crates.io-6f17d22bba15001f/ff-0.13.0/src/lib.rs","byte_start":1337,"byte_end":1344,"line_start":58,"line_end":58,"column_start":7,"column_end":14,"is_primary":true,"text":[{"text":"    + Product","highlight_start":7,"highlight_end":14}],"label":"required by this bound in `Field`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0277]\u001b[0m\u001b[0m\u001b[1m: a value of type `fr::Fr` cannot be made by multiplying all elements of type `fr::Fr` from an iterator\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0m/Users/yugo/.cargo/git/checkouts/pairing-e1005e25456a4f82/868f527/src/bn256/fr.rs:121:20\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m121\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0mimpl ff::Field for Fr {\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m                   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9mvalue of type `fr::Fr` cannot be made by multiplying all elements from a `std::iter::Iterator<Item=fr::Fr>`\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mhelp\u001b[0m\u001b[0m: the trait `Product` is not implemented for `fr::Fr`\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mhelp\u001b[0m\u001b[0m: the following other types implement trait `Product<A>`:\u001b[0m\n\u001b[0m              <Option<T> as Product<Option<U>>>\u001b[0m\n\u001b[0m              <Result<T, E> as Product<Result<U, E>>>\u001b[0m\n\u001b[0m              <Simd<f32, LANES> as Product<&'a Simd<f32, LANES>>>\u001b[0m\n\u001b[0m              <Simd<f32, LANES> as Product>\u001b[0m\n\u001b[0m              <Simd<f64, LANES> as Product<&'a Simd<f64, LANES>>>\u001b[0m\n\u001b[0m              <Simd<f64, LANES> as Product>\u001b[0m\n\u001b[0m              <Simd<i16, LANES> as Product<&'a Simd<i16, LANES>>>\u001b[0m\n\u001b[0m              <Simd<i16, LANES> as Product>\u001b[0m\n\u001b[0m            and 70 others\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;10mnote\u001b[0m\u001b[0m: required by a bound in `ff::Field`\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0m/Users/yugo/.cargo/registry/src/index.crates.io-6f17d22bba15001f/ff-0.13.0/src/lib.rs:58:7\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m58\u001b[0m\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m    + Product\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m      \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;10m^^^^^^^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;10mrequired by this bound in `Field`\u001b[0m\n\n"}
{"message":"a value of type `fr::Fr` cannot be made by summing an iterator over elements of type `fr::Fr`","code":{"code":"E0277","explanation":"You tried to use a type which doesn't implement some trait in a place which\nexpected that trait.\n\nErroneous code example:\n\n```compile_fail,E0277\n// here we declare the Foo trait with a bar method\ntrait Foo {\n    fn bar(&self);\n}\n\n// we now declare a function which takes an object implementing the Foo trait\nfn some_func<T: Foo>(foo: T) {\n    foo.bar();\n}\n\nfn main() {\n    // we now call the method with the i32 type, which doesn't implement\n    // the Foo trait\n    some_func(5i32); // error: the trait bound `i32 : Foo` is not satisfied\n}\n```\n\nIn order to fix this error, verify that the type you're using does implement\nthe trait. Example:\n\n```\ntrait Foo {\n    fn bar(&self);\n}\n\n// we implement the trait on the i32 type\nimpl Foo for i32 {\n    fn bar(&self) {}\n}\n\nfn some_func<T: Foo>(foo: T) {\n    foo.bar(); // we can now use this method since i32 implements the\n               // Foo trait\n}\n\nfn main() {\n    some_func(5i32); // ok!\n}\n```\n\nOr in a generic context, an erroneous code example would look like:\n\n```compile_fail,E0277\nfn some_func<T>(foo: T) {\n    println!(\"{:?}\", foo); // error: the trait `core::fmt::Debug` is not\n                           //        implemented for the type `T`\n}\n\nfn main() {\n    // We now call the method with the i32 type,\n    // which *does* implement the Debug trait.\n    some_func(5i32);\n}\n```\n\nNote that the error here is in the definition of the generic function. Although\nwe only call it with a parameter that does implement `Debug`, the compiler\nstill rejects the function. It must work with all possible input types. In\norder to make this example compile, we need to restrict the generic type we're\naccepting:\n\n```\nuse std::fmt;\n\n// Restrict the input type to types that implement Debug.\nfn some_func<T: fmt::Debug>(foo: T) {\n    println!(\"{:?}\", foo);\n}\n\nfn main() {\n    // Calling the method is still fine, as i32 implements Debug.\n    some_func(5i32);\n\n    // This would fail to compile now:\n    // struct WithoutDebug;\n    // some_func(WithoutDebug);\n}\n```\n\nRust only looks at the signature of the called function, as such it must\nalready specify all requirements that will be used for every type parameter.\n"},"level":"error","spans":[{"file_name":"/Users/yugo/.cargo/git/checkouts/pairing-e1005e25456a4f82/868f527/src/bn256/fr.rs","byte_start":2818,"byte_end":2820,"line_start":121,"line_end":121,"column_start":20,"column_end":22,"is_primary":true,"text":[{"text":"impl ff::Field for Fr {","highlight_start":20,"highlight_end":22}],"label":"value of type `fr::Fr` cannot be made by summing a `std::iter::Iterator<Item=fr::Fr>`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"the trait `Sum` is not implemented for `fr::Fr`","code":null,"level":"help","spans":[],"children":[],"rendered":null},{"message":"the following other types implement trait `Sum<A>`:\n  <Duration as Sum<&'a Duration>>\n  <Duration as Sum>\n  <Gt as Sum<T>>\n  <Option<T> as Sum<Option<U>>>\n  <Result<T, E> as Sum<Result<U, E>>>\n  <Simd<f32, LANES> as Sum<&'a Simd<f32, LANES>>>\n  <Simd<f32, LANES> as Sum>\n  <Simd<f64, LANES> as Sum<&'a Simd<f64, LANES>>>\nand 76 others","code":null,"level":"help","spans":[],"children":[],"rendered":null},{"message":"required by a bound in `ff::Field`","code":null,"level":"note","spans":[{"file_name":"/Users/yugo/.cargo/registry/src/index.crates.io-6f17d22bba15001f/ff-0.13.0/src/lib.rs","byte_start":1327,"byte_end":1330,"line_start":57,"line_end":57,"column_start":7,"column_end":10,"is_primary":true,"text":[{"text":"    + Sum","highlight_start":7,"highlight_end":10}],"label":"required by this bound in `Field`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0277]\u001b[0m\u001b[0m\u001b[1m: a value of type `fr::Fr` cannot be made by summing an iterator over elements of type `fr::Fr`\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0m/Users/yugo/.cargo/git/checkouts/pairing-e1005e25456a4f82/868f527/src/bn256/fr.rs:121:20\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m121\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0mimpl ff::Field for Fr {\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m                   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9mvalue of type `fr::Fr` cannot be made by summing a `std::iter::Iterator<Item=fr::Fr>`\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mhelp\u001b[0m\u001b[0m: the trait `Sum` is not implemented for `fr::Fr`\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mhelp\u001b[0m\u001b[0m: the following other types implement trait `Sum<A>`:\u001b[0m\n\u001b[0m              <Duration as Sum<&'a Duration>>\u001b[0m\n\u001b[0m              <Duration as Sum>\u001b[0m\n\u001b[0m              <Gt as Sum<T>>\u001b[0m\n\u001b[0m              <Option<T> as Sum<Option<U>>>\u001b[0m\n\u001b[0m              <Result<T, E> as Sum<Result<U, E>>>\u001b[0m\n\u001b[0m              <Simd<f32, LANES> as Sum<&'a Simd<f32, LANES>>>\u001b[0m\n\u001b[0m              <Simd<f32, LANES> as Sum>\u001b[0m\n\u001b[0m              <Simd<f64, LANES> as Sum<&'a Simd<f64, LANES>>>\u001b[0m\n\u001b[0m            and 76 others\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;10mnote\u001b[0m\u001b[0m: required by a bound in `ff::Field`\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0m/Users/yugo/.cargo/registry/src/index.crates.io-6f17d22bba15001f/ff-0.13.0/src/lib.rs:57:7\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m57\u001b[0m\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m    + Sum\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m      \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;10m^^^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;10mrequired by this bound in `Field`\u001b[0m\n\n"}
{"message":"a value of type `fr::Fr` cannot be made by multiplying all elements of type `&'a fr::Fr` from an iterator","code":{"code":"E0277","explanation":"You tried to use a type which doesn't implement some trait in a place which\nexpected that trait.\n\nErroneous code example:\n\n```compile_fail,E0277\n// here we declare the Foo trait with a bar method\ntrait Foo {\n    fn bar(&self);\n}\n\n// we now declare a function which takes an object implementing the Foo trait\nfn some_func<T: Foo>(foo: T) {\n    foo.bar();\n}\n\nfn main() {\n    // we now call the method with the i32 type, which doesn't implement\n    // the Foo trait\n    some_func(5i32); // error: the trait bound `i32 : Foo` is not satisfied\n}\n```\n\nIn order to fix this error, verify that the type you're using does implement\nthe trait. Example:\n\n```\ntrait Foo {\n    fn bar(&self);\n}\n\n// we implement the trait on the i32 type\nimpl Foo for i32 {\n    fn bar(&self) {}\n}\n\nfn some_func<T: Foo>(foo: T) {\n    foo.bar(); // we can now use this method since i32 implements the\n               // Foo trait\n}\n\nfn main() {\n    some_func(5i32); // ok!\n}\n```\n\nOr in a generic context, an erroneous code example would look like:\n\n```compile_fail,E0277\nfn some_func<T>(foo: T) {\n    println!(\"{:?}\", foo); // error: the trait `core::fmt::Debug` is not\n                           //        implemented for the type `T`\n}\n\nfn main() {\n    // We now call the method with the i32 type,\n    // which *does* implement the Debug trait.\n    some_func(5i32);\n}\n```\n\nNote that the error here is in the definition of the generic function. Although\nwe only call it with a parameter that does implement `Debug`, the compiler\nstill rejects the function. It must work with all possible input types. In\norder to make this example compile, we need to restrict the generic type we're\naccepting:\n\n```\nuse std::fmt;\n\n// Restrict the input type to types that implement Debug.\nfn some_func<T: fmt::Debug>(foo: T) {\n    println!(\"{:?}\", foo);\n}\n\nfn main() {\n    // Calling the method is still fine, as i32 implements Debug.\n    some_func(5i32);\n\n    // This would fail to compile now:\n    // struct WithoutDebug;\n    // some_func(WithoutDebug);\n}\n```\n\nRust only looks at the signature of the called function, as such it must\nalready specify all requirements that will be used for every type parameter.\n"},"level":"error","spans":[{"file_name":"/Users/yugo/.cargo/git/checkouts/pairing-e1005e25456a4f82/868f527/src/bn256/fr.rs","byte_start":3985,"byte_end":3987,"line_start":175,"line_end":175,"column_start":25,"column_end":27,"is_primary":true,"text":[{"text":"impl ff::PrimeField for Fr {","highlight_start":25,"highlight_end":27}],"label":"value of type `fr::Fr` cannot be made by multiplying all elements from a `std::iter::Iterator<Item=&'a fr::Fr>`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"the trait `for<'a> Product<&'a fr::Fr>` is not implemented for `fr::Fr`","code":null,"level":"help","spans":[],"children":[],"rendered":null},{"message":"the following other types implement trait `Product<A>`:\n  <Option<T> as Product<Option<U>>>\n  <Result<T, E> as Product<Result<U, E>>>\n  <Simd<f32, LANES> as Product<&'a Simd<f32, LANES>>>\n  <Simd<f32, LANES> as Product>\n  <Simd<f64, LANES> as Product<&'a Simd<f64, LANES>>>\n  <Simd<f64, LANES> as Product>\n  <Simd<i16, LANES> as Product<&'a Simd<i16, LANES>>>\n  <Simd<i16, LANES> as Product>\nand 70 others","code":null,"level":"help","spans":[],"children":[],"rendered":null},{"message":"required for `fr::Fr` to implement `ff::Field`","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"required by a bound in `ff::PrimeField`","code":null,"level":"note","spans":[{"file_name":"/Users/yugo/.cargo/registry/src/index.crates.io-6f17d22bba15001f/ff-0.13.0/src/lib.rs","byte_start":5874,"byte_end":5879,"line_start":195,"line_end":195,"column_start":23,"column_end":28,"is_primary":true,"text":[{"text":"pub trait PrimeField: Field + From<u64> {","highlight_start":23,"highlight_end":28}],"label":"required by this bound in `PrimeField`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0277]\u001b[0m\u001b[0m\u001b[1m: a value of type `fr::Fr` cannot be made by multiplying all elements of type `&'a fr::Fr` from an iterator\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0m/Users/yugo/.cargo/git/checkouts/pairing-e1005e25456a4f82/868f527/src/bn256/fr.rs:175:25\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m175\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0mimpl ff::PrimeField for Fr {\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m                        \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9mvalue of type `fr::Fr` cannot be made by multiplying all elements from a `std::iter::Iterator<Item=&'a fr::Fr>`\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mhelp\u001b[0m\u001b[0m: the trait `for<'a> Product<&'a fr::Fr>` is not implemented for `fr::Fr`\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mhelp\u001b[0m\u001b[0m: the following other types implement trait `Product<A>`:\u001b[0m\n\u001b[0m              <Option<T> as Product<Option<U>>>\u001b[0m\n\u001b[0m              <Result<T, E> as Product<Result<U, E>>>\u001b[0m\n\u001b[0m              <Simd<f32, LANES> as Product<&'a Simd<f32, LANES>>>\u001b[0m\n\u001b[0m              <Simd<f32, LANES> as Product>\u001b[0m\n\u001b[0m              <Simd<f64, LANES> as Product<&'a Simd<f64, LANES>>>\u001b[0m\n\u001b[0m              <Simd<f64, LANES> as Product>\u001b[0m\n\u001b[0m              <Simd<i16, LANES> as Product<&'a Simd<i16, LANES>>>\u001b[0m\n\u001b[0m              <Simd<i16, LANES> as Product>\u001b[0m\n\u001b[0m            and 70 others\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mnote\u001b[0m\u001b[0m: required for `fr::Fr` to implement `ff::Field`\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;10mnote\u001b[0m\u001b[0m: required by a bound in `ff::PrimeField`\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0m/Users/yugo/.cargo/registry/src/index.crates.io-6f17d22bba15001f/ff-0.13.0/src/lib.rs:195:23\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m195\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0mpub trait PrimeField: Field + From<u64> {\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m                      \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;10m^^^^^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;10mrequired by this bound in `PrimeField`\u001b[0m\n\n"}
{"message":"a value of type `fr::Fr` cannot be made by summing an iterator over elements of type `&'a fr::Fr`","code":{"code":"E0277","explanation":"You tried to use a type which doesn't implement some trait in a place which\nexpected that trait.\n\nErroneous code example:\n\n```compile_fail,E0277\n// here we declare the Foo trait with a bar method\ntrait Foo {\n    fn bar(&self);\n}\n\n// we now declare a function which takes an object implementing the Foo trait\nfn some_func<T: Foo>(foo: T) {\n    foo.bar();\n}\n\nfn main() {\n    // we now call the method with the i32 type, which doesn't implement\n    // the Foo trait\n    some_func(5i32); // error: the trait bound `i32 : Foo` is not satisfied\n}\n```\n\nIn order to fix this error, verify that the type you're using does implement\nthe trait. Example:\n\n```\ntrait Foo {\n    fn bar(&self);\n}\n\n// we implement the trait on the i32 type\nimpl Foo for i32 {\n    fn bar(&self) {}\n}\n\nfn some_func<T: Foo>(foo: T) {\n    foo.bar(); // we can now use this method since i32 implements the\n               // Foo trait\n}\n\nfn main() {\n    some_func(5i32); // ok!\n}\n```\n\nOr in a generic context, an erroneous code example would look like:\n\n```compile_fail,E0277\nfn some_func<T>(foo: T) {\n    println!(\"{:?}\", foo); // error: the trait `core::fmt::Debug` is not\n                           //        implemented for the type `T`\n}\n\nfn main() {\n    // We now call the method with the i32 type,\n    // which *does* implement the Debug trait.\n    some_func(5i32);\n}\n```\n\nNote that the error here is in the definition of the generic function. Although\nwe only call it with a parameter that does implement `Debug`, the compiler\nstill rejects the function. It must work with all possible input types. In\norder to make this example compile, we need to restrict the generic type we're\naccepting:\n\n```\nuse std::fmt;\n\n// Restrict the input type to types that implement Debug.\nfn some_func<T: fmt::Debug>(foo: T) {\n    println!(\"{:?}\", foo);\n}\n\nfn main() {\n    // Calling the method is still fine, as i32 implements Debug.\n    some_func(5i32);\n\n    // This would fail to compile now:\n    // struct WithoutDebug;\n    // some_func(WithoutDebug);\n}\n```\n\nRust only looks at the signature of the called function, as such it must\nalready specify all requirements that will be used for every type parameter.\n"},"level":"error","spans":[{"file_name":"/Users/yugo/.cargo/git/checkouts/pairing-e1005e25456a4f82/868f527/src/bn256/fr.rs","byte_start":3985,"byte_end":3987,"line_start":175,"line_end":175,"column_start":25,"column_end":27,"is_primary":true,"text":[{"text":"impl ff::PrimeField for Fr {","highlight_start":25,"highlight_end":27}],"label":"value of type `fr::Fr` cannot be made by summing a `std::iter::Iterator<Item=&'a fr::Fr>`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"the trait `for<'a> Sum<&'a fr::Fr>` is not implemented for `fr::Fr`","code":null,"level":"help","spans":[],"children":[],"rendered":null},{"message":"the following other types implement trait `Sum<A>`:\n  <Duration as Sum<&'a Duration>>\n  <Duration as Sum>\n  <Gt as Sum<T>>\n  <Option<T> as Sum<Option<U>>>\n  <Result<T, E> as Sum<Result<U, E>>>\n  <Simd<f32, LANES> as Sum<&'a Simd<f32, LANES>>>\n  <Simd<f32, LANES> as Sum>\n  <Simd<f64, LANES> as Sum<&'a Simd<f64, LANES>>>\nand 76 others","code":null,"level":"help","spans":[],"children":[],"rendered":null},{"message":"required for `fr::Fr` to implement `ff::Field`","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"required by a bound in `ff::PrimeField`","code":null,"level":"note","spans":[{"file_name":"/Users/yugo/.cargo/registry/src/index.crates.io-6f17d22bba15001f/ff-0.13.0/src/lib.rs","byte_start":5874,"byte_end":5879,"line_start":195,"line_end":195,"column_start":23,"column_end":28,"is_primary":true,"text":[{"text":"pub trait PrimeField: Field + From<u64> {","highlight_start":23,"highlight_end":28}],"label":"required by this bound in `PrimeField`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0277]\u001b[0m\u001b[0m\u001b[1m: a value of type `fr::Fr` cannot be made by summing an iterator over elements of type `&'a fr::Fr`\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0m/Users/yugo/.cargo/git/checkouts/pairing-e1005e25456a4f82/868f527/src/bn256/fr.rs:175:25\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m175\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0mimpl ff::PrimeField for Fr {\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m                        \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9mvalue of type `fr::Fr` cannot be made by summing a `std::iter::Iterator<Item=&'a fr::Fr>`\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mhelp\u001b[0m\u001b[0m: the trait `for<'a> Sum<&'a fr::Fr>` is not implemented for `fr::Fr`\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mhelp\u001b[0m\u001b[0m: the following other types implement trait `Sum<A>`:\u001b[0m\n\u001b[0m              <Duration as Sum<&'a Duration>>\u001b[0m\n\u001b[0m              <Duration as Sum>\u001b[0m\n\u001b[0m              <Gt as Sum<T>>\u001b[0m\n\u001b[0m              <Option<T> as Sum<Option<U>>>\u001b[0m\n\u001b[0m              <Result<T, E> as Sum<Result<U, E>>>\u001b[0m\n\u001b[0m              <Simd<f32, LANES> as Sum<&'a Simd<f32, LANES>>>\u001b[0m\n\u001b[0m              <Simd<f32, LANES> as Sum>\u001b[0m\n\u001b[0m              <Simd<f64, LANES> as Sum<&'a Simd<f64, LANES>>>\u001b[0m\n\u001b[0m            and 76 others\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mnote\u001b[0m\u001b[0m: required for `fr::Fr` to implement `ff::Field`\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;10mnote\u001b[0m\u001b[0m: required by a bound in `ff::PrimeField`\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0m/Users/yugo/.cargo/registry/src/index.crates.io-6f17d22bba15001f/ff-0.13.0/src/lib.rs:195:23\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m195\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0mpub trait PrimeField: Field + From<u64> {\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m                      \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;10m^^^^^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;10mrequired by this bound in `PrimeField`\u001b[0m\n\n"}
{"message":"a value of type `fr::Fr` cannot be made by multiplying all elements of type `fr::Fr` from an iterator","code":{"code":"E0277","explanation":"You tried to use a type which doesn't implement some trait in a place which\nexpected that trait.\n\nErroneous code example:\n\n```compile_fail,E0277\n// here we declare the Foo trait with a bar method\ntrait Foo {\n    fn bar(&self);\n}\n\n// we now declare a function which takes an object implementing the Foo trait\nfn some_func<T: Foo>(foo: T) {\n    foo.bar();\n}\n\nfn main() {\n    // we now call the method with the i32 type, which doesn't implement\n    // the Foo trait\n    some_func(5i32); // error: the trait bound `i32 : Foo` is not satisfied\n}\n```\n\nIn order to fix this error, verify that the type you're using does implement\nthe trait. Example:\n\n```\ntrait Foo {\n    fn bar(&self);\n}\n\n// we implement the trait on the i32 type\nimpl Foo for i32 {\n    fn bar(&self) {}\n}\n\nfn some_func<T: Foo>(foo: T) {\n    foo.bar(); // we can now use this method since i32 implements the\n               // Foo trait\n}\n\nfn main() {\n    some_func(5i32); // ok!\n}\n```\n\nOr in a generic context, an erroneous code example would look like:\n\n```compile_fail,E0277\nfn some_func<T>(foo: T) {\n    println!(\"{:?}\", foo); // error: the trait `core::fmt::Debug` is not\n                           //        implemented for the type `T`\n}\n\nfn main() {\n    // We now call the method with the i32 type,\n    // which *does* implement the Debug trait.\n    some_func(5i32);\n}\n```\n\nNote that the error here is in the definition of the generic function. Although\nwe only call it with a parameter that does implement `Debug`, the compiler\nstill rejects the function. It must work with all possible input types. In\norder to make this example compile, we need to restrict the generic type we're\naccepting:\n\n```\nuse std::fmt;\n\n// Restrict the input type to types that implement Debug.\nfn some_func<T: fmt::Debug>(foo: T) {\n    println!(\"{:?}\", foo);\n}\n\nfn main() {\n    // Calling the method is still fine, as i32 implements Debug.\n    some_func(5i32);\n\n    // This would fail to compile now:\n    // struct WithoutDebug;\n    // some_func(WithoutDebug);\n}\n```\n\nRust only looks at the signature of the called function, as such it must\nalready specify all requirements that will be used for every type parameter.\n"},"level":"error","spans":[{"file_name":"/Users/yugo/.cargo/git/checkouts/pairing-e1005e25456a4f82/868f527/src/bn256/fr.rs","byte_start":3985,"byte_end":3987,"line_start":175,"line_end":175,"column_start":25,"column_end":27,"is_primary":true,"text":[{"text":"impl ff::PrimeField for Fr {","highlight_start":25,"highlight_end":27}],"label":"value of type `fr::Fr` cannot be made by multiplying all elements from a `std::iter::Iterator<Item=fr::Fr>`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"the trait `Product` is not implemented for `fr::Fr`","code":null,"level":"help","spans":[],"children":[],"rendered":null},{"message":"the following other types implement trait `Product<A>`:\n  <Option<T> as Product<Option<U>>>\n  <Result<T, E> as Product<Result<U, E>>>\n  <Simd<f32, LANES> as Product<&'a Simd<f32, LANES>>>\n  <Simd<f32, LANES> as Product>\n  <Simd<f64, LANES> as Product<&'a Simd<f64, LANES>>>\n  <Simd<f64, LANES> as Product>\n  <Simd<i16, LANES> as Product<&'a Simd<i16, LANES>>>\n  <Simd<i16, LANES> as Product>\nand 70 others","code":null,"level":"help","spans":[],"children":[],"rendered":null},{"message":"required for `fr::Fr` to implement `ff::Field`","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"required by a bound in `ff::PrimeField`","code":null,"level":"note","spans":[{"file_name":"/Users/yugo/.cargo/registry/src/index.crates.io-6f17d22bba15001f/ff-0.13.0/src/lib.rs","byte_start":5874,"byte_end":5879,"line_start":195,"line_end":195,"column_start":23,"column_end":28,"is_primary":true,"text":[{"text":"pub trait PrimeField: Field + From<u64> {","highlight_start":23,"highlight_end":28}],"label":"required by this bound in `PrimeField`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0277]\u001b[0m\u001b[0m\u001b[1m: a value of type `fr::Fr` cannot be made by multiplying all elements of type `fr::Fr` from an iterator\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0m/Users/yugo/.cargo/git/checkouts/pairing-e1005e25456a4f82/868f527/src/bn256/fr.rs:175:25\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m175\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0mimpl ff::PrimeField for Fr {\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m                        \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9mvalue of type `fr::Fr` cannot be made by multiplying all elements from a `std::iter::Iterator<Item=fr::Fr>`\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mhelp\u001b[0m\u001b[0m: the trait `Product` is not implemented for `fr::Fr`\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mhelp\u001b[0m\u001b[0m: the following other types implement trait `Product<A>`:\u001b[0m\n\u001b[0m              <Option<T> as Product<Option<U>>>\u001b[0m\n\u001b[0m              <Result<T, E> as Product<Result<U, E>>>\u001b[0m\n\u001b[0m              <Simd<f32, LANES> as Product<&'a Simd<f32, LANES>>>\u001b[0m\n\u001b[0m              <Simd<f32, LANES> as Product>\u001b[0m\n\u001b[0m              <Simd<f64, LANES> as Product<&'a Simd<f64, LANES>>>\u001b[0m\n\u001b[0m              <Simd<f64, LANES> as Product>\u001b[0m\n\u001b[0m              <Simd<i16, LANES> as Product<&'a Simd<i16, LANES>>>\u001b[0m\n\u001b[0m              <Simd<i16, LANES> as Product>\u001b[0m\n\u001b[0m            and 70 others\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mnote\u001b[0m\u001b[0m: required for `fr::Fr` to implement `ff::Field`\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;10mnote\u001b[0m\u001b[0m: required by a bound in `ff::PrimeField`\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0m/Users/yugo/.cargo/registry/src/index.crates.io-6f17d22bba15001f/ff-0.13.0/src/lib.rs:195:23\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m195\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0mpub trait PrimeField: Field + From<u64> {\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m                      \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;10m^^^^^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;10mrequired by this bound in `PrimeField`\u001b[0m\n\n"}
{"message":"a value of type `fr::Fr` cannot be made by summing an iterator over elements of type `fr::Fr`","code":{"code":"E0277","explanation":"You tried to use a type which doesn't implement some trait in a place which\nexpected that trait.\n\nErroneous code example:\n\n```compile_fail,E0277\n// here we declare the Foo trait with a bar method\ntrait Foo {\n    fn bar(&self);\n}\n\n// we now declare a function which takes an object implementing the Foo trait\nfn some_func<T: Foo>(foo: T) {\n    foo.bar();\n}\n\nfn main() {\n    // we now call the method with the i32 type, which doesn't implement\n    // the Foo trait\n    some_func(5i32); // error: the trait bound `i32 : Foo` is not satisfied\n}\n```\n\nIn order to fix this error, verify that the type you're using does implement\nthe trait. Example:\n\n```\ntrait Foo {\n    fn bar(&self);\n}\n\n// we implement the trait on the i32 type\nimpl Foo for i32 {\n    fn bar(&self) {}\n}\n\nfn some_func<T: Foo>(foo: T) {\n    foo.bar(); // we can now use this method since i32 implements the\n               // Foo trait\n}\n\nfn main() {\n    some_func(5i32); // ok!\n}\n```\n\nOr in a generic context, an erroneous code example would look like:\n\n```compile_fail,E0277\nfn some_func<T>(foo: T) {\n    println!(\"{:?}\", foo); // error: the trait `core::fmt::Debug` is not\n                           //        implemented for the type `T`\n}\n\nfn main() {\n    // We now call the method with the i32 type,\n    // which *does* implement the Debug trait.\n    some_func(5i32);\n}\n```\n\nNote that the error here is in the definition of the generic function. Although\nwe only call it with a parameter that does implement `Debug`, the compiler\nstill rejects the function. It must work with all possible input types. In\norder to make this example compile, we need to restrict the generic type we're\naccepting:\n\n```\nuse std::fmt;\n\n// Restrict the input type to types that implement Debug.\nfn some_func<T: fmt::Debug>(foo: T) {\n    println!(\"{:?}\", foo);\n}\n\nfn main() {\n    // Calling the method is still fine, as i32 implements Debug.\n    some_func(5i32);\n\n    // This would fail to compile now:\n    // struct WithoutDebug;\n    // some_func(WithoutDebug);\n}\n```\n\nRust only looks at the signature of the called function, as such it must\nalready specify all requirements that will be used for every type parameter.\n"},"level":"error","spans":[{"file_name":"/Users/yugo/.cargo/git/checkouts/pairing-e1005e25456a4f82/868f527/src/bn256/fr.rs","byte_start":3985,"byte_end":3987,"line_start":175,"line_end":175,"column_start":25,"column_end":27,"is_primary":true,"text":[{"text":"impl ff::PrimeField for Fr {","highlight_start":25,"highlight_end":27}],"label":"value of type `fr::Fr` cannot be made by summing a `std::iter::Iterator<Item=fr::Fr>`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"the trait `Sum` is not implemented for `fr::Fr`","code":null,"level":"help","spans":[],"children":[],"rendered":null},{"message":"the following other types implement trait `Sum<A>`:\n  <Duration as Sum<&'a Duration>>\n  <Duration as Sum>\n  <Gt as Sum<T>>\n  <Option<T> as Sum<Option<U>>>\n  <Result<T, E> as Sum<Result<U, E>>>\n  <Simd<f32, LANES> as Sum<&'a Simd<f32, LANES>>>\n  <Simd<f32, LANES> as Sum>\n  <Simd<f64, LANES> as Sum<&'a Simd<f64, LANES>>>\nand 76 others","code":null,"level":"help","spans":[],"children":[],"rendered":null},{"message":"required for `fr::Fr` to implement `ff::Field`","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"required by a bound in `ff::PrimeField`","code":null,"level":"note","spans":[{"file_name":"/Users/yugo/.cargo/registry/src/index.crates.io-6f17d22bba15001f/ff-0.13.0/src/lib.rs","byte_start":5874,"byte_end":5879,"line_start":195,"line_end":195,"column_start":23,"column_end":28,"is_primary":true,"text":[{"text":"pub trait PrimeField: Field + From<u64> {","highlight_start":23,"highlight_end":28}],"label":"required by this bound in `PrimeField`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0277]\u001b[0m\u001b[0m\u001b[1m: a value of type `fr::Fr` cannot be made by summing an iterator over elements of type `fr::Fr`\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0m/Users/yugo/.cargo/git/checkouts/pairing-e1005e25456a4f82/868f527/src/bn256/fr.rs:175:25\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m175\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0mimpl ff::PrimeField for Fr {\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m                        \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9mvalue of type `fr::Fr` cannot be made by summing a `std::iter::Iterator<Item=fr::Fr>`\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mhelp\u001b[0m\u001b[0m: the trait `Sum` is not implemented for `fr::Fr`\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mhelp\u001b[0m\u001b[0m: the following other types implement trait `Sum<A>`:\u001b[0m\n\u001b[0m              <Duration as Sum<&'a Duration>>\u001b[0m\n\u001b[0m              <Duration as Sum>\u001b[0m\n\u001b[0m              <Gt as Sum<T>>\u001b[0m\n\u001b[0m              <Option<T> as Sum<Option<U>>>\u001b[0m\n\u001b[0m              <Result<T, E> as Sum<Result<U, E>>>\u001b[0m\n\u001b[0m              <Simd<f32, LANES> as Sum<&'a Simd<f32, LANES>>>\u001b[0m\n\u001b[0m              <Simd<f32, LANES> as Sum>\u001b[0m\n\u001b[0m              <Simd<f64, LANES> as Sum<&'a Simd<f64, LANES>>>\u001b[0m\n\u001b[0m            and 76 others\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mnote\u001b[0m\u001b[0m: required for `fr::Fr` to implement `ff::Field`\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;10mnote\u001b[0m\u001b[0m: required by a bound in `ff::PrimeField`\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0m/Users/yugo/.cargo/registry/src/index.crates.io-6f17d22bba15001f/ff-0.13.0/src/lib.rs:195:23\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m195\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0mpub trait PrimeField: Field + From<u64> {\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m                      \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;10m^^^^^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;10mrequired by this bound in `PrimeField`\u001b[0m\n\n"}
{"message":"aborting due to 62 previous errors","code":null,"level":"error","spans":[],"children":[],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror\u001b[0m\u001b[0m\u001b[1m: aborting due to 62 previous errors\u001b[0m\n\n"}
{"message":"Some errors have detailed explanations: E0277, E0407.","code":null,"level":"failure-note","spans":[],"children":[],"rendered":"\u001b[0m\u001b[1mSome errors have detailed explanations: E0277, E0407.\u001b[0m\n"}
{"message":"For more information about an error, try `rustc --explain E0277`.","code":null,"level":"failure-note","spans":[],"children":[],"rendered":"\u001b[0m\u001b[1mFor more information about an error, try `rustc --explain E0277`.\u001b[0m\n"}
